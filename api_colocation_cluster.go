/*
Cisco SD-WAN vManage API

The vManage API exposes the functionality of operations maintaining devices and the overlay network

API version: 2.0.0
Contact: vmanage@cisco.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// ColocationClusterApiService ColocationClusterApi service
type ColocationClusterApiService service

type ApiAcitvateCloudDockClusterRequest struct {
	ctx context.Context
	ApiService *ColocationClusterApiService
	clusterName *string
}

// Cluster name
func (r ApiAcitvateCloudDockClusterRequest) ClusterName(clusterName string) ApiAcitvateCloudDockClusterRequest {
	r.clusterName = &clusterName
	return r
}

func (r ApiAcitvateCloudDockClusterRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.AcitvateCloudDockClusterExecute(r)
}

/*
AcitvateCloudDockCluster Method for AcitvateCloudDockCluster

Activate a cluster

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAcitvateCloudDockClusterRequest
*/
func (a *ColocationClusterApiService) AcitvateCloudDockCluster(ctx context.Context) ApiAcitvateCloudDockClusterRequest {
	return ApiAcitvateCloudDockClusterRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ColocationClusterApiService) AcitvateCloudDockClusterExecute(r ApiAcitvateCloudDockClusterRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ColocationClusterApiService.AcitvateCloudDockCluster")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/colocation/cluster/activate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.clusterName == nil {
		return localVarReturnValue, nil, reportError("clusterName is required and must be specified")
	}

	localVarQueryParams.Add("clusterName", parameterToString(*r.clusterName, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCloudDockClusterPreviewRequest struct {
	ctx context.Context
	ApiService *ColocationClusterApiService
	serialNumber *string
}

// Serial number
func (r ApiCloudDockClusterPreviewRequest) SerialNumber(serialNumber string) ApiCloudDockClusterPreviewRequest {
	r.serialNumber = &serialNumber
	return r
}

func (r ApiCloudDockClusterPreviewRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.CloudDockClusterPreviewExecute(r)
}

/*
CloudDockClusterPreview Method for CloudDockClusterPreview

Clouddock cluster preview

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCloudDockClusterPreviewRequest
*/
func (a *ColocationClusterApiService) CloudDockClusterPreview(ctx context.Context) ApiCloudDockClusterPreviewRequest {
	return ApiCloudDockClusterPreviewRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return string
func (a *ColocationClusterApiService) CloudDockClusterPreviewExecute(r ApiCloudDockClusterPreviewRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ColocationClusterApiService.CloudDockClusterPreview")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/colocation/cluster/config"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.serialNumber == nil {
		return localVarReturnValue, nil, reportError("serialNumber is required and must be specified")
	}

	localVarQueryParams.Add("serialNumber", parameterToString(*r.serialNumber, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateCloudDockClusterRequest struct {
	ctx context.Context
	ApiService *ColocationClusterApiService
	body *map[string]interface{}
}

// Cluster config
func (r ApiCreateCloudDockClusterRequest) Body(body map[string]interface{}) ApiCreateCloudDockClusterRequest {
	r.body = &body
	return r
}

func (r ApiCreateCloudDockClusterRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateCloudDockClusterExecute(r)
}

/*
CreateCloudDockCluster Method for CreateCloudDockCluster

Add a new cluster

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateCloudDockClusterRequest
*/
func (a *ColocationClusterApiService) CreateCloudDockCluster(ctx context.Context) ApiCreateCloudDockClusterRequest {
	return ApiCreateCloudDockClusterRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ColocationClusterApiService) CreateCloudDockClusterExecute(r ApiCreateCloudDockClusterRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ColocationClusterApiService.CreateCloudDockCluster")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/colocation/cluster"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeAcitvateCloudDockClusterRequest struct {
	ctx context.Context
	ApiService *ColocationClusterApiService
	clusterId *string
}

// Cluster Id
func (r ApiDeAcitvateCloudDockClusterRequest) ClusterId(clusterId string) ApiDeAcitvateCloudDockClusterRequest {
	r.clusterId = &clusterId
	return r
}

func (r ApiDeAcitvateCloudDockClusterRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeAcitvateCloudDockClusterExecute(r)
}

/*
DeAcitvateCloudDockCluster Method for DeAcitvateCloudDockCluster

Deactivate clouddock cluster

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeAcitvateCloudDockClusterRequest
*/
func (a *ColocationClusterApiService) DeAcitvateCloudDockCluster(ctx context.Context) ApiDeAcitvateCloudDockClusterRequest {
	return ApiDeAcitvateCloudDockClusterRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ColocationClusterApiService) DeAcitvateCloudDockClusterExecute(r ApiDeAcitvateCloudDockClusterRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ColocationClusterApiService.DeAcitvateCloudDockCluster")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/colocation/cluster/deactivate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.clusterId == nil {
		return nil, reportError("clusterId is required and must be specified")
	}

	localVarQueryParams.Add("clusterId", parameterToString(*r.clusterId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteCloudDockClusterByNameRequest struct {
	ctx context.Context
	ApiService *ColocationClusterApiService
	clustername string
}

func (r ApiDeleteCloudDockClusterByNameRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteCloudDockClusterByNameExecute(r)
}

/*
DeleteCloudDockClusterByName Method for DeleteCloudDockClusterByName

Delete cluster by name

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clustername Cluster name
 @return ApiDeleteCloudDockClusterByNameRequest
*/
func (a *ColocationClusterApiService) DeleteCloudDockClusterByName(ctx context.Context, clustername string) ApiDeleteCloudDockClusterByNameRequest {
	return ApiDeleteCloudDockClusterByNameRequest{
		ApiService: a,
		ctx: ctx,
		clustername: clustername,
	}
}

// Execute executes the request
func (a *ColocationClusterApiService) DeleteCloudDockClusterByNameExecute(r ApiDeleteCloudDockClusterByNameRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ColocationClusterApiService.DeleteCloudDockClusterByName")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/colocation/cluster/{clustername}"
	localVarPath = strings.Replace(localVarPath, "{"+"clustername"+"}", url.PathEscape(parameterToString(r.clustername, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDummyccmRequest struct {
	ctx context.Context
	ApiService *ColocationClusterApiService
	clusterName *string
}

// Cluster name
func (r ApiDummyccmRequest) ClusterName(clusterName string) ApiDummyccmRequest {
	r.clusterName = &clusterName
	return r
}

func (r ApiDummyccmRequest) Execute() (*http.Response, error) {
	return r.ApiService.DummyccmExecute(r)
}

/*
Dummyccm Method for Dummyccm

Activate dummp cluster

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDummyccmRequest
*/
func (a *ColocationClusterApiService) Dummyccm(ctx context.Context) ApiDummyccmRequest {
	return ApiDummyccmRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ColocationClusterApiService) DummyccmExecute(r ApiDummyccmRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ColocationClusterApiService.Dummyccm")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/colocation/cluster/activateClusterDummy"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.clusterName == nil {
		return nil, reportError("clusterName is required and must be specified")
	}

	localVarQueryParams.Add("clusterName", parameterToString(*r.clusterName, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDummycspStateRequest struct {
	ctx context.Context
	ApiService *ColocationClusterApiService
	clusterName *string
	state *string
}

// Cluster name
func (r ApiDummycspStateRequest) ClusterName(clusterName string) ApiDummycspStateRequest {
	r.clusterName = &clusterName
	return r
}

// Cluster state
func (r ApiDummycspStateRequest) State(state string) ApiDummycspStateRequest {
	r.state = &state
	return r
}

func (r ApiDummycspStateRequest) Execute() (*http.Response, error) {
	return r.ApiService.DummycspStateExecute(r)
}

/*
DummycspState Method for DummycspState

Activate cluster in a state

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDummycspStateRequest
*/
func (a *ColocationClusterApiService) DummycspState(ctx context.Context) ApiDummycspStateRequest {
	return ApiDummycspStateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ColocationClusterApiService) DummycspStateExecute(r ApiDummycspStateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ColocationClusterApiService.DummycspState")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/colocation/cluster/activateClusterDummyState"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.clusterName == nil {
		return nil, reportError("clusterName is required and must be specified")
	}
	if r.state == nil {
		return nil, reportError("state is required and must be specified")
	}

	localVarQueryParams.Add("clusterName", parameterToString(*r.clusterName, ""))
	localVarQueryParams.Add("state", parameterToString(*r.state, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetCloudDockClusterDetailRequest struct {
	ctx context.Context
	ApiService *ColocationClusterApiService
	clusterName *string
}

// Cluster name
func (r ApiGetCloudDockClusterDetailRequest) ClusterName(clusterName string) ApiGetCloudDockClusterDetailRequest {
	r.clusterName = &clusterName
	return r
}

func (r ApiGetCloudDockClusterDetailRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetCloudDockClusterDetailExecute(r)
}

/*
GetCloudDockClusterDetail Method for GetCloudDockClusterDetail

Get details of all existing Clusters

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCloudDockClusterDetailRequest
*/
func (a *ColocationClusterApiService) GetCloudDockClusterDetail(ctx context.Context) ApiGetCloudDockClusterDetailRequest {
	return ApiGetCloudDockClusterDetailRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ColocationClusterApiService) GetCloudDockClusterDetailExecute(r ApiGetCloudDockClusterDetailRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ColocationClusterApiService.GetCloudDockClusterDetail")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/colocation/cluster"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.clusterName == nil {
		return localVarReturnValue, nil, reportError("clusterName is required and must be specified")
	}

	localVarQueryParams.Add("clusterName", parameterToString(*r.clusterName, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCloudDockClusterDetailByIdRequest struct {
	ctx context.Context
	ApiService *ColocationClusterApiService
	clusterId *string
}

// Cluster Id
func (r ApiGetCloudDockClusterDetailByIdRequest) ClusterId(clusterId string) ApiGetCloudDockClusterDetailByIdRequest {
	r.clusterId = &clusterId
	return r
}

func (r ApiGetCloudDockClusterDetailByIdRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetCloudDockClusterDetailByIdExecute(r)
}

/*
GetCloudDockClusterDetailById Method for GetCloudDockClusterDetailById

Get cluster by Id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCloudDockClusterDetailByIdRequest
*/
func (a *ColocationClusterApiService) GetCloudDockClusterDetailById(ctx context.Context) ApiGetCloudDockClusterDetailByIdRequest {
	return ApiGetCloudDockClusterDetailByIdRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ColocationClusterApiService) GetCloudDockClusterDetailByIdExecute(r ApiGetCloudDockClusterDetailByIdRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ColocationClusterApiService.GetCloudDockClusterDetailById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/colocation/cluster/id"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.clusterId == nil {
		return localVarReturnValue, nil, reportError("clusterId is required and must be specified")
	}

	localVarQueryParams.Add("clusterId", parameterToString(*r.clusterId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRmaCloudDockCspRequest struct {
	ctx context.Context
	ApiService *ColocationClusterApiService
	clusterName *string
	body *string
}

// Cluster name
func (r ApiRmaCloudDockCspRequest) ClusterName(clusterName string) ApiRmaCloudDockCspRequest {
	r.clusterName = &clusterName
	return r
}

func (r ApiRmaCloudDockCspRequest) Body(body string) ApiRmaCloudDockCspRequest {
	r.body = &body
	return r
}

func (r ApiRmaCloudDockCspRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.RmaCloudDockCspExecute(r)
}

/*
RmaCloudDockCsp Method for RmaCloudDockCsp

RMA operation for CSP device

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRmaCloudDockCspRequest
*/
func (a *ColocationClusterApiService) RmaCloudDockCsp(ctx context.Context) ApiRmaCloudDockCspRequest {
	return ApiRmaCloudDockCspRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ColocationClusterApiService) RmaCloudDockCspExecute(r ApiRmaCloudDockCspRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ColocationClusterApiService.RmaCloudDockCsp")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/colocation/cluster/rma"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.clusterName == nil {
		return localVarReturnValue, nil, reportError("clusterName is required and must be specified")
	}

	localVarQueryParams.Add("clusterName", parameterToString(*r.clusterName, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateCloudDockClusterRequest struct {
	ctx context.Context
	ApiService *ColocationClusterApiService
	body *map[string]interface{}
}

// Cluster config
func (r ApiUpdateCloudDockClusterRequest) Body(body map[string]interface{}) ApiUpdateCloudDockClusterRequest {
	r.body = &body
	return r
}

func (r ApiUpdateCloudDockClusterRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateCloudDockClusterExecute(r)
}

/*
UpdateCloudDockCluster Method for UpdateCloudDockCluster

Update a existing cluster

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateCloudDockClusterRequest
*/
func (a *ColocationClusterApiService) UpdateCloudDockCluster(ctx context.Context) ApiUpdateCloudDockClusterRequest {
	return ApiUpdateCloudDockClusterRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ColocationClusterApiService) UpdateCloudDockClusterExecute(r ApiUpdateCloudDockClusterRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ColocationClusterApiService.UpdateCloudDockCluster")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/colocation/cluster"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateCspToClusterRequest struct {
	ctx context.Context
	ApiService *ColocationClusterApiService
	body *map[string]interface{}
}

// CSP config
func (r ApiUpdateCspToClusterRequest) Body(body map[string]interface{}) ApiUpdateCspToClusterRequest {
	r.body = &body
	return r
}

func (r ApiUpdateCspToClusterRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateCspToClusterExecute(r)
}

/*
UpdateCspToCluster Method for UpdateCspToCluster

Update attached csp to cluster

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateCspToClusterRequest
*/
func (a *ColocationClusterApiService) UpdateCspToCluster(ctx context.Context) ApiUpdateCspToClusterRequest {
	return ApiUpdateCspToClusterRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ColocationClusterApiService) UpdateCspToClusterExecute(r ApiUpdateCspToClusterRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ColocationClusterApiService.UpdateCspToCluster")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/colocation/cluster/attached/csp"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
