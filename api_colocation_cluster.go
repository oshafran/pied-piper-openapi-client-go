/*
Cisco SD-WAN vManage API

The vManage API exposes the functionality of operations maintaining devices and the overlay network

API version: 2.0.0
Contact: vmanage@cisco.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// ColocationClusterApiService ColocationClusterApi service
type ColocationClusterApiService service

type ColocationClusterApiAcitvateCloudDockClusterRequest struct {
	ctx context.Context
	ApiService *ColocationClusterApiService
	clusterName *string
}

// Cluster name
func (r ColocationClusterApiAcitvateCloudDockClusterRequest) ClusterName(clusterName string) ColocationClusterApiAcitvateCloudDockClusterRequest {
	r.clusterName = &clusterName
	return r
}

func (r ColocationClusterApiAcitvateCloudDockClusterRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.AcitvateCloudDockClusterExecute(r)
}

/*
AcitvateCloudDockCluster Method for AcitvateCloudDockCluster

Activate a cluster

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ColocationClusterApiAcitvateCloudDockClusterRequest
*/
func (a *ColocationClusterApiService) AcitvateCloudDockCluster(ctx context.Context) ColocationClusterApiAcitvateCloudDockClusterRequest {
	return ColocationClusterApiAcitvateCloudDockClusterRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ColocationClusterApiService) AcitvateCloudDockClusterExecute(r ColocationClusterApiAcitvateCloudDockClusterRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ColocationClusterApiService.AcitvateCloudDockCluster")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/colocation/cluster/activate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.clusterName == nil {
		return localVarReturnValue, nil, reportError("clusterName is required and must be specified")
	}

	localVarQueryParams.Add("clusterName", parameterToString(*r.clusterName, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ColocationClusterApiCloudDockClusterPreviewRequest struct {
	ctx context.Context
	ApiService *ColocationClusterApiService
	serialNumber *string
}

// Serial number
func (r ColocationClusterApiCloudDockClusterPreviewRequest) SerialNumber(serialNumber string) ColocationClusterApiCloudDockClusterPreviewRequest {
	r.serialNumber = &serialNumber
	return r
}

func (r ColocationClusterApiCloudDockClusterPreviewRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.CloudDockClusterPreviewExecute(r)
}

/*
CloudDockClusterPreview Method for CloudDockClusterPreview

Clouddock cluster preview

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ColocationClusterApiCloudDockClusterPreviewRequest
*/
func (a *ColocationClusterApiService) CloudDockClusterPreview(ctx context.Context) ColocationClusterApiCloudDockClusterPreviewRequest {
	return ColocationClusterApiCloudDockClusterPreviewRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return string
func (a *ColocationClusterApiService) CloudDockClusterPreviewExecute(r ColocationClusterApiCloudDockClusterPreviewRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ColocationClusterApiService.CloudDockClusterPreview")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/colocation/cluster/config"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.serialNumber == nil {
		return localVarReturnValue, nil, reportError("serialNumber is required and must be specified")
	}

	localVarQueryParams.Add("serialNumber", parameterToString(*r.serialNumber, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ColocationClusterApiCreateCloudDockClusterRequest struct {
	ctx context.Context
	ApiService *ColocationClusterApiService
	body *map[string]interface{}
}

// Cluster config
func (r ColocationClusterApiCreateCloudDockClusterRequest) Body(body map[string]interface{}) ColocationClusterApiCreateCloudDockClusterRequest {
	r.body = &body
	return r
}

func (r ColocationClusterApiCreateCloudDockClusterRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateCloudDockClusterExecute(r)
}

/*
CreateCloudDockCluster Method for CreateCloudDockCluster

Add a new cluster

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ColocationClusterApiCreateCloudDockClusterRequest
*/
func (a *ColocationClusterApiService) CreateCloudDockCluster(ctx context.Context) ColocationClusterApiCreateCloudDockClusterRequest {
	return ColocationClusterApiCreateCloudDockClusterRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ColocationClusterApiService) CreateCloudDockClusterExecute(r ColocationClusterApiCreateCloudDockClusterRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ColocationClusterApiService.CreateCloudDockCluster")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/colocation/cluster"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ColocationClusterApiDeAcitvateCloudDockClusterRequest struct {
	ctx context.Context
	ApiService *ColocationClusterApiService
	clusterId *string
}

// Cluster Id
func (r ColocationClusterApiDeAcitvateCloudDockClusterRequest) ClusterId(clusterId string) ColocationClusterApiDeAcitvateCloudDockClusterRequest {
	r.clusterId = &clusterId
	return r
}

func (r ColocationClusterApiDeAcitvateCloudDockClusterRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeAcitvateCloudDockClusterExecute(r)
}

/*
DeAcitvateCloudDockCluster Method for DeAcitvateCloudDockCluster

Deactivate clouddock cluster

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ColocationClusterApiDeAcitvateCloudDockClusterRequest
*/
func (a *ColocationClusterApiService) DeAcitvateCloudDockCluster(ctx context.Context) ColocationClusterApiDeAcitvateCloudDockClusterRequest {
	return ColocationClusterApiDeAcitvateCloudDockClusterRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ColocationClusterApiService) DeAcitvateCloudDockClusterExecute(r ColocationClusterApiDeAcitvateCloudDockClusterRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ColocationClusterApiService.DeAcitvateCloudDockCluster")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/colocation/cluster/deactivate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.clusterId == nil {
		return nil, reportError("clusterId is required and must be specified")
	}

	localVarQueryParams.Add("clusterId", parameterToString(*r.clusterId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ColocationClusterApiDeleteCloudDockClusterByNameRequest struct {
	ctx context.Context
	ApiService *ColocationClusterApiService
	clustername string
}

func (r ColocationClusterApiDeleteCloudDockClusterByNameRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteCloudDockClusterByNameExecute(r)
}

/*
DeleteCloudDockClusterByName Method for DeleteCloudDockClusterByName

Delete cluster by name

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clustername Cluster name
 @return ColocationClusterApiDeleteCloudDockClusterByNameRequest
*/
func (a *ColocationClusterApiService) DeleteCloudDockClusterByName(ctx context.Context, clustername string) ColocationClusterApiDeleteCloudDockClusterByNameRequest {
	return ColocationClusterApiDeleteCloudDockClusterByNameRequest{
		ApiService: a,
		ctx: ctx,
		clustername: clustername,
	}
}

// Execute executes the request
func (a *ColocationClusterApiService) DeleteCloudDockClusterByNameExecute(r ColocationClusterApiDeleteCloudDockClusterByNameRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ColocationClusterApiService.DeleteCloudDockClusterByName")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/colocation/cluster/{clustername}"
	localVarPath = strings.Replace(localVarPath, "{"+"clustername"+"}", url.PathEscape(parameterToString(r.clustername, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ColocationClusterApiDummyccmRequest struct {
	ctx context.Context
	ApiService *ColocationClusterApiService
	clusterName *string
}

// Cluster name
func (r ColocationClusterApiDummyccmRequest) ClusterName(clusterName string) ColocationClusterApiDummyccmRequest {
	r.clusterName = &clusterName
	return r
}

func (r ColocationClusterApiDummyccmRequest) Execute() (*http.Response, error) {
	return r.ApiService.DummyccmExecute(r)
}

/*
Dummyccm Method for Dummyccm

Activate dummp cluster

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ColocationClusterApiDummyccmRequest
*/
func (a *ColocationClusterApiService) Dummyccm(ctx context.Context) ColocationClusterApiDummyccmRequest {
	return ColocationClusterApiDummyccmRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ColocationClusterApiService) DummyccmExecute(r ColocationClusterApiDummyccmRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ColocationClusterApiService.Dummyccm")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/colocation/cluster/activateClusterDummy"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.clusterName == nil {
		return nil, reportError("clusterName is required and must be specified")
	}

	localVarQueryParams.Add("clusterName", parameterToString(*r.clusterName, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ColocationClusterApiDummycspStateRequest struct {
	ctx context.Context
	ApiService *ColocationClusterApiService
	clusterName *string
	state *string
}

// Cluster name
func (r ColocationClusterApiDummycspStateRequest) ClusterName(clusterName string) ColocationClusterApiDummycspStateRequest {
	r.clusterName = &clusterName
	return r
}

// Cluster state
func (r ColocationClusterApiDummycspStateRequest) State(state string) ColocationClusterApiDummycspStateRequest {
	r.state = &state
	return r
}

func (r ColocationClusterApiDummycspStateRequest) Execute() (*http.Response, error) {
	return r.ApiService.DummycspStateExecute(r)
}

/*
DummycspState Method for DummycspState

Activate cluster in a state

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ColocationClusterApiDummycspStateRequest
*/
func (a *ColocationClusterApiService) DummycspState(ctx context.Context) ColocationClusterApiDummycspStateRequest {
	return ColocationClusterApiDummycspStateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ColocationClusterApiService) DummycspStateExecute(r ColocationClusterApiDummycspStateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ColocationClusterApiService.DummycspState")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/colocation/cluster/activateClusterDummyState"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.clusterName == nil {
		return nil, reportError("clusterName is required and must be specified")
	}
	if r.state == nil {
		return nil, reportError("state is required and must be specified")
	}

	localVarQueryParams.Add("clusterName", parameterToString(*r.clusterName, ""))
	localVarQueryParams.Add("state", parameterToString(*r.state, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ColocationClusterApiGetCloudDockClusterDetailRequest struct {
	ctx context.Context
	ApiService *ColocationClusterApiService
	clusterName *string
}

// Cluster name
func (r ColocationClusterApiGetCloudDockClusterDetailRequest) ClusterName(clusterName string) ColocationClusterApiGetCloudDockClusterDetailRequest {
	r.clusterName = &clusterName
	return r
}

func (r ColocationClusterApiGetCloudDockClusterDetailRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetCloudDockClusterDetailExecute(r)
}

/*
GetCloudDockClusterDetail Method for GetCloudDockClusterDetail

Get details of all existing Clusters

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ColocationClusterApiGetCloudDockClusterDetailRequest
*/
func (a *ColocationClusterApiService) GetCloudDockClusterDetail(ctx context.Context) ColocationClusterApiGetCloudDockClusterDetailRequest {
	return ColocationClusterApiGetCloudDockClusterDetailRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ColocationClusterApiService) GetCloudDockClusterDetailExecute(r ColocationClusterApiGetCloudDockClusterDetailRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ColocationClusterApiService.GetCloudDockClusterDetail")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/colocation/cluster"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.clusterName == nil {
		return localVarReturnValue, nil, reportError("clusterName is required and must be specified")
	}

	localVarQueryParams.Add("clusterName", parameterToString(*r.clusterName, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ColocationClusterApiGetCloudDockClusterDetailByIdRequest struct {
	ctx context.Context
	ApiService *ColocationClusterApiService
	clusterId *string
}

// Cluster Id
func (r ColocationClusterApiGetCloudDockClusterDetailByIdRequest) ClusterId(clusterId string) ColocationClusterApiGetCloudDockClusterDetailByIdRequest {
	r.clusterId = &clusterId
	return r
}

func (r ColocationClusterApiGetCloudDockClusterDetailByIdRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetCloudDockClusterDetailByIdExecute(r)
}

/*
GetCloudDockClusterDetailById Method for GetCloudDockClusterDetailById

Get cluster by Id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ColocationClusterApiGetCloudDockClusterDetailByIdRequest
*/
func (a *ColocationClusterApiService) GetCloudDockClusterDetailById(ctx context.Context) ColocationClusterApiGetCloudDockClusterDetailByIdRequest {
	return ColocationClusterApiGetCloudDockClusterDetailByIdRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ColocationClusterApiService) GetCloudDockClusterDetailByIdExecute(r ColocationClusterApiGetCloudDockClusterDetailByIdRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ColocationClusterApiService.GetCloudDockClusterDetailById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/colocation/cluster/id"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.clusterId == nil {
		return localVarReturnValue, nil, reportError("clusterId is required and must be specified")
	}

	localVarQueryParams.Add("clusterId", parameterToString(*r.clusterId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ColocationClusterApiRmaCloudDockCspRequest struct {
	ctx context.Context
	ApiService *ColocationClusterApiService
	clusterName *string
	body *string
}

// Cluster name
func (r ColocationClusterApiRmaCloudDockCspRequest) ClusterName(clusterName string) ColocationClusterApiRmaCloudDockCspRequest {
	r.clusterName = &clusterName
	return r
}

func (r ColocationClusterApiRmaCloudDockCspRequest) Body(body string) ColocationClusterApiRmaCloudDockCspRequest {
	r.body = &body
	return r
}

func (r ColocationClusterApiRmaCloudDockCspRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.RmaCloudDockCspExecute(r)
}

/*
RmaCloudDockCsp Method for RmaCloudDockCsp

RMA operation for CSP device

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ColocationClusterApiRmaCloudDockCspRequest
*/
func (a *ColocationClusterApiService) RmaCloudDockCsp(ctx context.Context) ColocationClusterApiRmaCloudDockCspRequest {
	return ColocationClusterApiRmaCloudDockCspRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ColocationClusterApiService) RmaCloudDockCspExecute(r ColocationClusterApiRmaCloudDockCspRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ColocationClusterApiService.RmaCloudDockCsp")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/colocation/cluster/rma"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.clusterName == nil {
		return localVarReturnValue, nil, reportError("clusterName is required and must be specified")
	}

	localVarQueryParams.Add("clusterName", parameterToString(*r.clusterName, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ColocationClusterApiUpdateCloudDockClusterRequest struct {
	ctx context.Context
	ApiService *ColocationClusterApiService
	body *map[string]interface{}
}

// Cluster config
func (r ColocationClusterApiUpdateCloudDockClusterRequest) Body(body map[string]interface{}) ColocationClusterApiUpdateCloudDockClusterRequest {
	r.body = &body
	return r
}

func (r ColocationClusterApiUpdateCloudDockClusterRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateCloudDockClusterExecute(r)
}

/*
UpdateCloudDockCluster Method for UpdateCloudDockCluster

Update a existing cluster

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ColocationClusterApiUpdateCloudDockClusterRequest
*/
func (a *ColocationClusterApiService) UpdateCloudDockCluster(ctx context.Context) ColocationClusterApiUpdateCloudDockClusterRequest {
	return ColocationClusterApiUpdateCloudDockClusterRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ColocationClusterApiService) UpdateCloudDockClusterExecute(r ColocationClusterApiUpdateCloudDockClusterRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ColocationClusterApiService.UpdateCloudDockCluster")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/colocation/cluster"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ColocationClusterApiUpdateCspToClusterRequest struct {
	ctx context.Context
	ApiService *ColocationClusterApiService
	body *map[string]interface{}
}

// CSP config
func (r ColocationClusterApiUpdateCspToClusterRequest) Body(body map[string]interface{}) ColocationClusterApiUpdateCspToClusterRequest {
	r.body = &body
	return r
}

func (r ColocationClusterApiUpdateCspToClusterRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateCspToClusterExecute(r)
}

/*
UpdateCspToCluster Method for UpdateCspToCluster

Update attached csp to cluster

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ColocationClusterApiUpdateCspToClusterRequest
*/
func (a *ColocationClusterApiService) UpdateCspToCluster(ctx context.Context) ColocationClusterApiUpdateCspToClusterRequest {
	return ColocationClusterApiUpdateCspToClusterRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ColocationClusterApiService) UpdateCspToClusterExecute(r ColocationClusterApiUpdateCspToClusterRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ColocationClusterApiService.UpdateCspToCluster")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/colocation/cluster/attached/csp"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
