/*
Cisco SD-WAN vManage API

The vManage API exposes the functionality of operations maintaining devices and the overlay network

API version: 2.0.0
Contact: vmanage@cisco.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
)


// MonitoringColocationClusterApiService MonitoringColocationClusterApi service
type MonitoringColocationClusterApiService service

type MonitoringColocationClusterApiGetClusterConfigByClusterIdRequest struct {
	ctx context.Context
	ApiService *MonitoringColocationClusterApiService
	clusterId *string
}

// Cluster Id
func (r MonitoringColocationClusterApiGetClusterConfigByClusterIdRequest) ClusterId(clusterId string) MonitoringColocationClusterApiGetClusterConfigByClusterIdRequest {
	r.clusterId = &clusterId
	return r
}

func (r MonitoringColocationClusterApiGetClusterConfigByClusterIdRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetClusterConfigByClusterIdExecute(r)
}

/*
GetClusterConfigByClusterId Method for GetClusterConfigByClusterId

Provide details of devices of clusters

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MonitoringColocationClusterApiGetClusterConfigByClusterIdRequest
*/
func (a *MonitoringColocationClusterApiService) GetClusterConfigByClusterId(ctx context.Context) MonitoringColocationClusterApiGetClusterConfigByClusterIdRequest {
	return MonitoringColocationClusterApiGetClusterConfigByClusterIdRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *MonitoringColocationClusterApiService) GetClusterConfigByClusterIdExecute(r MonitoringColocationClusterApiGetClusterConfigByClusterIdRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitoringColocationClusterApiService.GetClusterConfigByClusterId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/colocation/monitor/cluster/config"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.clusterId == nil {
		return localVarReturnValue, nil, reportError("clusterId is required and must be specified")
	}

	localVarQueryParams.Add("clusterId", parameterToString(*r.clusterId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MonitoringColocationClusterApiGetClusterDetailsByClusterIdRequest struct {
	ctx context.Context
	ApiService *MonitoringColocationClusterApiService
	clusterId *string
}

// Cluster Id
func (r MonitoringColocationClusterApiGetClusterDetailsByClusterIdRequest) ClusterId(clusterId string) MonitoringColocationClusterApiGetClusterDetailsByClusterIdRequest {
	r.clusterId = &clusterId
	return r
}

func (r MonitoringColocationClusterApiGetClusterDetailsByClusterIdRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetClusterDetailsByClusterIdExecute(r)
}

/*
GetClusterDetailsByClusterId Method for GetClusterDetailsByClusterId

Provide details of ids of existing clusters

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MonitoringColocationClusterApiGetClusterDetailsByClusterIdRequest
*/
func (a *MonitoringColocationClusterApiService) GetClusterDetailsByClusterId(ctx context.Context) MonitoringColocationClusterApiGetClusterDetailsByClusterIdRequest {
	return MonitoringColocationClusterApiGetClusterDetailsByClusterIdRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *MonitoringColocationClusterApiService) GetClusterDetailsByClusterIdExecute(r MonitoringColocationClusterApiGetClusterDetailsByClusterIdRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitoringColocationClusterApiService.GetClusterDetailsByClusterId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/colocation/monitor/cluster"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.clusterId == nil {
		return localVarReturnValue, nil, reportError("clusterId is required and must be specified")
	}

	localVarQueryParams.Add("clusterId", parameterToString(*r.clusterId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MonitoringColocationClusterApiGetClusterPortMappingByClusterIdRequest struct {
	ctx context.Context
	ApiService *MonitoringColocationClusterApiService
	clusterId *string
}

// Cluster Id
func (r MonitoringColocationClusterApiGetClusterPortMappingByClusterIdRequest) ClusterId(clusterId string) MonitoringColocationClusterApiGetClusterPortMappingByClusterIdRequest {
	r.clusterId = &clusterId
	return r
}

func (r MonitoringColocationClusterApiGetClusterPortMappingByClusterIdRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetClusterPortMappingByClusterIdExecute(r)
}

/*
GetClusterPortMappingByClusterId Method for GetClusterPortMappingByClusterId

Provide details of port mappings in the cluster

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MonitoringColocationClusterApiGetClusterPortMappingByClusterIdRequest
*/
func (a *MonitoringColocationClusterApiService) GetClusterPortMappingByClusterId(ctx context.Context) MonitoringColocationClusterApiGetClusterPortMappingByClusterIdRequest {
	return MonitoringColocationClusterApiGetClusterPortMappingByClusterIdRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *MonitoringColocationClusterApiService) GetClusterPortMappingByClusterIdExecute(r MonitoringColocationClusterApiGetClusterPortMappingByClusterIdRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitoringColocationClusterApiService.GetClusterPortMappingByClusterId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/colocation/monitor/cluster/portView"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.clusterId == nil {
		return localVarReturnValue, nil, reportError("clusterId is required and must be specified")
	}

	localVarQueryParams.Add("clusterId", parameterToString(*r.clusterId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MonitoringColocationClusterApiGetDeviceDetailByDeviceIdRequest struct {
	ctx context.Context
	ApiService *MonitoringColocationClusterApiService
	deviceId *string
}

// Device Id
func (r MonitoringColocationClusterApiGetDeviceDetailByDeviceIdRequest) DeviceId(deviceId string) MonitoringColocationClusterApiGetDeviceDetailByDeviceIdRequest {
	r.deviceId = &deviceId
	return r
}

func (r MonitoringColocationClusterApiGetDeviceDetailByDeviceIdRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetDeviceDetailByDeviceIdExecute(r)
}

/*
GetDeviceDetailByDeviceId Method for GetDeviceDetailByDeviceId

List details for Device

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MonitoringColocationClusterApiGetDeviceDetailByDeviceIdRequest
*/
func (a *MonitoringColocationClusterApiService) GetDeviceDetailByDeviceId(ctx context.Context) MonitoringColocationClusterApiGetDeviceDetailByDeviceIdRequest {
	return MonitoringColocationClusterApiGetDeviceDetailByDeviceIdRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *MonitoringColocationClusterApiService) GetDeviceDetailByDeviceIdExecute(r MonitoringColocationClusterApiGetDeviceDetailByDeviceIdRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitoringColocationClusterApiService.GetDeviceDetailByDeviceId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/colocation/monitor/device"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.deviceId != nil {
		localVarQueryParams.Add("deviceId", parameterToString(*r.deviceId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MonitoringColocationClusterApiGetPNFConfigRequest struct {
	ctx context.Context
	ApiService *MonitoringColocationClusterApiService
	pnfSerialNumber *string
	clusterId *string
}

// PNF serial number
func (r MonitoringColocationClusterApiGetPNFConfigRequest) PnfSerialNumber(pnfSerialNumber string) MonitoringColocationClusterApiGetPNFConfigRequest {
	r.pnfSerialNumber = &pnfSerialNumber
	return r
}

// Cluster Id
func (r MonitoringColocationClusterApiGetPNFConfigRequest) ClusterId(clusterId string) MonitoringColocationClusterApiGetPNFConfigRequest {
	r.clusterId = &clusterId
	return r
}

func (r MonitoringColocationClusterApiGetPNFConfigRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetPNFConfigExecute(r)
}

/*
GetPNFConfig Method for GetPNFConfig

List configuration of PNF

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MonitoringColocationClusterApiGetPNFConfigRequest
*/
func (a *MonitoringColocationClusterApiService) GetPNFConfig(ctx context.Context) MonitoringColocationClusterApiGetPNFConfigRequest {
	return MonitoringColocationClusterApiGetPNFConfigRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *MonitoringColocationClusterApiService) GetPNFConfigExecute(r MonitoringColocationClusterApiGetPNFConfigRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitoringColocationClusterApiService.GetPNFConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/colocation/monitor/pnf/configuration"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pnfSerialNumber != nil {
		localVarQueryParams.Add("pnfSerialNumber", parameterToString(*r.pnfSerialNumber, ""))
	}
	if r.clusterId != nil {
		localVarQueryParams.Add("clusterId", parameterToString(*r.clusterId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MonitoringColocationClusterApiGetServiceChainDetailsRequest struct {
	ctx context.Context
	ApiService *MonitoringColocationClusterApiService
	clusterId *string
	userGroupName *string
}

// Cluster Id
func (r MonitoringColocationClusterApiGetServiceChainDetailsRequest) ClusterId(clusterId string) MonitoringColocationClusterApiGetServiceChainDetailsRequest {
	r.clusterId = &clusterId
	return r
}

// UserGroup Name
func (r MonitoringColocationClusterApiGetServiceChainDetailsRequest) UserGroupName(userGroupName string) MonitoringColocationClusterApiGetServiceChainDetailsRequest {
	r.userGroupName = &userGroupName
	return r
}

func (r MonitoringColocationClusterApiGetServiceChainDetailsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetServiceChainDetailsExecute(r)
}

/*
GetServiceChainDetails Method for GetServiceChainDetails

List all service chain or service chains by Id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MonitoringColocationClusterApiGetServiceChainDetailsRequest
*/
func (a *MonitoringColocationClusterApiService) GetServiceChainDetails(ctx context.Context) MonitoringColocationClusterApiGetServiceChainDetailsRequest {
	return MonitoringColocationClusterApiGetServiceChainDetailsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *MonitoringColocationClusterApiService) GetServiceChainDetailsExecute(r MonitoringColocationClusterApiGetServiceChainDetailsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitoringColocationClusterApiService.GetServiceChainDetails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/colocation/monitor/servicechain"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.clusterId != nil {
		localVarQueryParams.Add("clusterId", parameterToString(*r.clusterId, ""))
	}
	if r.userGroupName != nil {
		localVarQueryParams.Add("userGroupName", parameterToString(*r.userGroupName, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MonitoringColocationClusterApiGetServiceGroupByClusterIdRequest struct {
	ctx context.Context
	ApiService *MonitoringColocationClusterApiService
	clusterId *string
}

// Cluster Id
func (r MonitoringColocationClusterApiGetServiceGroupByClusterIdRequest) ClusterId(clusterId string) MonitoringColocationClusterApiGetServiceGroupByClusterIdRequest {
	r.clusterId = &clusterId
	return r
}

func (r MonitoringColocationClusterApiGetServiceGroupByClusterIdRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetServiceGroupByClusterIdExecute(r)
}

/*
GetServiceGroupByClusterId Method for GetServiceGroupByClusterId

List all attached serviceGroups to cluster

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MonitoringColocationClusterApiGetServiceGroupByClusterIdRequest
*/
func (a *MonitoringColocationClusterApiService) GetServiceGroupByClusterId(ctx context.Context) MonitoringColocationClusterApiGetServiceGroupByClusterIdRequest {
	return MonitoringColocationClusterApiGetServiceGroupByClusterIdRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *MonitoringColocationClusterApiService) GetServiceGroupByClusterIdExecute(r MonitoringColocationClusterApiGetServiceGroupByClusterIdRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitoringColocationClusterApiService.GetServiceGroupByClusterId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/colocation/monitor/servicegroup"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.clusterId != nil {
		localVarQueryParams.Add("clusterId", parameterToString(*r.clusterId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MonitoringColocationClusterApiGetSystemStatusByDeviceIdRequest struct {
	ctx context.Context
	ApiService *MonitoringColocationClusterApiService
	deviceId *string
}

// Device Id
func (r MonitoringColocationClusterApiGetSystemStatusByDeviceIdRequest) DeviceId(deviceId string) MonitoringColocationClusterApiGetSystemStatusByDeviceIdRequest {
	r.deviceId = &deviceId
	return r
}

func (r MonitoringColocationClusterApiGetSystemStatusByDeviceIdRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetSystemStatusByDeviceIdExecute(r)
}

/*
GetSystemStatusByDeviceId Method for GetSystemStatusByDeviceId

List all connected VNF to a device

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MonitoringColocationClusterApiGetSystemStatusByDeviceIdRequest
*/
func (a *MonitoringColocationClusterApiService) GetSystemStatusByDeviceId(ctx context.Context) MonitoringColocationClusterApiGetSystemStatusByDeviceIdRequest {
	return MonitoringColocationClusterApiGetSystemStatusByDeviceIdRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *MonitoringColocationClusterApiService) GetSystemStatusByDeviceIdExecute(r MonitoringColocationClusterApiGetSystemStatusByDeviceIdRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitoringColocationClusterApiService.GetSystemStatusByDeviceId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/colocation/monitor/device/system"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.deviceId != nil {
		localVarQueryParams.Add("deviceId", parameterToString(*r.deviceId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MonitoringColocationClusterApiGetVNFAlarmCountRequest struct {
	ctx context.Context
	ApiService *MonitoringColocationClusterApiService
	userGroup *string
}

// user group name
func (r MonitoringColocationClusterApiGetVNFAlarmCountRequest) UserGroup(userGroup string) MonitoringColocationClusterApiGetVNFAlarmCountRequest {
	r.userGroup = &userGroup
	return r
}

func (r MonitoringColocationClusterApiGetVNFAlarmCountRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetVNFAlarmCountExecute(r)
}

/*
GetVNFAlarmCount Method for GetVNFAlarmCount

Get event detail of VNF

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MonitoringColocationClusterApiGetVNFAlarmCountRequest
*/
func (a *MonitoringColocationClusterApiService) GetVNFAlarmCount(ctx context.Context) MonitoringColocationClusterApiGetVNFAlarmCountRequest {
	return MonitoringColocationClusterApiGetVNFAlarmCountRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *MonitoringColocationClusterApiService) GetVNFAlarmCountExecute(r MonitoringColocationClusterApiGetVNFAlarmCountRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitoringColocationClusterApiService.GetVNFAlarmCount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/colocation/monitor/vnf/alarms/count"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.userGroup != nil {
		localVarQueryParams.Add("user_group", parameterToString(*r.userGroup, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MonitoringColocationClusterApiGetVNFEventsCountDetailRequest struct {
	ctx context.Context
	ApiService *MonitoringColocationClusterApiService
	userGroup *string
}

// user group name
func (r MonitoringColocationClusterApiGetVNFEventsCountDetailRequest) UserGroup(userGroup string) MonitoringColocationClusterApiGetVNFEventsCountDetailRequest {
	r.userGroup = &userGroup
	return r
}

func (r MonitoringColocationClusterApiGetVNFEventsCountDetailRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetVNFEventsCountDetailExecute(r)
}

/*
GetVNFEventsCountDetail Method for GetVNFEventsCountDetail

Get event detail of VNF

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MonitoringColocationClusterApiGetVNFEventsCountDetailRequest
*/
func (a *MonitoringColocationClusterApiService) GetVNFEventsCountDetail(ctx context.Context) MonitoringColocationClusterApiGetVNFEventsCountDetailRequest {
	return MonitoringColocationClusterApiGetVNFEventsCountDetailRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *MonitoringColocationClusterApiService) GetVNFEventsCountDetailExecute(r MonitoringColocationClusterApiGetVNFEventsCountDetailRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitoringColocationClusterApiService.GetVNFEventsCountDetail")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/colocation/monitor/vnf/alarms"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.userGroup != nil {
		localVarQueryParams.Add("user_group", parameterToString(*r.userGroup, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MonitoringColocationClusterApiGetVNFEventsDetailRequest struct {
	ctx context.Context
	ApiService *MonitoringColocationClusterApiService
	vnfName *string
}

// VNF name
func (r MonitoringColocationClusterApiGetVNFEventsDetailRequest) VnfName(vnfName string) MonitoringColocationClusterApiGetVNFEventsDetailRequest {
	r.vnfName = &vnfName
	return r
}

func (r MonitoringColocationClusterApiGetVNFEventsDetailRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetVNFEventsDetailExecute(r)
}

/*
GetVNFEventsDetail Method for GetVNFEventsDetail

Get event detail of VNF

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MonitoringColocationClusterApiGetVNFEventsDetailRequest
*/
func (a *MonitoringColocationClusterApiService) GetVNFEventsDetail(ctx context.Context) MonitoringColocationClusterApiGetVNFEventsDetailRequest {
	return MonitoringColocationClusterApiGetVNFEventsDetailRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *MonitoringColocationClusterApiService) GetVNFEventsDetailExecute(r MonitoringColocationClusterApiGetVNFEventsDetailRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitoringColocationClusterApiService.GetVNFEventsDetail")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/colocation/monitor/vnf/events"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.vnfName != nil {
		localVarQueryParams.Add("vnfName", parameterToString(*r.vnfName, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MonitoringColocationClusterApiGetVNFInterfaceDetailRequest struct {
	ctx context.Context
	ApiService *MonitoringColocationClusterApiService
	vnfName *string
	deviceIp *string
	deviceClass *string
}

// VNF name
func (r MonitoringColocationClusterApiGetVNFInterfaceDetailRequest) VnfName(vnfName string) MonitoringColocationClusterApiGetVNFInterfaceDetailRequest {
	r.vnfName = &vnfName
	return r
}

// Device IP
func (r MonitoringColocationClusterApiGetVNFInterfaceDetailRequest) DeviceIp(deviceIp string) MonitoringColocationClusterApiGetVNFInterfaceDetailRequest {
	r.deviceIp = &deviceIp
	return r
}

// Device class
func (r MonitoringColocationClusterApiGetVNFInterfaceDetailRequest) DeviceClass(deviceClass string) MonitoringColocationClusterApiGetVNFInterfaceDetailRequest {
	r.deviceClass = &deviceClass
	return r
}

func (r MonitoringColocationClusterApiGetVNFInterfaceDetailRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetVNFInterfaceDetailExecute(r)
}

/*
GetVNFInterfaceDetail Method for GetVNFInterfaceDetail

Get interface detail of VNF

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MonitoringColocationClusterApiGetVNFInterfaceDetailRequest
*/
func (a *MonitoringColocationClusterApiService) GetVNFInterfaceDetail(ctx context.Context) MonitoringColocationClusterApiGetVNFInterfaceDetailRequest {
	return MonitoringColocationClusterApiGetVNFInterfaceDetailRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *MonitoringColocationClusterApiService) GetVNFInterfaceDetailExecute(r MonitoringColocationClusterApiGetVNFInterfaceDetailRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitoringColocationClusterApiService.GetVNFInterfaceDetail")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/colocation/monitor/vnf/interface"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.vnfName != nil {
		localVarQueryParams.Add("vnfName", parameterToString(*r.vnfName, ""))
	}
	if r.deviceIp != nil {
		localVarQueryParams.Add("deviceIp", parameterToString(*r.deviceIp, ""))
	}
	if r.deviceClass != nil {
		localVarQueryParams.Add("deviceClass", parameterToString(*r.deviceClass, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MonitoringColocationClusterApiGetpnfDetailsRequest struct {
	ctx context.Context
	ApiService *MonitoringColocationClusterApiService
	clusterId *string
}

// Cluster Id
func (r MonitoringColocationClusterApiGetpnfDetailsRequest) ClusterId(clusterId string) MonitoringColocationClusterApiGetpnfDetailsRequest {
	r.clusterId = &clusterId
	return r
}

func (r MonitoringColocationClusterApiGetpnfDetailsRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetpnfDetailsExecute(r)
}

/*
GetpnfDetails Method for GetpnfDetails

List all PNF by cluster Id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MonitoringColocationClusterApiGetpnfDetailsRequest
*/
func (a *MonitoringColocationClusterApiService) GetpnfDetails(ctx context.Context) MonitoringColocationClusterApiGetpnfDetailsRequest {
	return MonitoringColocationClusterApiGetpnfDetailsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *MonitoringColocationClusterApiService) GetpnfDetailsExecute(r MonitoringColocationClusterApiGetpnfDetailsRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitoringColocationClusterApiService.GetpnfDetails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/colocation/monitor/pnf"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.clusterId != nil {
		localVarQueryParams.Add("clusterId", parameterToString(*r.clusterId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MonitoringColocationClusterApiGetvnfByDeviceIdRequest struct {
	ctx context.Context
	ApiService *MonitoringColocationClusterApiService
	deviceId *string
}

// Device Id
func (r MonitoringColocationClusterApiGetvnfByDeviceIdRequest) DeviceId(deviceId string) MonitoringColocationClusterApiGetvnfByDeviceIdRequest {
	r.deviceId = &deviceId
	return r
}

func (r MonitoringColocationClusterApiGetvnfByDeviceIdRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetvnfByDeviceIdExecute(r)
}

/*
GetvnfByDeviceId Method for GetvnfByDeviceId

List all VNF attached with Device

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MonitoringColocationClusterApiGetvnfByDeviceIdRequest
*/
func (a *MonitoringColocationClusterApiService) GetvnfByDeviceId(ctx context.Context) MonitoringColocationClusterApiGetvnfByDeviceIdRequest {
	return MonitoringColocationClusterApiGetvnfByDeviceIdRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *MonitoringColocationClusterApiService) GetvnfByDeviceIdExecute(r MonitoringColocationClusterApiGetvnfByDeviceIdRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitoringColocationClusterApiService.GetvnfByDeviceId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/colocation/monitor/device/vnf"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.deviceId != nil {
		localVarQueryParams.Add("deviceId", parameterToString(*r.deviceId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MonitoringColocationClusterApiGetvnfDetailsRequest struct {
	ctx context.Context
	ApiService *MonitoringColocationClusterApiService
	clusterId *string
	userGroupName *string
	vnfName *string
}

// Cluster Id
func (r MonitoringColocationClusterApiGetvnfDetailsRequest) ClusterId(clusterId string) MonitoringColocationClusterApiGetvnfDetailsRequest {
	r.clusterId = &clusterId
	return r
}

// UserGroup Name
func (r MonitoringColocationClusterApiGetvnfDetailsRequest) UserGroupName(userGroupName string) MonitoringColocationClusterApiGetvnfDetailsRequest {
	r.userGroupName = &userGroupName
	return r
}

// VNF Name
func (r MonitoringColocationClusterApiGetvnfDetailsRequest) VnfName(vnfName string) MonitoringColocationClusterApiGetvnfDetailsRequest {
	r.vnfName = &vnfName
	return r
}

func (r MonitoringColocationClusterApiGetvnfDetailsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetvnfDetailsExecute(r)
}

/*
GetvnfDetails Method for GetvnfDetails

Provide details of all existing VNF

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MonitoringColocationClusterApiGetvnfDetailsRequest
*/
func (a *MonitoringColocationClusterApiService) GetvnfDetails(ctx context.Context) MonitoringColocationClusterApiGetvnfDetailsRequest {
	return MonitoringColocationClusterApiGetvnfDetailsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *MonitoringColocationClusterApiService) GetvnfDetailsExecute(r MonitoringColocationClusterApiGetvnfDetailsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitoringColocationClusterApiService.GetvnfDetails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/colocation/monitor/vnf"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.clusterId != nil {
		localVarQueryParams.Add("clusterId", parameterToString(*r.clusterId, ""))
	}
	if r.userGroupName != nil {
		localVarQueryParams.Add("userGroupName", parameterToString(*r.userGroupName, ""))
	}
	if r.vnfName != nil {
		localVarQueryParams.Add("vnfName", parameterToString(*r.vnfName, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MonitoringColocationClusterApiListNetworkFunctionMapRequest struct {
	ctx context.Context
	ApiService *MonitoringColocationClusterApiService
}

func (r MonitoringColocationClusterApiListNetworkFunctionMapRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.ListNetworkFunctionMapExecute(r)
}

/*
ListNetworkFunctionMap Method for ListNetworkFunctionMap

Retrieve network function listing

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MonitoringColocationClusterApiListNetworkFunctionMapRequest
*/
func (a *MonitoringColocationClusterApiService) ListNetworkFunctionMap(ctx context.Context) MonitoringColocationClusterApiListNetworkFunctionMapRequest {
	return MonitoringColocationClusterApiListNetworkFunctionMapRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *MonitoringColocationClusterApiService) ListNetworkFunctionMapExecute(r MonitoringColocationClusterApiListNetworkFunctionMapRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitoringColocationClusterApiService.ListNetworkFunctionMap")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/colocation/monitor/networkfunction/listmap"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MonitoringColocationClusterApiVnfActionsRequest struct {
	ctx context.Context
	ApiService *MonitoringColocationClusterApiService
	vmName *string
	deviceId *string
	action *string
}

// VM Name
func (r MonitoringColocationClusterApiVnfActionsRequest) VmName(vmName string) MonitoringColocationClusterApiVnfActionsRequest {
	r.vmName = &vmName
	return r
}

// Device Id
func (r MonitoringColocationClusterApiVnfActionsRequest) DeviceId(deviceId string) MonitoringColocationClusterApiVnfActionsRequest {
	r.deviceId = &deviceId
	return r
}

// Action
func (r MonitoringColocationClusterApiVnfActionsRequest) Action(action string) MonitoringColocationClusterApiVnfActionsRequest {
	r.action = &action
	return r
}

func (r MonitoringColocationClusterApiVnfActionsRequest) Execute() (*http.Response, error) {
	return r.ApiService.VnfActionsExecute(r)
}

/*
VnfActions Method for VnfActions

VNF action

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MonitoringColocationClusterApiVnfActionsRequest
*/
func (a *MonitoringColocationClusterApiService) VnfActions(ctx context.Context) MonitoringColocationClusterApiVnfActionsRequest {
	return MonitoringColocationClusterApiVnfActionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *MonitoringColocationClusterApiService) VnfActionsExecute(r MonitoringColocationClusterApiVnfActionsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitoringColocationClusterApiService.VnfActions")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/colocation/monitor/vnf/action"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.vmName != nil {
		localVarQueryParams.Add("vmName", parameterToString(*r.vmName, ""))
	}
	if r.deviceId != nil {
		localVarQueryParams.Add("deviceId", parameterToString(*r.deviceId, ""))
	}
	if r.action != nil {
		localVarQueryParams.Add("action", parameterToString(*r.action, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
