/*
Cisco SD-WAN vManage API

The vManage API exposes the functionality of operations maintaining devices and the overlay network

API version: 2.0.0
Contact: vmanage@cisco.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
)


// RealTimeMonitoringIPApiService RealTimeMonitoringIPApi service
type RealTimeMonitoringIPApiService service

type RealTimeMonitoringIPApiCreateFibListRequest struct {
	ctx context.Context
	ApiService *RealTimeMonitoringIPApiService
	deviceId *string
	vpnId *string
	addressFamily *string
	prefix *string
	tloc *string
	color *string
}

// Device Id
func (r RealTimeMonitoringIPApiCreateFibListRequest) DeviceId(deviceId string) RealTimeMonitoringIPApiCreateFibListRequest {
	r.deviceId = &deviceId
	return r
}

// VPN Id
func (r RealTimeMonitoringIPApiCreateFibListRequest) VpnId(vpnId string) RealTimeMonitoringIPApiCreateFibListRequest {
	r.vpnId = &vpnId
	return r
}

// Address family
func (r RealTimeMonitoringIPApiCreateFibListRequest) AddressFamily(addressFamily string) RealTimeMonitoringIPApiCreateFibListRequest {
	r.addressFamily = &addressFamily
	return r
}

// IP prefix
func (r RealTimeMonitoringIPApiCreateFibListRequest) Prefix(prefix string) RealTimeMonitoringIPApiCreateFibListRequest {
	r.prefix = &prefix
	return r
}

// tloc IP
func (r RealTimeMonitoringIPApiCreateFibListRequest) Tloc(tloc string) RealTimeMonitoringIPApiCreateFibListRequest {
	r.tloc = &tloc
	return r
}

// tloc color
func (r RealTimeMonitoringIPApiCreateFibListRequest) Color(color string) RealTimeMonitoringIPApiCreateFibListRequest {
	r.color = &color
	return r
}

func (r RealTimeMonitoringIPApiCreateFibListRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.CreateFibListExecute(r)
}

/*
CreateFibList Method for CreateFibList

Get FIB list from device (Real Time)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return RealTimeMonitoringIPApiCreateFibListRequest
*/
func (a *RealTimeMonitoringIPApiService) CreateFibList(ctx context.Context) RealTimeMonitoringIPApiCreateFibListRequest {
	return RealTimeMonitoringIPApiCreateFibListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *RealTimeMonitoringIPApiService) CreateFibListExecute(r RealTimeMonitoringIPApiCreateFibListRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealTimeMonitoringIPApiService.CreateFibList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/ip/fib"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deviceId == nil {
		return localVarReturnValue, nil, reportError("deviceId is required and must be specified")
	}

	if r.vpnId != nil {
		localVarQueryParams.Add("vpn-id", parameterToString(*r.vpnId, ""))
	}
	if r.addressFamily != nil {
		localVarQueryParams.Add("address-family", parameterToString(*r.addressFamily, ""))
	}
	if r.prefix != nil {
		localVarQueryParams.Add("prefix", parameterToString(*r.prefix, ""))
	}
	if r.tloc != nil {
		localVarQueryParams.Add("tloc", parameterToString(*r.tloc, ""))
	}
	if r.color != nil {
		localVarQueryParams.Add("color", parameterToString(*r.color, ""))
	}
	localVarQueryParams.Add("deviceId", parameterToString(*r.deviceId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RealTimeMonitoringIPApiCreateIPMfibOilListRequest struct {
	ctx context.Context
	ApiService *RealTimeMonitoringIPApiService
	deviceId *string
}

// Device Id
func (r RealTimeMonitoringIPApiCreateIPMfibOilListRequest) DeviceId(deviceId string) RealTimeMonitoringIPApiCreateIPMfibOilListRequest {
	r.deviceId = &deviceId
	return r
}

func (r RealTimeMonitoringIPApiCreateIPMfibOilListRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.CreateIPMfibOilListExecute(r)
}

/*
CreateIPMfibOilList Method for CreateIPMfibOilList

Get IP MFIB OIL list from device (Real Time)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return RealTimeMonitoringIPApiCreateIPMfibOilListRequest
*/
func (a *RealTimeMonitoringIPApiService) CreateIPMfibOilList(ctx context.Context) RealTimeMonitoringIPApiCreateIPMfibOilListRequest {
	return RealTimeMonitoringIPApiCreateIPMfibOilListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *RealTimeMonitoringIPApiService) CreateIPMfibOilListExecute(r RealTimeMonitoringIPApiCreateIPMfibOilListRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealTimeMonitoringIPApiService.CreateIPMfibOilList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/ip/mfiboil"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deviceId == nil {
		return localVarReturnValue, nil, reportError("deviceId is required and must be specified")
	}

	localVarQueryParams.Add("deviceId", parameterToString(*r.deviceId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RealTimeMonitoringIPApiCreateIPMfibStatsListRequest struct {
	ctx context.Context
	ApiService *RealTimeMonitoringIPApiService
	deviceId *string
}

// Device Id
func (r RealTimeMonitoringIPApiCreateIPMfibStatsListRequest) DeviceId(deviceId string) RealTimeMonitoringIPApiCreateIPMfibStatsListRequest {
	r.deviceId = &deviceId
	return r
}

func (r RealTimeMonitoringIPApiCreateIPMfibStatsListRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.CreateIPMfibStatsListExecute(r)
}

/*
CreateIPMfibStatsList Method for CreateIPMfibStatsList

Get IP MFIB statistics list from device (Real Time)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return RealTimeMonitoringIPApiCreateIPMfibStatsListRequest
*/
func (a *RealTimeMonitoringIPApiService) CreateIPMfibStatsList(ctx context.Context) RealTimeMonitoringIPApiCreateIPMfibStatsListRequest {
	return RealTimeMonitoringIPApiCreateIPMfibStatsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *RealTimeMonitoringIPApiService) CreateIPMfibStatsListExecute(r RealTimeMonitoringIPApiCreateIPMfibStatsListRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealTimeMonitoringIPApiService.CreateIPMfibStatsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/ip/mfibstats"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deviceId == nil {
		return localVarReturnValue, nil, reportError("deviceId is required and must be specified")
	}

	localVarQueryParams.Add("deviceId", parameterToString(*r.deviceId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RealTimeMonitoringIPApiCreateIPMfibSummaryListRequest struct {
	ctx context.Context
	ApiService *RealTimeMonitoringIPApiService
	deviceId *string
}

// Device Id
func (r RealTimeMonitoringIPApiCreateIPMfibSummaryListRequest) DeviceId(deviceId string) RealTimeMonitoringIPApiCreateIPMfibSummaryListRequest {
	r.deviceId = &deviceId
	return r
}

func (r RealTimeMonitoringIPApiCreateIPMfibSummaryListRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.CreateIPMfibSummaryListExecute(r)
}

/*
CreateIPMfibSummaryList Method for CreateIPMfibSummaryList

Get IP MFIB summary list from device (Real Time)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return RealTimeMonitoringIPApiCreateIPMfibSummaryListRequest
*/
func (a *RealTimeMonitoringIPApiService) CreateIPMfibSummaryList(ctx context.Context) RealTimeMonitoringIPApiCreateIPMfibSummaryListRequest {
	return RealTimeMonitoringIPApiCreateIPMfibSummaryListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *RealTimeMonitoringIPApiService) CreateIPMfibSummaryListExecute(r RealTimeMonitoringIPApiCreateIPMfibSummaryListRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealTimeMonitoringIPApiService.CreateIPMfibSummaryList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/ip/mfibsummary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deviceId == nil {
		return localVarReturnValue, nil, reportError("deviceId is required and must be specified")
	}

	localVarQueryParams.Add("deviceId", parameterToString(*r.deviceId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RealTimeMonitoringIPApiCreateIetfRoutingListRequest struct {
	ctx context.Context
	ApiService *RealTimeMonitoringIPApiService
	deviceId *string
	routingInstanceName *string
	addressFamily *string
	outgoingInterface *string
	sourceProtocol *string
	nextHopAddress *string
}

// Device Id
func (r RealTimeMonitoringIPApiCreateIetfRoutingListRequest) DeviceId(deviceId string) RealTimeMonitoringIPApiCreateIetfRoutingListRequest {
	r.deviceId = &deviceId
	return r
}

// VPN Id
func (r RealTimeMonitoringIPApiCreateIetfRoutingListRequest) RoutingInstanceName(routingInstanceName string) RealTimeMonitoringIPApiCreateIetfRoutingListRequest {
	r.routingInstanceName = &routingInstanceName
	return r
}

// Address family
func (r RealTimeMonitoringIPApiCreateIetfRoutingListRequest) AddressFamily(addressFamily string) RealTimeMonitoringIPApiCreateIetfRoutingListRequest {
	r.addressFamily = &addressFamily
	return r
}

// Outgoing Interface
func (r RealTimeMonitoringIPApiCreateIetfRoutingListRequest) OutgoingInterface(outgoingInterface string) RealTimeMonitoringIPApiCreateIetfRoutingListRequest {
	r.outgoingInterface = &outgoingInterface
	return r
}

// Source Protocol
func (r RealTimeMonitoringIPApiCreateIetfRoutingListRequest) SourceProtocol(sourceProtocol string) RealTimeMonitoringIPApiCreateIetfRoutingListRequest {
	r.sourceProtocol = &sourceProtocol
	return r
}

// Next Hop Address
func (r RealTimeMonitoringIPApiCreateIetfRoutingListRequest) NextHopAddress(nextHopAddress string) RealTimeMonitoringIPApiCreateIetfRoutingListRequest {
	r.nextHopAddress = &nextHopAddress
	return r
}

func (r RealTimeMonitoringIPApiCreateIetfRoutingListRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.CreateIetfRoutingListExecute(r)
}

/*
CreateIetfRoutingList Method for CreateIetfRoutingList

Get ietf routing list from device

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return RealTimeMonitoringIPApiCreateIetfRoutingListRequest
*/
func (a *RealTimeMonitoringIPApiService) CreateIetfRoutingList(ctx context.Context) RealTimeMonitoringIPApiCreateIetfRoutingListRequest {
	return RealTimeMonitoringIPApiCreateIetfRoutingListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *RealTimeMonitoringIPApiService) CreateIetfRoutingListExecute(r RealTimeMonitoringIPApiCreateIetfRoutingListRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealTimeMonitoringIPApiService.CreateIetfRoutingList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/ip/ipRoutes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deviceId == nil {
		return localVarReturnValue, nil, reportError("deviceId is required and must be specified")
	}

	if r.routingInstanceName != nil {
		localVarQueryParams.Add("routing-instance-name", parameterToString(*r.routingInstanceName, ""))
	}
	if r.addressFamily != nil {
		localVarQueryParams.Add("address-family", parameterToString(*r.addressFamily, ""))
	}
	if r.outgoingInterface != nil {
		localVarQueryParams.Add("outgoing-interface", parameterToString(*r.outgoingInterface, ""))
	}
	if r.sourceProtocol != nil {
		localVarQueryParams.Add("source-protocol", parameterToString(*r.sourceProtocol, ""))
	}
	if r.nextHopAddress != nil {
		localVarQueryParams.Add("next-hop-address", parameterToString(*r.nextHopAddress, ""))
	}
	localVarQueryParams.Add("deviceId", parameterToString(*r.deviceId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RealTimeMonitoringIPApiCreateNat64TranslationListRequest struct {
	ctx context.Context
	ApiService *RealTimeMonitoringIPApiService
	deviceId *string
}

// Device Id
func (r RealTimeMonitoringIPApiCreateNat64TranslationListRequest) DeviceId(deviceId string) RealTimeMonitoringIPApiCreateNat64TranslationListRequest {
	r.deviceId = &deviceId
	return r
}

func (r RealTimeMonitoringIPApiCreateNat64TranslationListRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.CreateNat64TranslationListExecute(r)
}

/*
CreateNat64TranslationList Method for CreateNat64TranslationList

Get NAT64 interface list from device

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return RealTimeMonitoringIPApiCreateNat64TranslationListRequest
*/
func (a *RealTimeMonitoringIPApiService) CreateNat64TranslationList(ctx context.Context) RealTimeMonitoringIPApiCreateNat64TranslationListRequest {
	return RealTimeMonitoringIPApiCreateNat64TranslationListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *RealTimeMonitoringIPApiService) CreateNat64TranslationListExecute(r RealTimeMonitoringIPApiCreateNat64TranslationListRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealTimeMonitoringIPApiService.CreateNat64TranslationList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/ip/nat64/translation"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deviceId == nil {
		return localVarReturnValue, nil, reportError("deviceId is required and must be specified")
	}

	localVarQueryParams.Add("deviceId", parameterToString(*r.deviceId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RealTimeMonitoringIPApiCreateNatFilterListRequest struct {
	ctx context.Context
	ApiService *RealTimeMonitoringIPApiService
	deviceId *string
	natVpnId *string
	natIfname *string
	privateSourceAddress *string
	proto *string
}

// Device Id
func (r RealTimeMonitoringIPApiCreateNatFilterListRequest) DeviceId(deviceId string) RealTimeMonitoringIPApiCreateNatFilterListRequest {
	r.deviceId = &deviceId
	return r
}

// NAT VPN Id
func (r RealTimeMonitoringIPApiCreateNatFilterListRequest) NatVpnId(natVpnId string) RealTimeMonitoringIPApiCreateNatFilterListRequest {
	r.natVpnId = &natVpnId
	return r
}

// NAT interface name
func (r RealTimeMonitoringIPApiCreateNatFilterListRequest) NatIfname(natIfname string) RealTimeMonitoringIPApiCreateNatFilterListRequest {
	r.natIfname = &natIfname
	return r
}

// Private source address
func (r RealTimeMonitoringIPApiCreateNatFilterListRequest) PrivateSourceAddress(privateSourceAddress string) RealTimeMonitoringIPApiCreateNatFilterListRequest {
	r.privateSourceAddress = &privateSourceAddress
	return r
}

// Protocol
func (r RealTimeMonitoringIPApiCreateNatFilterListRequest) Proto(proto string) RealTimeMonitoringIPApiCreateNatFilterListRequest {
	r.proto = &proto
	return r
}

func (r RealTimeMonitoringIPApiCreateNatFilterListRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.CreateNatFilterListExecute(r)
}

/*
CreateNatFilterList Method for CreateNatFilterList

Get NAT filter list from device

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return RealTimeMonitoringIPApiCreateNatFilterListRequest
*/
func (a *RealTimeMonitoringIPApiService) CreateNatFilterList(ctx context.Context) RealTimeMonitoringIPApiCreateNatFilterListRequest {
	return RealTimeMonitoringIPApiCreateNatFilterListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *RealTimeMonitoringIPApiService) CreateNatFilterListExecute(r RealTimeMonitoringIPApiCreateNatFilterListRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealTimeMonitoringIPApiService.CreateNatFilterList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/ip/nat/filter"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deviceId == nil {
		return localVarReturnValue, nil, reportError("deviceId is required and must be specified")
	}

	if r.natVpnId != nil {
		localVarQueryParams.Add("nat-vpn-id", parameterToString(*r.natVpnId, ""))
	}
	if r.natIfname != nil {
		localVarQueryParams.Add("nat-ifname", parameterToString(*r.natIfname, ""))
	}
	if r.privateSourceAddress != nil {
		localVarQueryParams.Add("private-source-address", parameterToString(*r.privateSourceAddress, ""))
	}
	if r.proto != nil {
		localVarQueryParams.Add("proto", parameterToString(*r.proto, ""))
	}
	localVarQueryParams.Add("deviceId", parameterToString(*r.deviceId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RealTimeMonitoringIPApiCreateNatInterfaceListRequest struct {
	ctx context.Context
	ApiService *RealTimeMonitoringIPApiService
	deviceId *string
}

// Device Id
func (r RealTimeMonitoringIPApiCreateNatInterfaceListRequest) DeviceId(deviceId string) RealTimeMonitoringIPApiCreateNatInterfaceListRequest {
	r.deviceId = &deviceId
	return r
}

func (r RealTimeMonitoringIPApiCreateNatInterfaceListRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.CreateNatInterfaceListExecute(r)
}

/*
CreateNatInterfaceList Method for CreateNatInterfaceList

Get NAT interface list from device (Real Time)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return RealTimeMonitoringIPApiCreateNatInterfaceListRequest
*/
func (a *RealTimeMonitoringIPApiService) CreateNatInterfaceList(ctx context.Context) RealTimeMonitoringIPApiCreateNatInterfaceListRequest {
	return RealTimeMonitoringIPApiCreateNatInterfaceListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *RealTimeMonitoringIPApiService) CreateNatInterfaceListExecute(r RealTimeMonitoringIPApiCreateNatInterfaceListRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealTimeMonitoringIPApiService.CreateNatInterfaceList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/ip/nat/interface"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deviceId == nil {
		return localVarReturnValue, nil, reportError("deviceId is required and must be specified")
	}

	localVarQueryParams.Add("deviceId", parameterToString(*r.deviceId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RealTimeMonitoringIPApiCreateNatInterfaceStatisticsListRequest struct {
	ctx context.Context
	ApiService *RealTimeMonitoringIPApiService
	deviceId *string
}

// Device Id
func (r RealTimeMonitoringIPApiCreateNatInterfaceStatisticsListRequest) DeviceId(deviceId string) RealTimeMonitoringIPApiCreateNatInterfaceStatisticsListRequest {
	r.deviceId = &deviceId
	return r
}

func (r RealTimeMonitoringIPApiCreateNatInterfaceStatisticsListRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.CreateNatInterfaceStatisticsListExecute(r)
}

/*
CreateNatInterfaceStatisticsList Method for CreateNatInterfaceStatisticsList

Get NAT interface statistics list from device

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return RealTimeMonitoringIPApiCreateNatInterfaceStatisticsListRequest
*/
func (a *RealTimeMonitoringIPApiService) CreateNatInterfaceStatisticsList(ctx context.Context) RealTimeMonitoringIPApiCreateNatInterfaceStatisticsListRequest {
	return RealTimeMonitoringIPApiCreateNatInterfaceStatisticsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *RealTimeMonitoringIPApiService) CreateNatInterfaceStatisticsListExecute(r RealTimeMonitoringIPApiCreateNatInterfaceStatisticsListRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealTimeMonitoringIPApiService.CreateNatInterfaceStatisticsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/ip/nat/interfacestatistics"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deviceId == nil {
		return localVarReturnValue, nil, reportError("deviceId is required and must be specified")
	}

	localVarQueryParams.Add("deviceId", parameterToString(*r.deviceId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RealTimeMonitoringIPApiCreateNatTranslationListRequest struct {
	ctx context.Context
	ApiService *RealTimeMonitoringIPApiService
	deviceId *string
}

// Device Id
func (r RealTimeMonitoringIPApiCreateNatTranslationListRequest) DeviceId(deviceId string) RealTimeMonitoringIPApiCreateNatTranslationListRequest {
	r.deviceId = &deviceId
	return r
}

func (r RealTimeMonitoringIPApiCreateNatTranslationListRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.CreateNatTranslationListExecute(r)
}

/*
CreateNatTranslationList Method for CreateNatTranslationList

Get NAT translation list from device (Real Time)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return RealTimeMonitoringIPApiCreateNatTranslationListRequest
*/
func (a *RealTimeMonitoringIPApiService) CreateNatTranslationList(ctx context.Context) RealTimeMonitoringIPApiCreateNatTranslationListRequest {
	return RealTimeMonitoringIPApiCreateNatTranslationListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *RealTimeMonitoringIPApiService) CreateNatTranslationListExecute(r RealTimeMonitoringIPApiCreateNatTranslationListRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealTimeMonitoringIPApiService.CreateNatTranslationList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/ip/nat/translation"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deviceId == nil {
		return localVarReturnValue, nil, reportError("deviceId is required and must be specified")
	}

	localVarQueryParams.Add("deviceId", parameterToString(*r.deviceId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RealTimeMonitoringIPApiCreateRouteTableListRequest struct {
	ctx context.Context
	ApiService *RealTimeMonitoringIPApiService
	deviceId *string
	vpnId *string
	addressFamily *string
	prefix *string
	protocol *string
}

// Device Id
func (r RealTimeMonitoringIPApiCreateRouteTableListRequest) DeviceId(deviceId string) RealTimeMonitoringIPApiCreateRouteTableListRequest {
	r.deviceId = &deviceId
	return r
}

// VPN Id
func (r RealTimeMonitoringIPApiCreateRouteTableListRequest) VpnId(vpnId string) RealTimeMonitoringIPApiCreateRouteTableListRequest {
	r.vpnId = &vpnId
	return r
}

// Address family
func (r RealTimeMonitoringIPApiCreateRouteTableListRequest) AddressFamily(addressFamily string) RealTimeMonitoringIPApiCreateRouteTableListRequest {
	r.addressFamily = &addressFamily
	return r
}

// IP prefix
func (r RealTimeMonitoringIPApiCreateRouteTableListRequest) Prefix(prefix string) RealTimeMonitoringIPApiCreateRouteTableListRequest {
	r.prefix = &prefix
	return r
}

// IP protocol
func (r RealTimeMonitoringIPApiCreateRouteTableListRequest) Protocol(protocol string) RealTimeMonitoringIPApiCreateRouteTableListRequest {
	r.protocol = &protocol
	return r
}

func (r RealTimeMonitoringIPApiCreateRouteTableListRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.CreateRouteTableListExecute(r)
}

/*
CreateRouteTableList Method for CreateRouteTableList

Get route table list from device (Real Time)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return RealTimeMonitoringIPApiCreateRouteTableListRequest
*/
func (a *RealTimeMonitoringIPApiService) CreateRouteTableList(ctx context.Context) RealTimeMonitoringIPApiCreateRouteTableListRequest {
	return RealTimeMonitoringIPApiCreateRouteTableListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *RealTimeMonitoringIPApiService) CreateRouteTableListExecute(r RealTimeMonitoringIPApiCreateRouteTableListRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealTimeMonitoringIPApiService.CreateRouteTableList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/ip/routetable"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deviceId == nil {
		return localVarReturnValue, nil, reportError("deviceId is required and must be specified")
	}

	if r.vpnId != nil {
		localVarQueryParams.Add("vpn-id", parameterToString(*r.vpnId, ""))
	}
	if r.addressFamily != nil {
		localVarQueryParams.Add("address-family", parameterToString(*r.addressFamily, ""))
	}
	if r.prefix != nil {
		localVarQueryParams.Add("prefix", parameterToString(*r.prefix, ""))
	}
	if r.protocol != nil {
		localVarQueryParams.Add("protocol", parameterToString(*r.protocol, ""))
	}
	localVarQueryParams.Add("deviceId", parameterToString(*r.deviceId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
