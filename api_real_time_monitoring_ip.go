/*
Cisco SD-WAN vManage API

The vManage API exposes the functionality of operations maintaining devices and the overlay network

API version: 2.0.0
Contact: vmanage@cisco.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
)


// RealTimeMonitoringIPApiService RealTimeMonitoringIPApi service
type RealTimeMonitoringIPApiService service

type ApiCreateFibListRequest struct {
	ctx context.Context
	ApiService *RealTimeMonitoringIPApiService
	deviceId *string
	vpnId *string
	addressFamily *string
	prefix *string
	tloc *string
	color *string
}

// Device Id
func (r ApiCreateFibListRequest) DeviceId(deviceId string) ApiCreateFibListRequest {
	r.deviceId = &deviceId
	return r
}

// VPN Id
func (r ApiCreateFibListRequest) VpnId(vpnId string) ApiCreateFibListRequest {
	r.vpnId = &vpnId
	return r
}

// Address family
func (r ApiCreateFibListRequest) AddressFamily(addressFamily string) ApiCreateFibListRequest {
	r.addressFamily = &addressFamily
	return r
}

// IP prefix
func (r ApiCreateFibListRequest) Prefix(prefix string) ApiCreateFibListRequest {
	r.prefix = &prefix
	return r
}

// tloc IP
func (r ApiCreateFibListRequest) Tloc(tloc string) ApiCreateFibListRequest {
	r.tloc = &tloc
	return r
}

// tloc color
func (r ApiCreateFibListRequest) Color(color string) ApiCreateFibListRequest {
	r.color = &color
	return r
}

func (r ApiCreateFibListRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.CreateFibListExecute(r)
}

/*
CreateFibList Method for CreateFibList

Get FIB list from device (Real Time)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateFibListRequest
*/
func (a *RealTimeMonitoringIPApiService) CreateFibList(ctx context.Context) ApiCreateFibListRequest {
	return ApiCreateFibListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *RealTimeMonitoringIPApiService) CreateFibListExecute(r ApiCreateFibListRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealTimeMonitoringIPApiService.CreateFibList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/ip/fib"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deviceId == nil {
		return localVarReturnValue, nil, reportError("deviceId is required and must be specified")
	}

	if r.vpnId != nil {
		localVarQueryParams.Add("vpn-id", parameterToString(*r.vpnId, ""))
	}
	if r.addressFamily != nil {
		localVarQueryParams.Add("address-family", parameterToString(*r.addressFamily, ""))
	}
	if r.prefix != nil {
		localVarQueryParams.Add("prefix", parameterToString(*r.prefix, ""))
	}
	if r.tloc != nil {
		localVarQueryParams.Add("tloc", parameterToString(*r.tloc, ""))
	}
	if r.color != nil {
		localVarQueryParams.Add("color", parameterToString(*r.color, ""))
	}
	localVarQueryParams.Add("deviceId", parameterToString(*r.deviceId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateIPMfibOilListRequest struct {
	ctx context.Context
	ApiService *RealTimeMonitoringIPApiService
	deviceId *string
}

// Device Id
func (r ApiCreateIPMfibOilListRequest) DeviceId(deviceId string) ApiCreateIPMfibOilListRequest {
	r.deviceId = &deviceId
	return r
}

func (r ApiCreateIPMfibOilListRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.CreateIPMfibOilListExecute(r)
}

/*
CreateIPMfibOilList Method for CreateIPMfibOilList

Get IP MFIB OIL list from device (Real Time)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateIPMfibOilListRequest
*/
func (a *RealTimeMonitoringIPApiService) CreateIPMfibOilList(ctx context.Context) ApiCreateIPMfibOilListRequest {
	return ApiCreateIPMfibOilListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *RealTimeMonitoringIPApiService) CreateIPMfibOilListExecute(r ApiCreateIPMfibOilListRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealTimeMonitoringIPApiService.CreateIPMfibOilList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/ip/mfiboil"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deviceId == nil {
		return localVarReturnValue, nil, reportError("deviceId is required and must be specified")
	}

	localVarQueryParams.Add("deviceId", parameterToString(*r.deviceId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateIPMfibStatsListRequest struct {
	ctx context.Context
	ApiService *RealTimeMonitoringIPApiService
	deviceId *string
}

// Device Id
func (r ApiCreateIPMfibStatsListRequest) DeviceId(deviceId string) ApiCreateIPMfibStatsListRequest {
	r.deviceId = &deviceId
	return r
}

func (r ApiCreateIPMfibStatsListRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.CreateIPMfibStatsListExecute(r)
}

/*
CreateIPMfibStatsList Method for CreateIPMfibStatsList

Get IP MFIB statistics list from device (Real Time)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateIPMfibStatsListRequest
*/
func (a *RealTimeMonitoringIPApiService) CreateIPMfibStatsList(ctx context.Context) ApiCreateIPMfibStatsListRequest {
	return ApiCreateIPMfibStatsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *RealTimeMonitoringIPApiService) CreateIPMfibStatsListExecute(r ApiCreateIPMfibStatsListRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealTimeMonitoringIPApiService.CreateIPMfibStatsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/ip/mfibstats"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deviceId == nil {
		return localVarReturnValue, nil, reportError("deviceId is required and must be specified")
	}

	localVarQueryParams.Add("deviceId", parameterToString(*r.deviceId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateIPMfibSummaryListRequest struct {
	ctx context.Context
	ApiService *RealTimeMonitoringIPApiService
	deviceId *string
}

// Device Id
func (r ApiCreateIPMfibSummaryListRequest) DeviceId(deviceId string) ApiCreateIPMfibSummaryListRequest {
	r.deviceId = &deviceId
	return r
}

func (r ApiCreateIPMfibSummaryListRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.CreateIPMfibSummaryListExecute(r)
}

/*
CreateIPMfibSummaryList Method for CreateIPMfibSummaryList

Get IP MFIB summary list from device (Real Time)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateIPMfibSummaryListRequest
*/
func (a *RealTimeMonitoringIPApiService) CreateIPMfibSummaryList(ctx context.Context) ApiCreateIPMfibSummaryListRequest {
	return ApiCreateIPMfibSummaryListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *RealTimeMonitoringIPApiService) CreateIPMfibSummaryListExecute(r ApiCreateIPMfibSummaryListRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealTimeMonitoringIPApiService.CreateIPMfibSummaryList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/ip/mfibsummary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deviceId == nil {
		return localVarReturnValue, nil, reportError("deviceId is required and must be specified")
	}

	localVarQueryParams.Add("deviceId", parameterToString(*r.deviceId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateIetfRoutingListRequest struct {
	ctx context.Context
	ApiService *RealTimeMonitoringIPApiService
	deviceId *string
	routingInstanceName *string
	addressFamily *string
	outgoingInterface *string
	sourceProtocol *string
	nextHopAddress *string
}

// Device Id
func (r ApiCreateIetfRoutingListRequest) DeviceId(deviceId string) ApiCreateIetfRoutingListRequest {
	r.deviceId = &deviceId
	return r
}

// VPN Id
func (r ApiCreateIetfRoutingListRequest) RoutingInstanceName(routingInstanceName string) ApiCreateIetfRoutingListRequest {
	r.routingInstanceName = &routingInstanceName
	return r
}

// Address family
func (r ApiCreateIetfRoutingListRequest) AddressFamily(addressFamily string) ApiCreateIetfRoutingListRequest {
	r.addressFamily = &addressFamily
	return r
}

// Outgoing Interface
func (r ApiCreateIetfRoutingListRequest) OutgoingInterface(outgoingInterface string) ApiCreateIetfRoutingListRequest {
	r.outgoingInterface = &outgoingInterface
	return r
}

// Source Protocol
func (r ApiCreateIetfRoutingListRequest) SourceProtocol(sourceProtocol string) ApiCreateIetfRoutingListRequest {
	r.sourceProtocol = &sourceProtocol
	return r
}

// Next Hop Address
func (r ApiCreateIetfRoutingListRequest) NextHopAddress(nextHopAddress string) ApiCreateIetfRoutingListRequest {
	r.nextHopAddress = &nextHopAddress
	return r
}

func (r ApiCreateIetfRoutingListRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.CreateIetfRoutingListExecute(r)
}

/*
CreateIetfRoutingList Method for CreateIetfRoutingList

Get ietf routing list from device

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateIetfRoutingListRequest
*/
func (a *RealTimeMonitoringIPApiService) CreateIetfRoutingList(ctx context.Context) ApiCreateIetfRoutingListRequest {
	return ApiCreateIetfRoutingListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *RealTimeMonitoringIPApiService) CreateIetfRoutingListExecute(r ApiCreateIetfRoutingListRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealTimeMonitoringIPApiService.CreateIetfRoutingList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/ip/ipRoutes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deviceId == nil {
		return localVarReturnValue, nil, reportError("deviceId is required and must be specified")
	}

	if r.routingInstanceName != nil {
		localVarQueryParams.Add("routing-instance-name", parameterToString(*r.routingInstanceName, ""))
	}
	if r.addressFamily != nil {
		localVarQueryParams.Add("address-family", parameterToString(*r.addressFamily, ""))
	}
	if r.outgoingInterface != nil {
		localVarQueryParams.Add("outgoing-interface", parameterToString(*r.outgoingInterface, ""))
	}
	if r.sourceProtocol != nil {
		localVarQueryParams.Add("source-protocol", parameterToString(*r.sourceProtocol, ""))
	}
	if r.nextHopAddress != nil {
		localVarQueryParams.Add("next-hop-address", parameterToString(*r.nextHopAddress, ""))
	}
	localVarQueryParams.Add("deviceId", parameterToString(*r.deviceId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateNat64TranslationListRequest struct {
	ctx context.Context
	ApiService *RealTimeMonitoringIPApiService
	deviceId *string
}

// Device Id
func (r ApiCreateNat64TranslationListRequest) DeviceId(deviceId string) ApiCreateNat64TranslationListRequest {
	r.deviceId = &deviceId
	return r
}

func (r ApiCreateNat64TranslationListRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.CreateNat64TranslationListExecute(r)
}

/*
CreateNat64TranslationList Method for CreateNat64TranslationList

Get NAT64 interface list from device

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateNat64TranslationListRequest
*/
func (a *RealTimeMonitoringIPApiService) CreateNat64TranslationList(ctx context.Context) ApiCreateNat64TranslationListRequest {
	return ApiCreateNat64TranslationListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *RealTimeMonitoringIPApiService) CreateNat64TranslationListExecute(r ApiCreateNat64TranslationListRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealTimeMonitoringIPApiService.CreateNat64TranslationList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/ip/nat64/translation"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deviceId == nil {
		return localVarReturnValue, nil, reportError("deviceId is required and must be specified")
	}

	localVarQueryParams.Add("deviceId", parameterToString(*r.deviceId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateNatFilterListRequest struct {
	ctx context.Context
	ApiService *RealTimeMonitoringIPApiService
	deviceId *string
	natVpnId *string
	natIfname *string
	privateSourceAddress *string
	proto *string
}

// Device Id
func (r ApiCreateNatFilterListRequest) DeviceId(deviceId string) ApiCreateNatFilterListRequest {
	r.deviceId = &deviceId
	return r
}

// NAT VPN Id
func (r ApiCreateNatFilterListRequest) NatVpnId(natVpnId string) ApiCreateNatFilterListRequest {
	r.natVpnId = &natVpnId
	return r
}

// NAT interface name
func (r ApiCreateNatFilterListRequest) NatIfname(natIfname string) ApiCreateNatFilterListRequest {
	r.natIfname = &natIfname
	return r
}

// Private source address
func (r ApiCreateNatFilterListRequest) PrivateSourceAddress(privateSourceAddress string) ApiCreateNatFilterListRequest {
	r.privateSourceAddress = &privateSourceAddress
	return r
}

// Protocol
func (r ApiCreateNatFilterListRequest) Proto(proto string) ApiCreateNatFilterListRequest {
	r.proto = &proto
	return r
}

func (r ApiCreateNatFilterListRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.CreateNatFilterListExecute(r)
}

/*
CreateNatFilterList Method for CreateNatFilterList

Get NAT filter list from device

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateNatFilterListRequest
*/
func (a *RealTimeMonitoringIPApiService) CreateNatFilterList(ctx context.Context) ApiCreateNatFilterListRequest {
	return ApiCreateNatFilterListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *RealTimeMonitoringIPApiService) CreateNatFilterListExecute(r ApiCreateNatFilterListRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealTimeMonitoringIPApiService.CreateNatFilterList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/ip/nat/filter"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deviceId == nil {
		return localVarReturnValue, nil, reportError("deviceId is required and must be specified")
	}

	if r.natVpnId != nil {
		localVarQueryParams.Add("nat-vpn-id", parameterToString(*r.natVpnId, ""))
	}
	if r.natIfname != nil {
		localVarQueryParams.Add("nat-ifname", parameterToString(*r.natIfname, ""))
	}
	if r.privateSourceAddress != nil {
		localVarQueryParams.Add("private-source-address", parameterToString(*r.privateSourceAddress, ""))
	}
	if r.proto != nil {
		localVarQueryParams.Add("proto", parameterToString(*r.proto, ""))
	}
	localVarQueryParams.Add("deviceId", parameterToString(*r.deviceId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateNatInterfaceListRequest struct {
	ctx context.Context
	ApiService *RealTimeMonitoringIPApiService
	deviceId *string
}

// Device Id
func (r ApiCreateNatInterfaceListRequest) DeviceId(deviceId string) ApiCreateNatInterfaceListRequest {
	r.deviceId = &deviceId
	return r
}

func (r ApiCreateNatInterfaceListRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.CreateNatInterfaceListExecute(r)
}

/*
CreateNatInterfaceList Method for CreateNatInterfaceList

Get NAT interface list from device (Real Time)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateNatInterfaceListRequest
*/
func (a *RealTimeMonitoringIPApiService) CreateNatInterfaceList(ctx context.Context) ApiCreateNatInterfaceListRequest {
	return ApiCreateNatInterfaceListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *RealTimeMonitoringIPApiService) CreateNatInterfaceListExecute(r ApiCreateNatInterfaceListRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealTimeMonitoringIPApiService.CreateNatInterfaceList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/ip/nat/interface"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deviceId == nil {
		return localVarReturnValue, nil, reportError("deviceId is required and must be specified")
	}

	localVarQueryParams.Add("deviceId", parameterToString(*r.deviceId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateNatInterfaceStatisticsListRequest struct {
	ctx context.Context
	ApiService *RealTimeMonitoringIPApiService
	deviceId *string
}

// Device Id
func (r ApiCreateNatInterfaceStatisticsListRequest) DeviceId(deviceId string) ApiCreateNatInterfaceStatisticsListRequest {
	r.deviceId = &deviceId
	return r
}

func (r ApiCreateNatInterfaceStatisticsListRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.CreateNatInterfaceStatisticsListExecute(r)
}

/*
CreateNatInterfaceStatisticsList Method for CreateNatInterfaceStatisticsList

Get NAT interface statistics list from device

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateNatInterfaceStatisticsListRequest
*/
func (a *RealTimeMonitoringIPApiService) CreateNatInterfaceStatisticsList(ctx context.Context) ApiCreateNatInterfaceStatisticsListRequest {
	return ApiCreateNatInterfaceStatisticsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *RealTimeMonitoringIPApiService) CreateNatInterfaceStatisticsListExecute(r ApiCreateNatInterfaceStatisticsListRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealTimeMonitoringIPApiService.CreateNatInterfaceStatisticsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/ip/nat/interfacestatistics"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deviceId == nil {
		return localVarReturnValue, nil, reportError("deviceId is required and must be specified")
	}

	localVarQueryParams.Add("deviceId", parameterToString(*r.deviceId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateNatTranslationListRequest struct {
	ctx context.Context
	ApiService *RealTimeMonitoringIPApiService
	deviceId *string
}

// Device Id
func (r ApiCreateNatTranslationListRequest) DeviceId(deviceId string) ApiCreateNatTranslationListRequest {
	r.deviceId = &deviceId
	return r
}

func (r ApiCreateNatTranslationListRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.CreateNatTranslationListExecute(r)
}

/*
CreateNatTranslationList Method for CreateNatTranslationList

Get NAT translation list from device (Real Time)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateNatTranslationListRequest
*/
func (a *RealTimeMonitoringIPApiService) CreateNatTranslationList(ctx context.Context) ApiCreateNatTranslationListRequest {
	return ApiCreateNatTranslationListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *RealTimeMonitoringIPApiService) CreateNatTranslationListExecute(r ApiCreateNatTranslationListRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealTimeMonitoringIPApiService.CreateNatTranslationList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/ip/nat/translation"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deviceId == nil {
		return localVarReturnValue, nil, reportError("deviceId is required and must be specified")
	}

	localVarQueryParams.Add("deviceId", parameterToString(*r.deviceId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateRouteTableListRequest struct {
	ctx context.Context
	ApiService *RealTimeMonitoringIPApiService
	deviceId *string
	vpnId *string
	addressFamily *string
	prefix *string
	protocol *string
}

// Device Id
func (r ApiCreateRouteTableListRequest) DeviceId(deviceId string) ApiCreateRouteTableListRequest {
	r.deviceId = &deviceId
	return r
}

// VPN Id
func (r ApiCreateRouteTableListRequest) VpnId(vpnId string) ApiCreateRouteTableListRequest {
	r.vpnId = &vpnId
	return r
}

// Address family
func (r ApiCreateRouteTableListRequest) AddressFamily(addressFamily string) ApiCreateRouteTableListRequest {
	r.addressFamily = &addressFamily
	return r
}

// IP prefix
func (r ApiCreateRouteTableListRequest) Prefix(prefix string) ApiCreateRouteTableListRequest {
	r.prefix = &prefix
	return r
}

// IP protocol
func (r ApiCreateRouteTableListRequest) Protocol(protocol string) ApiCreateRouteTableListRequest {
	r.protocol = &protocol
	return r
}

func (r ApiCreateRouteTableListRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.CreateRouteTableListExecute(r)
}

/*
CreateRouteTableList Method for CreateRouteTableList

Get route table list from device (Real Time)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateRouteTableListRequest
*/
func (a *RealTimeMonitoringIPApiService) CreateRouteTableList(ctx context.Context) ApiCreateRouteTableListRequest {
	return ApiCreateRouteTableListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *RealTimeMonitoringIPApiService) CreateRouteTableListExecute(r ApiCreateRouteTableListRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealTimeMonitoringIPApiService.CreateRouteTableList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/ip/routetable"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deviceId == nil {
		return localVarReturnValue, nil, reportError("deviceId is required and must be specified")
	}

	if r.vpnId != nil {
		localVarQueryParams.Add("vpn-id", parameterToString(*r.vpnId, ""))
	}
	if r.addressFamily != nil {
		localVarQueryParams.Add("address-family", parameterToString(*r.addressFamily, ""))
	}
	if r.prefix != nil {
		localVarQueryParams.Add("prefix", parameterToString(*r.prefix, ""))
	}
	if r.protocol != nil {
		localVarQueryParams.Add("protocol", parameterToString(*r.protocol, ""))
	}
	localVarQueryParams.Add("deviceId", parameterToString(*r.deviceId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
