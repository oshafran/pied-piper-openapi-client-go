/*
Cisco SD-WAN vManage API

The vManage API exposes the functionality of operations maintaining devices and the overlay network

API version: 2.0.0
Contact: vmanage@cisco.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
)


// RealTimeMonitoringCFMApiService RealTimeMonitoringCFMApi service
type RealTimeMonitoringCFMApiService service

type ApiGetMpDatabaseRequest struct {
	ctx context.Context
	ApiService *RealTimeMonitoringCFMApiService
	deviceId *string
}

// Device IP
func (r ApiGetMpDatabaseRequest) DeviceId(deviceId string) ApiGetMpDatabaseRequest {
	r.deviceId = &deviceId
	return r
}

func (r ApiGetMpDatabaseRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetMpDatabaseExecute(r)
}

/*
GetMpDatabase Method for GetMpDatabase

Get mp database from device

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetMpDatabaseRequest
*/
func (a *RealTimeMonitoringCFMApiService) GetMpDatabase(ctx context.Context) ApiGetMpDatabaseRequest {
	return ApiGetMpDatabaseRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *RealTimeMonitoringCFMApiService) GetMpDatabaseExecute(r ApiGetMpDatabaseRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealTimeMonitoringCFMApiService.GetMpDatabase")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/cfm/mp/database"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deviceId == nil {
		return localVarReturnValue, nil, reportError("deviceId is required and must be specified")
	}

	localVarQueryParams.Add("deviceId", parameterToString(*r.deviceId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMpLocalMepRequest struct {
	ctx context.Context
	ApiService *RealTimeMonitoringCFMApiService
	deviceId *string
	domain *string
	service *string
	mepId *float32
}

// Device IP
func (r ApiGetMpLocalMepRequest) DeviceId(deviceId string) ApiGetMpLocalMepRequest {
	r.deviceId = &deviceId
	return r
}

// Domain Name
func (r ApiGetMpLocalMepRequest) Domain(domain string) ApiGetMpLocalMepRequest {
	r.domain = &domain
	return r
}

// Service Name
func (r ApiGetMpLocalMepRequest) Service(service string) ApiGetMpLocalMepRequest {
	r.service = &service
	return r
}

// MEP ID
func (r ApiGetMpLocalMepRequest) MepId(mepId float32) ApiGetMpLocalMepRequest {
	r.mepId = &mepId
	return r
}

func (r ApiGetMpLocalMepRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetMpLocalMepExecute(r)
}

/*
GetMpLocalMep Method for GetMpLocalMep

Get mp local mep from device

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetMpLocalMepRequest
*/
func (a *RealTimeMonitoringCFMApiService) GetMpLocalMep(ctx context.Context) ApiGetMpLocalMepRequest {
	return ApiGetMpLocalMepRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *RealTimeMonitoringCFMApiService) GetMpLocalMepExecute(r ApiGetMpLocalMepRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealTimeMonitoringCFMApiService.GetMpLocalMep")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/cfm/mp/local/mep"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deviceId == nil {
		return localVarReturnValue, nil, reportError("deviceId is required and must be specified")
	}

	if r.domain != nil {
		localVarQueryParams.Add("domain", parameterToString(*r.domain, ""))
	}
	if r.service != nil {
		localVarQueryParams.Add("service", parameterToString(*r.service, ""))
	}
	if r.mepId != nil {
		localVarQueryParams.Add("mep-id", parameterToString(*r.mepId, ""))
	}
	localVarQueryParams.Add("deviceId", parameterToString(*r.deviceId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMpLocalMipRequest struct {
	ctx context.Context
	ApiService *RealTimeMonitoringCFMApiService
	deviceId *string
	level *float32
	port *string
	svcInst *float32
}

// Device IP
func (r ApiGetMpLocalMipRequest) DeviceId(deviceId string) ApiGetMpLocalMipRequest {
	r.deviceId = &deviceId
	return r
}

// Level
func (r ApiGetMpLocalMipRequest) Level(level float32) ApiGetMpLocalMipRequest {
	r.level = &level
	return r
}

// Port
func (r ApiGetMpLocalMipRequest) Port(port string) ApiGetMpLocalMipRequest {
	r.port = &port
	return r
}

// Service Instance
func (r ApiGetMpLocalMipRequest) SvcInst(svcInst float32) ApiGetMpLocalMipRequest {
	r.svcInst = &svcInst
	return r
}

func (r ApiGetMpLocalMipRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetMpLocalMipExecute(r)
}

/*
GetMpLocalMip Method for GetMpLocalMip

Get mp local mip from device

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetMpLocalMipRequest
*/
func (a *RealTimeMonitoringCFMApiService) GetMpLocalMip(ctx context.Context) ApiGetMpLocalMipRequest {
	return ApiGetMpLocalMipRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *RealTimeMonitoringCFMApiService) GetMpLocalMipExecute(r ApiGetMpLocalMipRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealTimeMonitoringCFMApiService.GetMpLocalMip")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/cfm/mp/local/mip"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deviceId == nil {
		return localVarReturnValue, nil, reportError("deviceId is required and must be specified")
	}

	if r.level != nil {
		localVarQueryParams.Add("level", parameterToString(*r.level, ""))
	}
	if r.port != nil {
		localVarQueryParams.Add("port", parameterToString(*r.port, ""))
	}
	if r.svcInst != nil {
		localVarQueryParams.Add("svc-inst", parameterToString(*r.svcInst, ""))
	}
	localVarQueryParams.Add("deviceId", parameterToString(*r.deviceId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMpRemoteMepRequest struct {
	ctx context.Context
	ApiService *RealTimeMonitoringCFMApiService
	deviceId *string
	domain *string
	service *string
	localMepId *float32
	remoteMepId *float32
}

// Device IP
func (r ApiGetMpRemoteMepRequest) DeviceId(deviceId string) ApiGetMpRemoteMepRequest {
	r.deviceId = &deviceId
	return r
}

// Domain Name
func (r ApiGetMpRemoteMepRequest) Domain(domain string) ApiGetMpRemoteMepRequest {
	r.domain = &domain
	return r
}

// Service Name
func (r ApiGetMpRemoteMepRequest) Service(service string) ApiGetMpRemoteMepRequest {
	r.service = &service
	return r
}

// Local MEP ID
func (r ApiGetMpRemoteMepRequest) LocalMepId(localMepId float32) ApiGetMpRemoteMepRequest {
	r.localMepId = &localMepId
	return r
}

// Remote MEP ID
func (r ApiGetMpRemoteMepRequest) RemoteMepId(remoteMepId float32) ApiGetMpRemoteMepRequest {
	r.remoteMepId = &remoteMepId
	return r
}

func (r ApiGetMpRemoteMepRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetMpRemoteMepExecute(r)
}

/*
GetMpRemoteMep Method for GetMpRemoteMep

Get mp remote mep from device

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetMpRemoteMepRequest
*/
func (a *RealTimeMonitoringCFMApiService) GetMpRemoteMep(ctx context.Context) ApiGetMpRemoteMepRequest {
	return ApiGetMpRemoteMepRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *RealTimeMonitoringCFMApiService) GetMpRemoteMepExecute(r ApiGetMpRemoteMepRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealTimeMonitoringCFMApiService.GetMpRemoteMep")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/cfm/mp/remotemep"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deviceId == nil {
		return localVarReturnValue, nil, reportError("deviceId is required and must be specified")
	}

	if r.domain != nil {
		localVarQueryParams.Add("domain", parameterToString(*r.domain, ""))
	}
	if r.service != nil {
		localVarQueryParams.Add("service", parameterToString(*r.service, ""))
	}
	if r.localMepId != nil {
		localVarQueryParams.Add("local-mep-id", parameterToString(*r.localMepId, ""))
	}
	if r.remoteMepId != nil {
		localVarQueryParams.Add("remote-mep-id", parameterToString(*r.remoteMepId, ""))
	}
	localVarQueryParams.Add("deviceId", parameterToString(*r.deviceId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
