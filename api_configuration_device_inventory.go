/*
Cisco SD-WAN vManage API

The vManage API exposes the functionality of operations maintaining devices and the overlay network

API version: 2.0.0
Contact: vmanage@cisco.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// ConfigurationDeviceInventoryApiService ConfigurationDeviceInventoryApi service
type ConfigurationDeviceInventoryApiService service

type ConfigurationDeviceInventoryApiCheckSelfSignedCertRequest struct {
	ctx context.Context
	ApiService *ConfigurationDeviceInventoryApiService
}

func (r ConfigurationDeviceInventoryApiCheckSelfSignedCertRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.CheckSelfSignedCertExecute(r)
}

/*
CheckSelfSignedCert Method for CheckSelfSignedCert

Whether self signed certificate created

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationDeviceInventoryApiCheckSelfSignedCertRequest
*/
func (a *ConfigurationDeviceInventoryApiService) CheckSelfSignedCert(ctx context.Context) ConfigurationDeviceInventoryApiCheckSelfSignedCertRequest {
	return ConfigurationDeviceInventoryApiCheckSelfSignedCertRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationDeviceInventoryApiService) CheckSelfSignedCertExecute(r ConfigurationDeviceInventoryApiCheckSelfSignedCertRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationDeviceInventoryApiService.CheckSelfSignedCert")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/system/device/selfsignedcert/iscreated"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationDeviceInventoryApiClaimDevicesRequest struct {
	ctx context.Context
	ApiService *ConfigurationDeviceInventoryApiService
	body *map[string]interface{}
}

// Claim device request
func (r ConfigurationDeviceInventoryApiClaimDevicesRequest) Body(body map[string]interface{}) ConfigurationDeviceInventoryApiClaimDevicesRequest {
	r.body = &body
	return r
}

func (r ConfigurationDeviceInventoryApiClaimDevicesRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.ClaimDevicesExecute(r)
}

/*
ClaimDevices Method for ClaimDevices

Claim the selected unclaimed devices

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationDeviceInventoryApiClaimDevicesRequest
*/
func (a *ConfigurationDeviceInventoryApiService) ClaimDevices(ctx context.Context) ConfigurationDeviceInventoryApiClaimDevicesRequest {
	return ConfigurationDeviceInventoryApiClaimDevicesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *ConfigurationDeviceInventoryApiService) ClaimDevicesExecute(r ConfigurationDeviceInventoryApiClaimDevicesRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationDeviceInventoryApiService.ClaimDevices")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/system/device/claimDevices"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationDeviceInventoryApiCreateDeviceRequest struct {
	ctx context.Context
	ApiService *ConfigurationDeviceInventoryApiService
	body *map[string]interface{}
}

// Create device request
func (r ConfigurationDeviceInventoryApiCreateDeviceRequest) Body(body map[string]interface{}) ConfigurationDeviceInventoryApiCreateDeviceRequest {
	r.body = &body
	return r
}

func (r ConfigurationDeviceInventoryApiCreateDeviceRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateDeviceExecute(r)
}

/*
CreateDevice Method for CreateDevice

Create new device<br><br><br>Note: In a multitenant vManage system, this API is only available in the Provider view.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationDeviceInventoryApiCreateDeviceRequest
*/
func (a *ConfigurationDeviceInventoryApiService) CreateDevice(ctx context.Context) ConfigurationDeviceInventoryApiCreateDeviceRequest {
	return ConfigurationDeviceInventoryApiCreateDeviceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ConfigurationDeviceInventoryApiService) CreateDeviceExecute(r ConfigurationDeviceInventoryApiCreateDeviceRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationDeviceInventoryApiService.CreateDevice")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/system/device"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ConfigurationDeviceInventoryApiDecommissionVedgeCloudRequest struct {
	ctx context.Context
	ApiService *ConfigurationDeviceInventoryApiService
	uuid string
}

func (r ConfigurationDeviceInventoryApiDecommissionVedgeCloudRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.DecommissionVedgeCloudExecute(r)
}

/*
DecommissionVedgeCloud Method for DecommissionVedgeCloud

Decomission vEdge device

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid Device uuid
 @return ConfigurationDeviceInventoryApiDecommissionVedgeCloudRequest
*/
func (a *ConfigurationDeviceInventoryApiService) DecommissionVedgeCloud(ctx context.Context, uuid string) ConfigurationDeviceInventoryApiDecommissionVedgeCloudRequest {
	return ConfigurationDeviceInventoryApiDecommissionVedgeCloudRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationDeviceInventoryApiService) DecommissionVedgeCloudExecute(r ConfigurationDeviceInventoryApiDecommissionVedgeCloudRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationDeviceInventoryApiService.DecommissionVedgeCloud")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/system/device/decommission/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationDeviceInventoryApiDeleteDeviceRequest struct {
	ctx context.Context
	ApiService *ConfigurationDeviceInventoryApiService
	uuid string
}

func (r ConfigurationDeviceInventoryApiDeleteDeviceRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteDeviceExecute(r)
}

/*
DeleteDevice Method for DeleteDevice

Delete vEdges

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid Device uuid
 @return ConfigurationDeviceInventoryApiDeleteDeviceRequest
*/
func (a *ConfigurationDeviceInventoryApiService) DeleteDevice(ctx context.Context, uuid string) ConfigurationDeviceInventoryApiDeleteDeviceRequest {
	return ConfigurationDeviceInventoryApiDeleteDeviceRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
func (a *ConfigurationDeviceInventoryApiService) DeleteDeviceExecute(r ConfigurationDeviceInventoryApiDeleteDeviceRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationDeviceInventoryApiService.DeleteDevice")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/system/device/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ConfigurationDeviceInventoryApiDevicesWithoutSubjectSudiRequest struct {
	ctx context.Context
	ApiService *ConfigurationDeviceInventoryApiService
}

func (r ConfigurationDeviceInventoryApiDevicesWithoutSubjectSudiRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.DevicesWithoutSubjectSudiExecute(r)
}

/*
DevicesWithoutSubjectSudi Method for DevicesWithoutSubjectSudi

retrieve devices without subject sudi

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationDeviceInventoryApiDevicesWithoutSubjectSudiRequest
*/
func (a *ConfigurationDeviceInventoryApiService) DevicesWithoutSubjectSudi(ctx context.Context) ConfigurationDeviceInventoryApiDevicesWithoutSubjectSudiRequest {
	return ConfigurationDeviceInventoryApiDevicesWithoutSubjectSudiRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *ConfigurationDeviceInventoryApiService) DevicesWithoutSubjectSudiExecute(r ConfigurationDeviceInventoryApiDevicesWithoutSubjectSudiRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationDeviceInventoryApiService.DevicesWithoutSubjectSudi")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/system/device/devicesWithoutSubjectSudi"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationDeviceInventoryApiEditDeviceRequest struct {
	ctx context.Context
	ApiService *ConfigurationDeviceInventoryApiService
	uuid string
	body *map[string]interface{}
}

// Device config
func (r ConfigurationDeviceInventoryApiEditDeviceRequest) Body(body map[string]interface{}) ConfigurationDeviceInventoryApiEditDeviceRequest {
	r.body = &body
	return r
}

func (r ConfigurationDeviceInventoryApiEditDeviceRequest) Execute() (*http.Response, error) {
	return r.ApiService.EditDeviceExecute(r)
}

/*
EditDevice Method for EditDevice

Edit device

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid Device uuid
 @return ConfigurationDeviceInventoryApiEditDeviceRequest
*/
func (a *ConfigurationDeviceInventoryApiService) EditDevice(ctx context.Context, uuid string) ConfigurationDeviceInventoryApiEditDeviceRequest {
	return ConfigurationDeviceInventoryApiEditDeviceRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
func (a *ConfigurationDeviceInventoryApiService) EditDeviceExecute(r ConfigurationDeviceInventoryApiEditDeviceRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationDeviceInventoryApiService.EditDevice")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/system/device/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ConfigurationDeviceInventoryApiFormPostRequest struct {
	ctx context.Context
	ApiService *ConfigurationDeviceInventoryApiService
}

func (r ConfigurationDeviceInventoryApiFormPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.FormPostExecute(r)
}

/*
FormPost Method for FormPost

Upload file to vEdge

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationDeviceInventoryApiFormPostRequest
*/
func (a *ConfigurationDeviceInventoryApiService) FormPost(ctx context.Context) ConfigurationDeviceInventoryApiFormPostRequest {
	return ConfigurationDeviceInventoryApiFormPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ConfigurationDeviceInventoryApiService) FormPostExecute(r ConfigurationDeviceInventoryApiFormPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationDeviceInventoryApiService.FormPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/system/device/fileupload"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ConfigurationDeviceInventoryApiGenerateBootstrapConfigForVedgeRequest struct {
	ctx context.Context
	ApiService *ConfigurationDeviceInventoryApiService
	uuid string
	configtype *string
	inclDefRootCert *bool
	version *string
}

// Device config type
func (r ConfigurationDeviceInventoryApiGenerateBootstrapConfigForVedgeRequest) Configtype(configtype string) ConfigurationDeviceInventoryApiGenerateBootstrapConfigForVedgeRequest {
	r.configtype = &configtype
	return r
}

// Include default root certs flag
func (r ConfigurationDeviceInventoryApiGenerateBootstrapConfigForVedgeRequest) InclDefRootCert(inclDefRootCert bool) ConfigurationDeviceInventoryApiGenerateBootstrapConfigForVedgeRequest {
	r.inclDefRootCert = &inclDefRootCert
	return r
}

// cloud-init format version
func (r ConfigurationDeviceInventoryApiGenerateBootstrapConfigForVedgeRequest) Version(version string) ConfigurationDeviceInventoryApiGenerateBootstrapConfigForVedgeRequest {
	r.version = &version
	return r
}

func (r ConfigurationDeviceInventoryApiGenerateBootstrapConfigForVedgeRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GenerateBootstrapConfigForVedgeExecute(r)
}

/*
GenerateBootstrapConfigForVedge Method for GenerateBootstrapConfigForVedge

Create vEdge device config

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid Device uuid
 @return ConfigurationDeviceInventoryApiGenerateBootstrapConfigForVedgeRequest
*/
func (a *ConfigurationDeviceInventoryApiService) GenerateBootstrapConfigForVedge(ctx context.Context, uuid string) ConfigurationDeviceInventoryApiGenerateBootstrapConfigForVedgeRequest {
	return ConfigurationDeviceInventoryApiGenerateBootstrapConfigForVedgeRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationDeviceInventoryApiService) GenerateBootstrapConfigForVedgeExecute(r ConfigurationDeviceInventoryApiGenerateBootstrapConfigForVedgeRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationDeviceInventoryApiService.GenerateBootstrapConfigForVedge")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/system/device/bootstrap/device/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.configtype == nil {
		return localVarReturnValue, nil, reportError("configtype is required and must be specified")
	}
	if r.inclDefRootCert == nil {
		return localVarReturnValue, nil, reportError("inclDefRootCert is required and must be specified")
	}

	localVarQueryParams.Add("configtype", parameterToString(*r.configtype, ""))
	localVarQueryParams.Add("inclDefRootCert", parameterToString(*r.inclDefRootCert, ""))
	if r.version != nil {
		localVarQueryParams.Add("version", parameterToString(*r.version, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationDeviceInventoryApiGenerateBootstrapConfigForVedgesRequest struct {
	ctx context.Context
	ApiService *ConfigurationDeviceInventoryApiService
	body *map[string]interface{}
}

// Device bootstrap type and id
func (r ConfigurationDeviceInventoryApiGenerateBootstrapConfigForVedgesRequest) Body(body map[string]interface{}) ConfigurationDeviceInventoryApiGenerateBootstrapConfigForVedgesRequest {
	r.body = &body
	return r
}

func (r ConfigurationDeviceInventoryApiGenerateBootstrapConfigForVedgesRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GenerateBootstrapConfigForVedgesExecute(r)
}

/*
GenerateBootstrapConfigForVedges Method for GenerateBootstrapConfigForVedges

Create bootstrap config for software vEdges

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationDeviceInventoryApiGenerateBootstrapConfigForVedgesRequest
*/
func (a *ConfigurationDeviceInventoryApiService) GenerateBootstrapConfigForVedges(ctx context.Context) ConfigurationDeviceInventoryApiGenerateBootstrapConfigForVedgesRequest {
	return ConfigurationDeviceInventoryApiGenerateBootstrapConfigForVedgesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationDeviceInventoryApiService) GenerateBootstrapConfigForVedgesExecute(r ConfigurationDeviceInventoryApiGenerateBootstrapConfigForVedgesRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationDeviceInventoryApiService.GenerateBootstrapConfigForVedges")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/system/device/bootstrap/devices"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationDeviceInventoryApiGenerateGenericBootstrapConfigForVedgesRequest struct {
	ctx context.Context
	ApiService *ConfigurationDeviceInventoryApiService
	wanif *string
}

// Device WAN interface
func (r ConfigurationDeviceInventoryApiGenerateGenericBootstrapConfigForVedgesRequest) Wanif(wanif string) ConfigurationDeviceInventoryApiGenerateGenericBootstrapConfigForVedgesRequest {
	r.wanif = &wanif
	return r
}

func (r ConfigurationDeviceInventoryApiGenerateGenericBootstrapConfigForVedgesRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GenerateGenericBootstrapConfigForVedgesExecute(r)
}

/*
GenerateGenericBootstrapConfigForVedges Method for GenerateGenericBootstrapConfigForVedges

Create bootstrap config for software vEdges

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationDeviceInventoryApiGenerateGenericBootstrapConfigForVedgesRequest
*/
func (a *ConfigurationDeviceInventoryApiService) GenerateGenericBootstrapConfigForVedges(ctx context.Context) ConfigurationDeviceInventoryApiGenerateGenericBootstrapConfigForVedgesRequest {
	return ConfigurationDeviceInventoryApiGenerateGenericBootstrapConfigForVedgesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationDeviceInventoryApiService) GenerateGenericBootstrapConfigForVedgesExecute(r ConfigurationDeviceInventoryApiGenerateGenericBootstrapConfigForVedgesRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationDeviceInventoryApiService.GenerateGenericBootstrapConfigForVedges")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/system/device/bootstrap/generic/devices"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.wanif != nil {
		localVarQueryParams.Add("wanif", parameterToString(*r.wanif, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationDeviceInventoryApiGetAllUnclaimedDevicesRequest struct {
	ctx context.Context
	ApiService *ConfigurationDeviceInventoryApiService
}

func (r ConfigurationDeviceInventoryApiGetAllUnclaimedDevicesRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetAllUnclaimedDevicesExecute(r)
}

/*
GetAllUnclaimedDevices Method for GetAllUnclaimedDevices

Get list of all unclaimed devices

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationDeviceInventoryApiGetAllUnclaimedDevicesRequest
*/
func (a *ConfigurationDeviceInventoryApiService) GetAllUnclaimedDevices(ctx context.Context) ConfigurationDeviceInventoryApiGetAllUnclaimedDevicesRequest {
	return ConfigurationDeviceInventoryApiGetAllUnclaimedDevicesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *ConfigurationDeviceInventoryApiService) GetAllUnclaimedDevicesExecute(r ConfigurationDeviceInventoryApiGetAllUnclaimedDevicesRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationDeviceInventoryApiService.GetAllUnclaimedDevices")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/system/device/unclaimedDevices"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationDeviceInventoryApiGetBootstrapConfigZipRequest struct {
	ctx context.Context
	ApiService *ConfigurationDeviceInventoryApiService
	id string
}

func (r ConfigurationDeviceInventoryApiGetBootstrapConfigZipRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetBootstrapConfigZipExecute(r)
}

/*
GetBootstrapConfigZip Method for GetBootstrapConfigZip

Download vEdge device config

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Bootstrap config id
 @return ConfigurationDeviceInventoryApiGetBootstrapConfigZipRequest
*/
func (a *ConfigurationDeviceInventoryApiService) GetBootstrapConfigZip(ctx context.Context, id string) ConfigurationDeviceInventoryApiGetBootstrapConfigZipRequest {
	return ConfigurationDeviceInventoryApiGetBootstrapConfigZipRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationDeviceInventoryApiService) GetBootstrapConfigZipExecute(r ConfigurationDeviceInventoryApiGetBootstrapConfigZipRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationDeviceInventoryApiService.GetBootstrapConfigZip")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/system/device/bootstrap/download/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationDeviceInventoryApiGetCloudDockDataBasedOnDeviceTypeRequest struct {
	ctx context.Context
	ApiService *ConfigurationDeviceInventoryApiService
	deviceCategory string
}

func (r ConfigurationDeviceInventoryApiGetCloudDockDataBasedOnDeviceTypeRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetCloudDockDataBasedOnDeviceTypeExecute(r)
}

/*
GetCloudDockDataBasedOnDeviceType Method for GetCloudDockDataBasedOnDeviceType

Get devices details

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceCategory Device category
 @return ConfigurationDeviceInventoryApiGetCloudDockDataBasedOnDeviceTypeRequest
*/
func (a *ConfigurationDeviceInventoryApiService) GetCloudDockDataBasedOnDeviceType(ctx context.Context, deviceCategory string) ConfigurationDeviceInventoryApiGetCloudDockDataBasedOnDeviceTypeRequest {
	return ConfigurationDeviceInventoryApiGetCloudDockDataBasedOnDeviceTypeRequest{
		ApiService: a,
		ctx: ctx,
		deviceCategory: deviceCategory,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *ConfigurationDeviceInventoryApiService) GetCloudDockDataBasedOnDeviceTypeExecute(r ConfigurationDeviceInventoryApiGetCloudDockDataBasedOnDeviceTypeRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationDeviceInventoryApiService.GetCloudDockDataBasedOnDeviceType")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/system/device/type/{deviceCategory}"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceCategory"+"}", url.PathEscape(parameterToString(r.deviceCategory, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationDeviceInventoryApiGetCloudDockDefaultConfigBasedOnDeviceTypeRequest struct {
	ctx context.Context
	ApiService *ConfigurationDeviceInventoryApiService
	deviceCategory string
}

func (r ConfigurationDeviceInventoryApiGetCloudDockDefaultConfigBasedOnDeviceTypeRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetCloudDockDefaultConfigBasedOnDeviceTypeExecute(r)
}

/*
GetCloudDockDefaultConfigBasedOnDeviceType Method for GetCloudDockDefaultConfigBasedOnDeviceType

Get devices default config

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceCategory Device category
 @return ConfigurationDeviceInventoryApiGetCloudDockDefaultConfigBasedOnDeviceTypeRequest
*/
func (a *ConfigurationDeviceInventoryApiService) GetCloudDockDefaultConfigBasedOnDeviceType(ctx context.Context, deviceCategory string) ConfigurationDeviceInventoryApiGetCloudDockDefaultConfigBasedOnDeviceTypeRequest {
	return ConfigurationDeviceInventoryApiGetCloudDockDefaultConfigBasedOnDeviceTypeRequest{
		ApiService: a,
		ctx: ctx,
		deviceCategory: deviceCategory,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *ConfigurationDeviceInventoryApiService) GetCloudDockDefaultConfigBasedOnDeviceTypeExecute(r ConfigurationDeviceInventoryApiGetCloudDockDefaultConfigBasedOnDeviceTypeRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationDeviceInventoryApiService.GetCloudDockDefaultConfigBasedOnDeviceType")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/system/device/type/{deviceCategory}/defaultConfig"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceCategory"+"}", url.PathEscape(parameterToString(r.deviceCategory, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationDeviceInventoryApiGetControllerVEdgeSyncStatusRequest struct {
	ctx context.Context
	ApiService *ConfigurationDeviceInventoryApiService
}

func (r ConfigurationDeviceInventoryApiGetControllerVEdgeSyncStatusRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetControllerVEdgeSyncStatusExecute(r)
}

/*
GetControllerVEdgeSyncStatus Method for GetControllerVEdgeSyncStatus

Get controllers vEdge sync status

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationDeviceInventoryApiGetControllerVEdgeSyncStatusRequest
*/
func (a *ConfigurationDeviceInventoryApiService) GetControllerVEdgeSyncStatus(ctx context.Context) ConfigurationDeviceInventoryApiGetControllerVEdgeSyncStatusRequest {
	return ConfigurationDeviceInventoryApiGetControllerVEdgeSyncStatusRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *ConfigurationDeviceInventoryApiService) GetControllerVEdgeSyncStatusExecute(r ConfigurationDeviceInventoryApiGetControllerVEdgeSyncStatusRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationDeviceInventoryApiService.GetControllerVEdgeSyncStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/system/device/controllers/vedge/status"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationDeviceInventoryApiGetDevicesDetailsRequest struct {
	ctx context.Context
	ApiService *ConfigurationDeviceInventoryApiService
	deviceCategory string
	model *string
	state *[]CertificateStates
	uuid *[]DeviceUuid
	deviceIP *[]DeviceIP
	validity *[]CertificateValidity
	family *string
}

// Device model
func (r ConfigurationDeviceInventoryApiGetDevicesDetailsRequest) Model(model string) ConfigurationDeviceInventoryApiGetDevicesDetailsRequest {
	r.model = &model
	return r
}

// List of states
func (r ConfigurationDeviceInventoryApiGetDevicesDetailsRequest) State(state []CertificateStates) ConfigurationDeviceInventoryApiGetDevicesDetailsRequest {
	r.state = &state
	return r
}

// List of device uuid
func (r ConfigurationDeviceInventoryApiGetDevicesDetailsRequest) Uuid(uuid []DeviceUuid) ConfigurationDeviceInventoryApiGetDevicesDetailsRequest {
	r.uuid = &uuid
	return r
}

// List of device system IP
func (r ConfigurationDeviceInventoryApiGetDevicesDetailsRequest) DeviceIP(deviceIP []DeviceIP) ConfigurationDeviceInventoryApiGetDevicesDetailsRequest {
	r.deviceIP = &deviceIP
	return r
}

// List of device validity
func (r ConfigurationDeviceInventoryApiGetDevicesDetailsRequest) Validity(validity []CertificateValidity) ConfigurationDeviceInventoryApiGetDevicesDetailsRequest {
	r.validity = &validity
	return r
}

// The platform family to filter for
func (r ConfigurationDeviceInventoryApiGetDevicesDetailsRequest) Family(family string) ConfigurationDeviceInventoryApiGetDevicesDetailsRequest {
	r.family = &family
	return r
}

func (r ConfigurationDeviceInventoryApiGetDevicesDetailsRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetDevicesDetailsExecute(r)
}

/*
GetDevicesDetails Method for GetDevicesDetails

Get devices details. When {deviceCategory = controllers}, it returns vEdge sync status, vBond, vManage and vSmart.
When {deviceCategory = vedges}, it returns all available vEdge routers

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceCategory Device category
 @return ConfigurationDeviceInventoryApiGetDevicesDetailsRequest
*/
func (a *ConfigurationDeviceInventoryApiService) GetDevicesDetails(ctx context.Context, deviceCategory string) ConfigurationDeviceInventoryApiGetDevicesDetailsRequest {
	return ConfigurationDeviceInventoryApiGetDevicesDetailsRequest{
		ApiService: a,
		ctx: ctx,
		deviceCategory: deviceCategory,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *ConfigurationDeviceInventoryApiService) GetDevicesDetailsExecute(r ConfigurationDeviceInventoryApiGetDevicesDetailsRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationDeviceInventoryApiService.GetDevicesDetails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/system/device/{deviceCategory}"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceCategory"+"}", url.PathEscape(parameterToString(r.deviceCategory, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.model != nil {
		localVarQueryParams.Add("model", parameterToString(*r.model, ""))
	}
	if r.state != nil {
		t := *r.state
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("state", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("state", parameterToString(t, "multi"))
		}
	}
	if r.uuid != nil {
		t := *r.uuid
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("uuid", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("uuid", parameterToString(t, "multi"))
		}
	}
	if r.deviceIP != nil {
		t := *r.deviceIP
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("deviceIP", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("deviceIP", parameterToString(t, "multi"))
		}
	}
	if r.validity != nil {
		t := *r.validity
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("validity", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("validity", parameterToString(t, "multi"))
		}
	}
	if r.family != nil {
		localVarQueryParams.Add("family", parameterToString(*r.family, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationDeviceInventoryApiGetManagementSystemIPInfoRequest struct {
	ctx context.Context
	ApiService *ConfigurationDeviceInventoryApiService
}

func (r ConfigurationDeviceInventoryApiGetManagementSystemIPInfoRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetManagementSystemIPInfoExecute(r)
}

/*
GetManagementSystemIPInfo Method for GetManagementSystemIPInfo

Get management system IP mapping

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationDeviceInventoryApiGetManagementSystemIPInfoRequest
*/
func (a *ConfigurationDeviceInventoryApiService) GetManagementSystemIPInfo(ctx context.Context) ConfigurationDeviceInventoryApiGetManagementSystemIPInfoRequest {
	return ConfigurationDeviceInventoryApiGetManagementSystemIPInfoRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationDeviceInventoryApiService) GetManagementSystemIPInfoExecute(r ConfigurationDeviceInventoryApiGetManagementSystemIPInfoRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationDeviceInventoryApiService.GetManagementSystemIPInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/system/device/management/systemip"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationDeviceInventoryApiGetRMACandidatesRequest struct {
	ctx context.Context
	ApiService *ConfigurationDeviceInventoryApiService
	deviceType string
	uuid *string
}

// Excluded currently selected uuid
func (r ConfigurationDeviceInventoryApiGetRMACandidatesRequest) Uuid(uuid string) ConfigurationDeviceInventoryApiGetRMACandidatesRequest {
	r.uuid = &uuid
	return r
}

func (r ConfigurationDeviceInventoryApiGetRMACandidatesRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetRMACandidatesExecute(r)
}

/*
GetRMACandidates Method for GetRMACandidates

Get RMA candidates by device type

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceType Device Type
 @return ConfigurationDeviceInventoryApiGetRMACandidatesRequest
*/
func (a *ConfigurationDeviceInventoryApiService) GetRMACandidates(ctx context.Context, deviceType string) ConfigurationDeviceInventoryApiGetRMACandidatesRequest {
	return ConfigurationDeviceInventoryApiGetRMACandidatesRequest{
		ApiService: a,
		ctx: ctx,
		deviceType: deviceType,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *ConfigurationDeviceInventoryApiService) GetRMACandidatesExecute(r ConfigurationDeviceInventoryApiGetRMACandidatesRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationDeviceInventoryApiService.GetRMACandidates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/system/device/rma/candidates/{deviceType}"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceType"+"}", url.PathEscape(parameterToString(r.deviceType, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.uuid != nil {
		localVarQueryParams.Add("uuid", parameterToString(*r.uuid, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationDeviceInventoryApiGetRootCertStatusAllRequest struct {
	ctx context.Context
	ApiService *ConfigurationDeviceInventoryApiService
	state *string
}

// Root certificate state
func (r ConfigurationDeviceInventoryApiGetRootCertStatusAllRequest) State(state string) ConfigurationDeviceInventoryApiGetRootCertStatusAllRequest {
	r.state = &state
	return r
}

func (r ConfigurationDeviceInventoryApiGetRootCertStatusAllRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetRootCertStatusAllExecute(r)
}

/*
GetRootCertStatusAll Method for GetRootCertStatusAll

Get controllers vEdge sync status

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationDeviceInventoryApiGetRootCertStatusAllRequest
*/
func (a *ConfigurationDeviceInventoryApiService) GetRootCertStatusAll(ctx context.Context) ConfigurationDeviceInventoryApiGetRootCertStatusAllRequest {
	return ConfigurationDeviceInventoryApiGetRootCertStatusAllRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *ConfigurationDeviceInventoryApiService) GetRootCertStatusAllExecute(r ConfigurationDeviceInventoryApiGetRootCertStatusAllRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationDeviceInventoryApiService.GetRootCertStatusAll")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/system/device/rootcertchain/status"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.state == nil {
		return localVarReturnValue, nil, reportError("state is required and must be specified")
	}

	localVarQueryParams.Add("state", parameterToString(*r.state, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationDeviceInventoryApiGetTenantManagementSystemIPsRequest struct {
	ctx context.Context
	ApiService *ConfigurationDeviceInventoryApiService
}

func (r ConfigurationDeviceInventoryApiGetTenantManagementSystemIPsRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetTenantManagementSystemIPsExecute(r)
}

/*
GetTenantManagementSystemIPs Method for GetTenantManagementSystemIPs

Get management system IP<br><br><br>Note: In a multitenant vManage system, this API is only available in the Provider view.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationDeviceInventoryApiGetTenantManagementSystemIPsRequest
*/
func (a *ConfigurationDeviceInventoryApiService) GetTenantManagementSystemIPs(ctx context.Context) ConfigurationDeviceInventoryApiGetTenantManagementSystemIPsRequest {
	return ConfigurationDeviceInventoryApiGetTenantManagementSystemIPsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *ConfigurationDeviceInventoryApiService) GetTenantManagementSystemIPsExecute(r ConfigurationDeviceInventoryApiGetTenantManagementSystemIPsRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationDeviceInventoryApiService.GetTenantManagementSystemIPs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/system/device/tenant/management/systemip"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationDeviceInventoryApiInvalidateVmanageRootCARequest struct {
	ctx context.Context
	ApiService *ConfigurationDeviceInventoryApiService
	uuid string
}

func (r ConfigurationDeviceInventoryApiInvalidateVmanageRootCARequest) Execute() (*http.Response, error) {
	return r.ApiService.InvalidateVmanageRootCAExecute(r)
}

/*
InvalidateVmanageRootCA Method for InvalidateVmanageRootCA

Invalidate vManage root CA

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid Device uuid
 @return ConfigurationDeviceInventoryApiInvalidateVmanageRootCARequest
*/
func (a *ConfigurationDeviceInventoryApiService) InvalidateVmanageRootCA(ctx context.Context, uuid string) ConfigurationDeviceInventoryApiInvalidateVmanageRootCARequest {
	return ConfigurationDeviceInventoryApiInvalidateVmanageRootCARequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
func (a *ConfigurationDeviceInventoryApiService) InvalidateVmanageRootCAExecute(r ConfigurationDeviceInventoryApiInvalidateVmanageRootCARequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationDeviceInventoryApiService.InvalidateVmanageRootCA")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/system/device/vmanagerootca/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ConfigurationDeviceInventoryApiMigrateDeviceRequest struct {
	ctx context.Context
	ApiService *ConfigurationDeviceInventoryApiService
	uuid string
}

func (r ConfigurationDeviceInventoryApiMigrateDeviceRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.MigrateDeviceExecute(r)
}

/*
MigrateDevice Method for MigrateDevice

Migrate device software to vedge/cedge

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid Device uuid
 @return ConfigurationDeviceInventoryApiMigrateDeviceRequest
*/
func (a *ConfigurationDeviceInventoryApiService) MigrateDevice(ctx context.Context, uuid string) ConfigurationDeviceInventoryApiMigrateDeviceRequest {
	return ConfigurationDeviceInventoryApiMigrateDeviceRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationDeviceInventoryApiService) MigrateDeviceExecute(r ConfigurationDeviceInventoryApiMigrateDeviceRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationDeviceInventoryApiService.MigrateDevice")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/system/device/migrateDevice/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationDeviceInventoryApiResetVedgeCloudRequest struct {
	ctx context.Context
	ApiService *ConfigurationDeviceInventoryApiService
	uuid string
}

func (r ConfigurationDeviceInventoryApiResetVedgeCloudRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ResetVedgeCloudExecute(r)
}

/*
ResetVedgeCloud Method for ResetVedgeCloud

Reset vEdge device

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid Device uuid
 @return ConfigurationDeviceInventoryApiResetVedgeCloudRequest
*/
func (a *ConfigurationDeviceInventoryApiService) ResetVedgeCloud(ctx context.Context, uuid string) ConfigurationDeviceInventoryApiResetVedgeCloudRequest {
	return ConfigurationDeviceInventoryApiResetVedgeCloudRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationDeviceInventoryApiService) ResetVedgeCloudExecute(r ConfigurationDeviceInventoryApiResetVedgeCloudRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationDeviceInventoryApiService.ResetVedgeCloud")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/system/device/reset/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationDeviceInventoryApiSetLifeCycleRequest struct {
	ctx context.Context
	ApiService *ConfigurationDeviceInventoryApiService
	uuid string
	enable *bool
}

// lifecycle needed flag
func (r ConfigurationDeviceInventoryApiSetLifeCycleRequest) Enable(enable bool) ConfigurationDeviceInventoryApiSetLifeCycleRequest {
	r.enable = &enable
	return r
}

func (r ConfigurationDeviceInventoryApiSetLifeCycleRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.SetLifeCycleExecute(r)
}

/*
SetLifeCycle Method for SetLifeCycle

Set device lifecycle needed flag

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid Device uuid
 @return ConfigurationDeviceInventoryApiSetLifeCycleRequest
*/
func (a *ConfigurationDeviceInventoryApiService) SetLifeCycle(ctx context.Context, uuid string) ConfigurationDeviceInventoryApiSetLifeCycleRequest {
	return ConfigurationDeviceInventoryApiSetLifeCycleRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationDeviceInventoryApiService) SetLifeCycleExecute(r ConfigurationDeviceInventoryApiSetLifeCycleRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationDeviceInventoryApiService.SetLifeCycle")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/system/device/lifecycle/management/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.enable != nil {
		localVarQueryParams.Add("enable", parameterToString(*r.enable, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationDeviceInventoryApiSyncDevicesRequest struct {
	ctx context.Context
	ApiService *ConfigurationDeviceInventoryApiService
	smartAccountModel *SmartAccountModel
}

func (r ConfigurationDeviceInventoryApiSyncDevicesRequest) SmartAccountModel(smartAccountModel SmartAccountModel) ConfigurationDeviceInventoryApiSyncDevicesRequest {
	r.smartAccountModel = &smartAccountModel
	return r
}

func (r ConfigurationDeviceInventoryApiSyncDevicesRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.SyncDevicesExecute(r)
}

/*
SyncDevices Method for SyncDevices

Sync devices from Smart-Account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationDeviceInventoryApiSyncDevicesRequest
*/
func (a *ConfigurationDeviceInventoryApiService) SyncDevices(ctx context.Context) ConfigurationDeviceInventoryApiSyncDevicesRequest {
	return ConfigurationDeviceInventoryApiSyncDevicesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationDeviceInventoryApiService) SyncDevicesExecute(r ConfigurationDeviceInventoryApiSyncDevicesRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationDeviceInventoryApiService.SyncDevices")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/system/device/smartaccount/sync"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.smartAccountModel
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationDeviceInventoryApiSyncRootCertChainRequest struct {
	ctx context.Context
	ApiService *ConfigurationDeviceInventoryApiService
}

func (r ConfigurationDeviceInventoryApiSyncRootCertChainRequest) Execute() (*http.Response, error) {
	return r.ApiService.SyncRootCertChainExecute(r)
}

/*
SyncRootCertChain Method for SyncRootCertChain

Sync root certificate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationDeviceInventoryApiSyncRootCertChainRequest
*/
func (a *ConfigurationDeviceInventoryApiService) SyncRootCertChain(ctx context.Context) ConfigurationDeviceInventoryApiSyncRootCertChainRequest {
	return ConfigurationDeviceInventoryApiSyncRootCertChainRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ConfigurationDeviceInventoryApiService) SyncRootCertChainExecute(r ConfigurationDeviceInventoryApiSyncRootCertChainRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationDeviceInventoryApiService.SyncRootCertChain")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/system/device/sync/rootcertchain"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ConfigurationDeviceInventoryApiUpdateDeviceSubjectSUDIRequest struct {
	ctx context.Context
	ApiService *ConfigurationDeviceInventoryApiService
	uuid string
}

func (r ConfigurationDeviceInventoryApiUpdateDeviceSubjectSUDIRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateDeviceSubjectSUDIExecute(r)
}

/*
UpdateDeviceSubjectSUDI Method for UpdateDeviceSubjectSUDI

update subject sudi value of given device uuid

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid Device uuid
 @return ConfigurationDeviceInventoryApiUpdateDeviceSubjectSUDIRequest
*/
func (a *ConfigurationDeviceInventoryApiService) UpdateDeviceSubjectSUDI(ctx context.Context, uuid string) ConfigurationDeviceInventoryApiUpdateDeviceSubjectSUDIRequest {
	return ConfigurationDeviceInventoryApiUpdateDeviceSubjectSUDIRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
func (a *ConfigurationDeviceInventoryApiService) UpdateDeviceSubjectSUDIExecute(r ConfigurationDeviceInventoryApiUpdateDeviceSubjectSUDIRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationDeviceInventoryApiService.UpdateDeviceSubjectSUDI")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/system/device/updateDeviceSubjectSUDI/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ConfigurationDeviceInventoryApiValidateUserRequest struct {
	ctx context.Context
	ApiService *ConfigurationDeviceInventoryApiService
	smartAccountModel *SmartAccountModel
}

func (r ConfigurationDeviceInventoryApiValidateUserRequest) SmartAccountModel(smartAccountModel SmartAccountModel) ConfigurationDeviceInventoryApiValidateUserRequest {
	r.smartAccountModel = &smartAccountModel
	return r
}

func (r ConfigurationDeviceInventoryApiValidateUserRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ValidateUserExecute(r)
}

/*
ValidateUser Method for ValidateUser

Authenticate vSmart user account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationDeviceInventoryApiValidateUserRequest
*/
func (a *ConfigurationDeviceInventoryApiService) ValidateUser(ctx context.Context) ConfigurationDeviceInventoryApiValidateUserRequest {
	return ConfigurationDeviceInventoryApiValidateUserRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationDeviceInventoryApiService) ValidateUserExecute(r ConfigurationDeviceInventoryApiValidateUserRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationDeviceInventoryApiService.ValidateUser")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/system/device/smartaccount/authenticate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.smartAccountModel
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationDeviceInventoryApiValidateUser1Request struct {
	ctx context.Context
	ApiService *ConfigurationDeviceInventoryApiService
	requestBody *map[string]GetO365PreferredPathFromVAnalyticsRequestValue
}

func (r ConfigurationDeviceInventoryApiValidateUser1Request) RequestBody(requestBody map[string]GetO365PreferredPathFromVAnalyticsRequestValue) ConfigurationDeviceInventoryApiValidateUser1Request {
	r.requestBody = &requestBody
	return r
}

func (r ConfigurationDeviceInventoryApiValidateUser1Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ValidateUser1Execute(r)
}

/*
ValidateUser1 Method for ValidateUser1

Authenticate vSmart user account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationDeviceInventoryApiValidateUser1Request
*/
func (a *ConfigurationDeviceInventoryApiService) ValidateUser1(ctx context.Context) ConfigurationDeviceInventoryApiValidateUser1Request {
	return ConfigurationDeviceInventoryApiValidateUser1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationDeviceInventoryApiService) ValidateUser1Execute(r ConfigurationDeviceInventoryApiValidateUser1Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationDeviceInventoryApiService.ValidateUser1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/system/device/generate-payg"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
