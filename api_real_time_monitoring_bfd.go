/*
Cisco SD-WAN vManage API

The vManage API exposes the functionality of operations maintaining devices and the overlay network

API version: 2.0.0
Contact: vmanage@cisco.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"reflect"
)


// RealTimeMonitoringBFDApiService RealTimeMonitoringBFDApi service
type RealTimeMonitoringBFDApiService service

type RealTimeMonitoringBFDApiCreateBFDHistoryListRequest struct {
	ctx context.Context
	ApiService *RealTimeMonitoringBFDApiService
	deviceId *string
	systemIp *string
	color *string
}

// Device IP
func (r RealTimeMonitoringBFDApiCreateBFDHistoryListRequest) DeviceId(deviceId string) RealTimeMonitoringBFDApiCreateBFDHistoryListRequest {
	r.deviceId = &deviceId
	return r
}

// System IP
func (r RealTimeMonitoringBFDApiCreateBFDHistoryListRequest) SystemIp(systemIp string) RealTimeMonitoringBFDApiCreateBFDHistoryListRequest {
	r.systemIp = &systemIp
	return r
}

// Remote color
func (r RealTimeMonitoringBFDApiCreateBFDHistoryListRequest) Color(color string) RealTimeMonitoringBFDApiCreateBFDHistoryListRequest {
	r.color = &color
	return r
}

func (r RealTimeMonitoringBFDApiCreateBFDHistoryListRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.CreateBFDHistoryListExecute(r)
}

/*
CreateBFDHistoryList Method for CreateBFDHistoryList

Get BFD session history from device (Real Time)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return RealTimeMonitoringBFDApiCreateBFDHistoryListRequest
*/
func (a *RealTimeMonitoringBFDApiService) CreateBFDHistoryList(ctx context.Context) RealTimeMonitoringBFDApiCreateBFDHistoryListRequest {
	return RealTimeMonitoringBFDApiCreateBFDHistoryListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *RealTimeMonitoringBFDApiService) CreateBFDHistoryListExecute(r RealTimeMonitoringBFDApiCreateBFDHistoryListRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealTimeMonitoringBFDApiService.CreateBFDHistoryList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/bfd/history"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deviceId == nil {
		return localVarReturnValue, nil, reportError("deviceId is required and must be specified")
	}

	if r.systemIp != nil {
		localVarQueryParams.Add("system-ip", parameterToString(*r.systemIp, ""))
	}
	if r.color != nil {
		localVarQueryParams.Add("color", parameterToString(*r.color, ""))
	}
	localVarQueryParams.Add("deviceId", parameterToString(*r.deviceId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RealTimeMonitoringBFDApiCreateBFDLinkListRequest struct {
	ctx context.Context
	ApiService *RealTimeMonitoringBFDApiService
	state *string
}

// Device state
func (r RealTimeMonitoringBFDApiCreateBFDLinkListRequest) State(state string) RealTimeMonitoringBFDApiCreateBFDLinkListRequest {
	r.state = &state
	return r
}

func (r RealTimeMonitoringBFDApiCreateBFDLinkListRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.CreateBFDLinkListExecute(r)
}

/*
CreateBFDLinkList Method for CreateBFDLinkList

Get list of BFD connections

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return RealTimeMonitoringBFDApiCreateBFDLinkListRequest
*/
func (a *RealTimeMonitoringBFDApiService) CreateBFDLinkList(ctx context.Context) RealTimeMonitoringBFDApiCreateBFDLinkListRequest {
	return RealTimeMonitoringBFDApiCreateBFDLinkListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *RealTimeMonitoringBFDApiService) CreateBFDLinkListExecute(r RealTimeMonitoringBFDApiCreateBFDLinkListRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealTimeMonitoringBFDApiService.CreateBFDLinkList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/bfd/links"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.state == nil {
		return localVarReturnValue, nil, reportError("state is required and must be specified")
	}

	localVarQueryParams.Add("state", parameterToString(*r.state, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RealTimeMonitoringBFDApiCreateBFDSessionsRequest struct {
	ctx context.Context
	ApiService *RealTimeMonitoringBFDApiService
	deviceId *string
	systemIp *string
	color *string
	localColor *string
	regionType *string
}

// Device IP
func (r RealTimeMonitoringBFDApiCreateBFDSessionsRequest) DeviceId(deviceId string) RealTimeMonitoringBFDApiCreateBFDSessionsRequest {
	r.deviceId = &deviceId
	return r
}

// System IP
func (r RealTimeMonitoringBFDApiCreateBFDSessionsRequest) SystemIp(systemIp string) RealTimeMonitoringBFDApiCreateBFDSessionsRequest {
	r.systemIp = &systemIp
	return r
}

// Remote color
func (r RealTimeMonitoringBFDApiCreateBFDSessionsRequest) Color(color string) RealTimeMonitoringBFDApiCreateBFDSessionsRequest {
	r.color = &color
	return r
}

// Source color
func (r RealTimeMonitoringBFDApiCreateBFDSessionsRequest) LocalColor(localColor string) RealTimeMonitoringBFDApiCreateBFDSessionsRequest {
	r.localColor = &localColor
	return r
}

// Region type
func (r RealTimeMonitoringBFDApiCreateBFDSessionsRequest) RegionType(regionType string) RealTimeMonitoringBFDApiCreateBFDSessionsRequest {
	r.regionType = &regionType
	return r
}

func (r RealTimeMonitoringBFDApiCreateBFDSessionsRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.CreateBFDSessionsExecute(r)
}

/*
CreateBFDSessions Method for CreateBFDSessions

Get list of BFD sessions from vManage (Real Time)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return RealTimeMonitoringBFDApiCreateBFDSessionsRequest
*/
func (a *RealTimeMonitoringBFDApiService) CreateBFDSessions(ctx context.Context) RealTimeMonitoringBFDApiCreateBFDSessionsRequest {
	return RealTimeMonitoringBFDApiCreateBFDSessionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *RealTimeMonitoringBFDApiService) CreateBFDSessionsExecute(r RealTimeMonitoringBFDApiCreateBFDSessionsRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealTimeMonitoringBFDApiService.CreateBFDSessions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/bfd/sessions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deviceId == nil {
		return localVarReturnValue, nil, reportError("deviceId is required and must be specified")
	}

	if r.systemIp != nil {
		localVarQueryParams.Add("system-ip", parameterToString(*r.systemIp, ""))
	}
	if r.color != nil {
		localVarQueryParams.Add("color", parameterToString(*r.color, ""))
	}
	if r.localColor != nil {
		localVarQueryParams.Add("local-color", parameterToString(*r.localColor, ""))
	}
	if r.regionType != nil {
		localVarQueryParams.Add("region-type", parameterToString(*r.regionType, ""))
	}
	localVarQueryParams.Add("deviceId", parameterToString(*r.deviceId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RealTimeMonitoringBFDApiCreateBFDSummaryRequest struct {
	ctx context.Context
	ApiService *RealTimeMonitoringBFDApiService
	deviceId *string
}

// Device IP
func (r RealTimeMonitoringBFDApiCreateBFDSummaryRequest) DeviceId(deviceId string) RealTimeMonitoringBFDApiCreateBFDSummaryRequest {
	r.deviceId = &deviceId
	return r
}

func (r RealTimeMonitoringBFDApiCreateBFDSummaryRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.CreateBFDSummaryExecute(r)
}

/*
CreateBFDSummary Method for CreateBFDSummary

Get BFD summary from device (Real Time)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return RealTimeMonitoringBFDApiCreateBFDSummaryRequest
*/
func (a *RealTimeMonitoringBFDApiService) CreateBFDSummary(ctx context.Context) RealTimeMonitoringBFDApiCreateBFDSummaryRequest {
	return RealTimeMonitoringBFDApiCreateBFDSummaryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *RealTimeMonitoringBFDApiService) CreateBFDSummaryExecute(r RealTimeMonitoringBFDApiCreateBFDSummaryRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealTimeMonitoringBFDApiService.CreateBFDSummary")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/bfd/summary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deviceId == nil {
		return localVarReturnValue, nil, reportError("deviceId is required and must be specified")
	}

	localVarQueryParams.Add("deviceId", parameterToString(*r.deviceId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RealTimeMonitoringBFDApiCreateSyncedBFDSessionRequest struct {
	ctx context.Context
	ApiService *RealTimeMonitoringBFDApiService
	deviceId *string
	systemIp *string
	color *string
	localColor *string
}

// Device Id
func (r RealTimeMonitoringBFDApiCreateSyncedBFDSessionRequest) DeviceId(deviceId string) RealTimeMonitoringBFDApiCreateSyncedBFDSessionRequest {
	r.deviceId = &deviceId
	return r
}

// System IP
func (r RealTimeMonitoringBFDApiCreateSyncedBFDSessionRequest) SystemIp(systemIp string) RealTimeMonitoringBFDApiCreateSyncedBFDSessionRequest {
	r.systemIp = &systemIp
	return r
}

// Remote color
func (r RealTimeMonitoringBFDApiCreateSyncedBFDSessionRequest) Color(color string) RealTimeMonitoringBFDApiCreateSyncedBFDSessionRequest {
	r.color = &color
	return r
}

// Source color
func (r RealTimeMonitoringBFDApiCreateSyncedBFDSessionRequest) LocalColor(localColor string) RealTimeMonitoringBFDApiCreateSyncedBFDSessionRequest {
	r.localColor = &localColor
	return r
}

func (r RealTimeMonitoringBFDApiCreateSyncedBFDSessionRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.CreateSyncedBFDSessionExecute(r)
}

/*
CreateSyncedBFDSession Method for CreateSyncedBFDSession

Get list of BFD sessions from vManage synchronously

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return RealTimeMonitoringBFDApiCreateSyncedBFDSessionRequest
*/
func (a *RealTimeMonitoringBFDApiService) CreateSyncedBFDSession(ctx context.Context) RealTimeMonitoringBFDApiCreateSyncedBFDSessionRequest {
	return RealTimeMonitoringBFDApiCreateSyncedBFDSessionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *RealTimeMonitoringBFDApiService) CreateSyncedBFDSessionExecute(r RealTimeMonitoringBFDApiCreateSyncedBFDSessionRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealTimeMonitoringBFDApiService.CreateSyncedBFDSession")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/bfd/synced/sessions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deviceId == nil {
		return localVarReturnValue, nil, reportError("deviceId is required and must be specified")
	}

	if r.systemIp != nil {
		localVarQueryParams.Add("system-ip", parameterToString(*r.systemIp, ""))
	}
	if r.color != nil {
		localVarQueryParams.Add("color", parameterToString(*r.color, ""))
	}
	if r.localColor != nil {
		localVarQueryParams.Add("local-color", parameterToString(*r.localColor, ""))
	}
	localVarQueryParams.Add("deviceId", parameterToString(*r.deviceId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RealTimeMonitoringBFDApiCreateTLOCSummaryRequest struct {
	ctx context.Context
	ApiService *RealTimeMonitoringBFDApiService
	deviceId *string
}

// Device IP
func (r RealTimeMonitoringBFDApiCreateTLOCSummaryRequest) DeviceId(deviceId string) RealTimeMonitoringBFDApiCreateTLOCSummaryRequest {
	r.deviceId = &deviceId
	return r
}

func (r RealTimeMonitoringBFDApiCreateTLOCSummaryRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.CreateTLOCSummaryExecute(r)
}

/*
CreateTLOCSummary Method for CreateTLOCSummary

Get TLOC summary from device (Real Time)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return RealTimeMonitoringBFDApiCreateTLOCSummaryRequest
*/
func (a *RealTimeMonitoringBFDApiService) CreateTLOCSummary(ctx context.Context) RealTimeMonitoringBFDApiCreateTLOCSummaryRequest {
	return RealTimeMonitoringBFDApiCreateTLOCSummaryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *RealTimeMonitoringBFDApiService) CreateTLOCSummaryExecute(r RealTimeMonitoringBFDApiCreateTLOCSummaryRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealTimeMonitoringBFDApiService.CreateTLOCSummary")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/bfd/tloc"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deviceId == nil {
		return localVarReturnValue, nil, reportError("deviceId is required and must be specified")
	}

	localVarQueryParams.Add("deviceId", parameterToString(*r.deviceId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RealTimeMonitoringBFDApiGetBFDSiteStateDetailRequest struct {
	ctx context.Context
	ApiService *RealTimeMonitoringBFDApiService
}

func (r RealTimeMonitoringBFDApiGetBFDSiteStateDetailRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetBFDSiteStateDetailExecute(r)
}

/*
GetBFDSiteStateDetail Method for GetBFDSiteStateDetail

Get detailed BFD site details

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return RealTimeMonitoringBFDApiGetBFDSiteStateDetailRequest
*/
func (a *RealTimeMonitoringBFDApiService) GetBFDSiteStateDetail(ctx context.Context) RealTimeMonitoringBFDApiGetBFDSiteStateDetailRequest {
	return RealTimeMonitoringBFDApiGetBFDSiteStateDetailRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *RealTimeMonitoringBFDApiService) GetBFDSiteStateDetailExecute(r RealTimeMonitoringBFDApiGetBFDSiteStateDetailRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealTimeMonitoringBFDApiService.GetBFDSiteStateDetail")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/bfd/sites/detail"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RealTimeMonitoringBFDApiGetBFDSitesSummaryRequest struct {
	ctx context.Context
	ApiService *RealTimeMonitoringBFDApiService
	vpnId *[]VPNID
	isCached *bool
}

// Filter VPN
func (r RealTimeMonitoringBFDApiGetBFDSitesSummaryRequest) VpnId(vpnId []VPNID) RealTimeMonitoringBFDApiGetBFDSitesSummaryRequest {
	r.vpnId = &vpnId
	return r
}

// Flag for caching
func (r RealTimeMonitoringBFDApiGetBFDSitesSummaryRequest) IsCached(isCached bool) RealTimeMonitoringBFDApiGetBFDSitesSummaryRequest {
	r.isCached = &isCached
	return r
}

func (r RealTimeMonitoringBFDApiGetBFDSitesSummaryRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetBFDSitesSummaryExecute(r)
}

/*
GetBFDSitesSummary Method for GetBFDSitesSummary

Get BFD site summary

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return RealTimeMonitoringBFDApiGetBFDSitesSummaryRequest
*/
func (a *RealTimeMonitoringBFDApiService) GetBFDSitesSummary(ctx context.Context) RealTimeMonitoringBFDApiGetBFDSitesSummaryRequest {
	return RealTimeMonitoringBFDApiGetBFDSitesSummaryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *RealTimeMonitoringBFDApiService) GetBFDSitesSummaryExecute(r RealTimeMonitoringBFDApiGetBFDSitesSummaryRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealTimeMonitoringBFDApiService.GetBFDSitesSummary")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/bfd/sites/summary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vpnId == nil {
		return localVarReturnValue, nil, reportError("vpnId is required and must be specified")
	}

	if r.isCached != nil {
		localVarQueryParams.Add("isCached", parameterToString(*r.isCached, ""))
	}
	{
		t := *r.vpnId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("vpnId", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("vpnId", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RealTimeMonitoringBFDApiGetDeviceBFDStateSummaryRequest struct {
	ctx context.Context
	ApiService *RealTimeMonitoringBFDApiService
	deviceId *string
}

// Device Id
func (r RealTimeMonitoringBFDApiGetDeviceBFDStateSummaryRequest) DeviceId(deviceId string) RealTimeMonitoringBFDApiGetDeviceBFDStateSummaryRequest {
	r.deviceId = &deviceId
	return r
}

func (r RealTimeMonitoringBFDApiGetDeviceBFDStateSummaryRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetDeviceBFDStateSummaryExecute(r)
}

/*
GetDeviceBFDStateSummary Method for GetDeviceBFDStateSummary

Get device BFD state summary

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return RealTimeMonitoringBFDApiGetDeviceBFDStateSummaryRequest
*/
func (a *RealTimeMonitoringBFDApiService) GetDeviceBFDStateSummary(ctx context.Context) RealTimeMonitoringBFDApiGetDeviceBFDStateSummaryRequest {
	return RealTimeMonitoringBFDApiGetDeviceBFDStateSummaryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *RealTimeMonitoringBFDApiService) GetDeviceBFDStateSummaryExecute(r RealTimeMonitoringBFDApiGetDeviceBFDStateSummaryRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealTimeMonitoringBFDApiService.GetDeviceBFDStateSummary")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/bfd/state/device"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deviceId == nil {
		return localVarReturnValue, nil, reportError("deviceId is required and must be specified")
	}

	localVarQueryParams.Add("deviceId", parameterToString(*r.deviceId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RealTimeMonitoringBFDApiGetDeviceBFDStateSummaryTlocRequest struct {
	ctx context.Context
	ApiService *RealTimeMonitoringBFDApiService
	deviceId *string
}

// Device Id
func (r RealTimeMonitoringBFDApiGetDeviceBFDStateSummaryTlocRequest) DeviceId(deviceId string) RealTimeMonitoringBFDApiGetDeviceBFDStateSummaryTlocRequest {
	r.deviceId = &deviceId
	return r
}

func (r RealTimeMonitoringBFDApiGetDeviceBFDStateSummaryTlocRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetDeviceBFDStateSummaryTlocExecute(r)
}

/*
GetDeviceBFDStateSummaryTloc Method for GetDeviceBFDStateSummaryTloc

Get device BFD state summary with tloc color

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return RealTimeMonitoringBFDApiGetDeviceBFDStateSummaryTlocRequest
*/
func (a *RealTimeMonitoringBFDApiService) GetDeviceBFDStateSummaryTloc(ctx context.Context) RealTimeMonitoringBFDApiGetDeviceBFDStateSummaryTlocRequest {
	return RealTimeMonitoringBFDApiGetDeviceBFDStateSummaryTlocRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *RealTimeMonitoringBFDApiService) GetDeviceBFDStateSummaryTlocExecute(r RealTimeMonitoringBFDApiGetDeviceBFDStateSummaryTlocRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealTimeMonitoringBFDApiService.GetDeviceBFDStateSummaryTloc")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/bfd/state/device/tloc"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deviceId == nil {
		return localVarReturnValue, nil, reportError("deviceId is required and must be specified")
	}

	localVarQueryParams.Add("deviceId", parameterToString(*r.deviceId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RealTimeMonitoringBFDApiGetDeviceBFDStatusRequest struct {
	ctx context.Context
	ApiService *RealTimeMonitoringBFDApiService
}

func (r RealTimeMonitoringBFDApiGetDeviceBFDStatusRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetDeviceBFDStatusExecute(r)
}

/*
GetDeviceBFDStatus Method for GetDeviceBFDStatus

Get device BFD status

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return RealTimeMonitoringBFDApiGetDeviceBFDStatusRequest
*/
func (a *RealTimeMonitoringBFDApiService) GetDeviceBFDStatus(ctx context.Context) RealTimeMonitoringBFDApiGetDeviceBFDStatusRequest {
	return RealTimeMonitoringBFDApiGetDeviceBFDStatusRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *RealTimeMonitoringBFDApiService) GetDeviceBFDStatusExecute(r RealTimeMonitoringBFDApiGetDeviceBFDStatusRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealTimeMonitoringBFDApiService.GetDeviceBFDStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/bfd/status"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RealTimeMonitoringBFDApiGetDeviceBFDStatusSummaryRequest struct {
	ctx context.Context
	ApiService *RealTimeMonitoringBFDApiService
	deviceId *string
}

// Device Id
func (r RealTimeMonitoringBFDApiGetDeviceBFDStatusSummaryRequest) DeviceId(deviceId string) RealTimeMonitoringBFDApiGetDeviceBFDStatusSummaryRequest {
	r.deviceId = &deviceId
	return r
}

func (r RealTimeMonitoringBFDApiGetDeviceBFDStatusSummaryRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetDeviceBFDStatusSummaryExecute(r)
}

/*
GetDeviceBFDStatusSummary Method for GetDeviceBFDStatusSummary

Get device BFD status summary

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return RealTimeMonitoringBFDApiGetDeviceBFDStatusSummaryRequest
*/
func (a *RealTimeMonitoringBFDApiService) GetDeviceBFDStatusSummary(ctx context.Context) RealTimeMonitoringBFDApiGetDeviceBFDStatusSummaryRequest {
	return RealTimeMonitoringBFDApiGetDeviceBFDStatusSummaryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *RealTimeMonitoringBFDApiService) GetDeviceBFDStatusSummaryExecute(r RealTimeMonitoringBFDApiGetDeviceBFDStatusSummaryRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealTimeMonitoringBFDApiService.GetDeviceBFDStatusSummary")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/bfd/summary/device"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deviceId == nil {
		return localVarReturnValue, nil, reportError("deviceId is required and must be specified")
	}

	localVarQueryParams.Add("deviceId", parameterToString(*r.deviceId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
