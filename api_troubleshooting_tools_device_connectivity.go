/*
Cisco SD-WAN vManage API

The vManage API exposes the functionality of operations maintaining devices and the overlay network

API version: 2.0.0
Contact: vmanage@cisco.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// TroubleshootingToolsDeviceConnectivityApiService TroubleshootingToolsDeviceConnectivityApi service
type TroubleshootingToolsDeviceConnectivityApiService service

type TroubleshootingToolsDeviceConnectivityApiCopyAdminTechOnDeviceRequest struct {
	ctx context.Context
	ApiService *TroubleshootingToolsDeviceConnectivityApiService
	body *map[string]interface{}
}

// Admin tech copy request
func (r TroubleshootingToolsDeviceConnectivityApiCopyAdminTechOnDeviceRequest) Body(body map[string]interface{}) TroubleshootingToolsDeviceConnectivityApiCopyAdminTechOnDeviceRequest {
	r.body = &body
	return r
}

func (r TroubleshootingToolsDeviceConnectivityApiCopyAdminTechOnDeviceRequest) Execute() (*http.Response, error) {
	return r.ApiService.CopyAdminTechOnDeviceExecute(r)
}

/*
CopyAdminTechOnDevice Method for CopyAdminTechOnDevice

copy admin tech logs

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TroubleshootingToolsDeviceConnectivityApiCopyAdminTechOnDeviceRequest
*/
func (a *TroubleshootingToolsDeviceConnectivityApiService) CopyAdminTechOnDevice(ctx context.Context) TroubleshootingToolsDeviceConnectivityApiCopyAdminTechOnDeviceRequest {
	return TroubleshootingToolsDeviceConnectivityApiCopyAdminTechOnDeviceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *TroubleshootingToolsDeviceConnectivityApiService) CopyAdminTechOnDeviceExecute(r TroubleshootingToolsDeviceConnectivityApiCopyAdminTechOnDeviceRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TroubleshootingToolsDeviceConnectivityApiService.CopyAdminTechOnDevice")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/tools/admintech/copy"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type TroubleshootingToolsDeviceConnectivityApiCreateAdminTechRequest struct {
	ctx context.Context
	ApiService *TroubleshootingToolsDeviceConnectivityApiService
	body *map[string]interface{}
}

// Admin tech generation request
func (r TroubleshootingToolsDeviceConnectivityApiCreateAdminTechRequest) Body(body map[string]interface{}) TroubleshootingToolsDeviceConnectivityApiCreateAdminTechRequest {
	r.body = &body
	return r
}

func (r TroubleshootingToolsDeviceConnectivityApiCreateAdminTechRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateAdminTechExecute(r)
}

/*
CreateAdminTech Method for CreateAdminTech

Generate admin tech logs

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TroubleshootingToolsDeviceConnectivityApiCreateAdminTechRequest
*/
func (a *TroubleshootingToolsDeviceConnectivityApiService) CreateAdminTech(ctx context.Context) TroubleshootingToolsDeviceConnectivityApiCreateAdminTechRequest {
	return TroubleshootingToolsDeviceConnectivityApiCreateAdminTechRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *TroubleshootingToolsDeviceConnectivityApiService) CreateAdminTechExecute(r TroubleshootingToolsDeviceConnectivityApiCreateAdminTechRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TroubleshootingToolsDeviceConnectivityApiService.CreateAdminTech")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/tools/admintech"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type TroubleshootingToolsDeviceConnectivityApiDeleteAdminTechFileRequest struct {
	ctx context.Context
	ApiService *TroubleshootingToolsDeviceConnectivityApiService
	requestID string
}

func (r TroubleshootingToolsDeviceConnectivityApiDeleteAdminTechFileRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteAdminTechFileExecute(r)
}

/*
DeleteAdminTechFile Method for DeleteAdminTechFile

Delete admin tech logs

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param requestID Request Id of admin tech generation request
 @return TroubleshootingToolsDeviceConnectivityApiDeleteAdminTechFileRequest
*/
func (a *TroubleshootingToolsDeviceConnectivityApiService) DeleteAdminTechFile(ctx context.Context, requestID string) TroubleshootingToolsDeviceConnectivityApiDeleteAdminTechFileRequest {
	return TroubleshootingToolsDeviceConnectivityApiDeleteAdminTechFileRequest{
		ApiService: a,
		ctx: ctx,
		requestID: requestID,
	}
}

// Execute executes the request
func (a *TroubleshootingToolsDeviceConnectivityApiService) DeleteAdminTechFileExecute(r TroubleshootingToolsDeviceConnectivityApiDeleteAdminTechFileRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TroubleshootingToolsDeviceConnectivityApiService.DeleteAdminTechFile")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/tools/admintech/{requestID}"
	localVarPath = strings.Replace(localVarPath, "{"+"requestID"+"}", url.PathEscape(parameterToString(r.requestID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type TroubleshootingToolsDeviceConnectivityApiDeleteAdminTechOnDeviceRequest struct {
	ctx context.Context
	ApiService *TroubleshootingToolsDeviceConnectivityApiService
	body *map[string]interface{}
}

// Admin tech copy request
func (r TroubleshootingToolsDeviceConnectivityApiDeleteAdminTechOnDeviceRequest) Body(body map[string]interface{}) TroubleshootingToolsDeviceConnectivityApiDeleteAdminTechOnDeviceRequest {
	r.body = &body
	return r
}

func (r TroubleshootingToolsDeviceConnectivityApiDeleteAdminTechOnDeviceRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteAdminTechOnDeviceExecute(r)
}

/*
DeleteAdminTechOnDevice Method for DeleteAdminTechOnDevice

delete admin tech logs

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TroubleshootingToolsDeviceConnectivityApiDeleteAdminTechOnDeviceRequest
*/
func (a *TroubleshootingToolsDeviceConnectivityApiService) DeleteAdminTechOnDevice(ctx context.Context) TroubleshootingToolsDeviceConnectivityApiDeleteAdminTechOnDeviceRequest {
	return TroubleshootingToolsDeviceConnectivityApiDeleteAdminTechOnDeviceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *TroubleshootingToolsDeviceConnectivityApiService) DeleteAdminTechOnDeviceExecute(r TroubleshootingToolsDeviceConnectivityApiDeleteAdminTechOnDeviceRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TroubleshootingToolsDeviceConnectivityApiService.DeleteAdminTechOnDevice")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/tools/admintech/delete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type TroubleshootingToolsDeviceConnectivityApiDownloadAdminTechFileRequest struct {
	ctx context.Context
	ApiService *TroubleshootingToolsDeviceConnectivityApiService
	filename string
}

func (r TroubleshootingToolsDeviceConnectivityApiDownloadAdminTechFileRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.DownloadAdminTechFileExecute(r)
}

/*
DownloadAdminTechFile Method for DownloadAdminTechFile

Download admin tech logs

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param filename Admin tech file
 @return TroubleshootingToolsDeviceConnectivityApiDownloadAdminTechFileRequest
*/
func (a *TroubleshootingToolsDeviceConnectivityApiService) DownloadAdminTechFile(ctx context.Context, filename string) TroubleshootingToolsDeviceConnectivityApiDownloadAdminTechFileRequest {
	return TroubleshootingToolsDeviceConnectivityApiDownloadAdminTechFileRequest{
		ApiService: a,
		ctx: ctx,
		filename: filename,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *TroubleshootingToolsDeviceConnectivityApiService) DownloadAdminTechFileExecute(r TroubleshootingToolsDeviceConnectivityApiDownloadAdminTechFileRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TroubleshootingToolsDeviceConnectivityApiService.DownloadAdminTechFile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/tools/admintech/download/{filename}"
	localVarPath = strings.Replace(localVarPath, "{"+"filename"+"}", url.PathEscape(parameterToString(r.filename, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TroubleshootingToolsDeviceConnectivityApiFactoryResetRequest struct {
	ctx context.Context
	ApiService *TroubleshootingToolsDeviceConnectivityApiService
	body *map[string]interface{}
}

// Device factory reset
func (r TroubleshootingToolsDeviceConnectivityApiFactoryResetRequest) Body(body map[string]interface{}) TroubleshootingToolsDeviceConnectivityApiFactoryResetRequest {
	r.body = &body
	return r
}

func (r TroubleshootingToolsDeviceConnectivityApiFactoryResetRequest) Execute() (*http.Response, error) {
	return r.ApiService.FactoryResetExecute(r)
}

/*
FactoryReset Method for FactoryReset

Device factory reset

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TroubleshootingToolsDeviceConnectivityApiFactoryResetRequest
*/
func (a *TroubleshootingToolsDeviceConnectivityApiService) FactoryReset(ctx context.Context) TroubleshootingToolsDeviceConnectivityApiFactoryResetRequest {
	return TroubleshootingToolsDeviceConnectivityApiFactoryResetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *TroubleshootingToolsDeviceConnectivityApiService) FactoryResetExecute(r TroubleshootingToolsDeviceConnectivityApiFactoryResetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TroubleshootingToolsDeviceConnectivityApiService.FactoryReset")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/tools/factoryreset"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type TroubleshootingToolsDeviceConnectivityApiGetControlConnectionsRequest struct {
	ctx context.Context
	ApiService *TroubleshootingToolsDeviceConnectivityApiService
	uuid string
}

func (r TroubleshootingToolsDeviceConnectivityApiGetControlConnectionsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetControlConnectionsExecute(r)
}

/*
GetControlConnections Method for GetControlConnections

Troubleshoot control connections

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid Device uuid
 @return TroubleshootingToolsDeviceConnectivityApiGetControlConnectionsRequest
*/
func (a *TroubleshootingToolsDeviceConnectivityApiService) GetControlConnections(ctx context.Context, uuid string) TroubleshootingToolsDeviceConnectivityApiGetControlConnectionsRequest {
	return TroubleshootingToolsDeviceConnectivityApiGetControlConnectionsRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *TroubleshootingToolsDeviceConnectivityApiService) GetControlConnectionsExecute(r TroubleshootingToolsDeviceConnectivityApiGetControlConnectionsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TroubleshootingToolsDeviceConnectivityApiService.GetControlConnections")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/troubleshooting/control/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TroubleshootingToolsDeviceConnectivityApiGetDeviceConfigurationRequest struct {
	ctx context.Context
	ApiService *TroubleshootingToolsDeviceConnectivityApiService
	uuid *string
}

// Device uuid
func (r TroubleshootingToolsDeviceConnectivityApiGetDeviceConfigurationRequest) Uuid(uuid string) TroubleshootingToolsDeviceConnectivityApiGetDeviceConfigurationRequest {
	r.uuid = &uuid
	return r
}

func (r TroubleshootingToolsDeviceConnectivityApiGetDeviceConfigurationRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetDeviceConfigurationExecute(r)
}

/*
GetDeviceConfiguration Method for GetDeviceConfiguration

Debug device bring up

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TroubleshootingToolsDeviceConnectivityApiGetDeviceConfigurationRequest
*/
func (a *TroubleshootingToolsDeviceConnectivityApiService) GetDeviceConfiguration(ctx context.Context) TroubleshootingToolsDeviceConnectivityApiGetDeviceConfigurationRequest {
	return TroubleshootingToolsDeviceConnectivityApiGetDeviceConfigurationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *TroubleshootingToolsDeviceConnectivityApiService) GetDeviceConfigurationExecute(r TroubleshootingToolsDeviceConnectivityApiGetDeviceConfigurationRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TroubleshootingToolsDeviceConnectivityApiService.GetDeviceConfiguration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/troubleshooting/devicebringup"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.uuid == nil {
		return localVarReturnValue, nil, reportError("uuid is required and must be specified")
	}

	localVarQueryParams.Add("uuid", parameterToString(*r.uuid, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TroubleshootingToolsDeviceConnectivityApiGetInProgressCountRequest struct {
	ctx context.Context
	ApiService *TroubleshootingToolsDeviceConnectivityApiService
}

func (r TroubleshootingToolsDeviceConnectivityApiGetInProgressCountRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetInProgressCountExecute(r)
}

/*
GetInProgressCount Method for GetInProgressCount

Get device admin-tech InProgressCount

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TroubleshootingToolsDeviceConnectivityApiGetInProgressCountRequest
*/
func (a *TroubleshootingToolsDeviceConnectivityApiService) GetInProgressCount(ctx context.Context) TroubleshootingToolsDeviceConnectivityApiGetInProgressCountRequest {
	return TroubleshootingToolsDeviceConnectivityApiGetInProgressCountRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *TroubleshootingToolsDeviceConnectivityApiService) GetInProgressCountExecute(r TroubleshootingToolsDeviceConnectivityApiGetInProgressCountRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TroubleshootingToolsDeviceConnectivityApiService.GetInProgressCount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/tools/admintechs/inprogress"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TroubleshootingToolsDeviceConnectivityApiInvalidateDeviceRequest struct {
	ctx context.Context
	ApiService *TroubleshootingToolsDeviceConnectivityApiService
	body *map[string]interface{}
}

// vEdge device info
func (r TroubleshootingToolsDeviceConnectivityApiInvalidateDeviceRequest) Body(body map[string]interface{}) TroubleshootingToolsDeviceConnectivityApiInvalidateDeviceRequest {
	r.body = &body
	return r
}

func (r TroubleshootingToolsDeviceConnectivityApiInvalidateDeviceRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.InvalidateDeviceExecute(r)
}

/*
InvalidateDevice Method for InvalidateDevice

invalidate the device

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TroubleshootingToolsDeviceConnectivityApiInvalidateDeviceRequest
*/
func (a *TroubleshootingToolsDeviceConnectivityApiService) InvalidateDevice(ctx context.Context) TroubleshootingToolsDeviceConnectivityApiInvalidateDeviceRequest {
	return TroubleshootingToolsDeviceConnectivityApiInvalidateDeviceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *TroubleshootingToolsDeviceConnectivityApiService) InvalidateDeviceExecute(r TroubleshootingToolsDeviceConnectivityApiInvalidateDeviceRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TroubleshootingToolsDeviceConnectivityApiService.InvalidateDevice")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/certificate/device/invalidate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TroubleshootingToolsDeviceConnectivityApiListAdminTechsRequest struct {
	ctx context.Context
	ApiService *TroubleshootingToolsDeviceConnectivityApiService
}

func (r TroubleshootingToolsDeviceConnectivityApiListAdminTechsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ListAdminTechsExecute(r)
}

/*
ListAdminTechs Method for ListAdminTechs

Get device admin-tech information

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TroubleshootingToolsDeviceConnectivityApiListAdminTechsRequest
*/
func (a *TroubleshootingToolsDeviceConnectivityApiService) ListAdminTechs(ctx context.Context) TroubleshootingToolsDeviceConnectivityApiListAdminTechsRequest {
	return TroubleshootingToolsDeviceConnectivityApiListAdminTechsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *TroubleshootingToolsDeviceConnectivityApiService) ListAdminTechsExecute(r TroubleshootingToolsDeviceConnectivityApiListAdminTechsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TroubleshootingToolsDeviceConnectivityApiService.ListAdminTechs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/tools/admintechs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TroubleshootingToolsDeviceConnectivityApiListAdminTechsOnDeviceRequest struct {
	ctx context.Context
	ApiService *TroubleshootingToolsDeviceConnectivityApiService
	body *map[string]interface{}
}

// Admin tech listing request
func (r TroubleshootingToolsDeviceConnectivityApiListAdminTechsOnDeviceRequest) Body(body map[string]interface{}) TroubleshootingToolsDeviceConnectivityApiListAdminTechsOnDeviceRequest {
	r.body = &body
	return r
}

func (r TroubleshootingToolsDeviceConnectivityApiListAdminTechsOnDeviceRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ListAdminTechsOnDeviceExecute(r)
}

/*
ListAdminTechsOnDevice Method for ListAdminTechsOnDevice

List admin tech logs

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TroubleshootingToolsDeviceConnectivityApiListAdminTechsOnDeviceRequest
*/
func (a *TroubleshootingToolsDeviceConnectivityApiService) ListAdminTechsOnDevice(ctx context.Context) TroubleshootingToolsDeviceConnectivityApiListAdminTechsOnDeviceRequest {
	return TroubleshootingToolsDeviceConnectivityApiListAdminTechsOnDeviceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *TroubleshootingToolsDeviceConnectivityApiService) ListAdminTechsOnDeviceExecute(r TroubleshootingToolsDeviceConnectivityApiListAdminTechsOnDeviceRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TroubleshootingToolsDeviceConnectivityApiService.ListAdminTechsOnDevice")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/tools/admintechlist"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TroubleshootingToolsDeviceConnectivityApiNpingDeviceRequest struct {
	ctx context.Context
	ApiService *TroubleshootingToolsDeviceConnectivityApiService
	deviceIP string
	body *map[string]interface{}
}

// NPing parameter
func (r TroubleshootingToolsDeviceConnectivityApiNpingDeviceRequest) Body(body map[string]interface{}) TroubleshootingToolsDeviceConnectivityApiNpingDeviceRequest {
	r.body = &body
	return r
}

func (r TroubleshootingToolsDeviceConnectivityApiNpingDeviceRequest) Execute() (*http.Response, error) {
	return r.ApiService.NpingDeviceExecute(r)
}

/*
NpingDevice Method for NpingDevice

NPing device

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceIP Device IP
 @return TroubleshootingToolsDeviceConnectivityApiNpingDeviceRequest
*/
func (a *TroubleshootingToolsDeviceConnectivityApiService) NpingDevice(ctx context.Context, deviceIP string) TroubleshootingToolsDeviceConnectivityApiNpingDeviceRequest {
	return TroubleshootingToolsDeviceConnectivityApiNpingDeviceRequest{
		ApiService: a,
		ctx: ctx,
		deviceIP: deviceIP,
	}
}

// Execute executes the request
func (a *TroubleshootingToolsDeviceConnectivityApiService) NpingDeviceExecute(r TroubleshootingToolsDeviceConnectivityApiNpingDeviceRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TroubleshootingToolsDeviceConnectivityApiService.NpingDevice")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/tools/nping/{deviceIP}"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceIP"+"}", url.PathEscape(parameterToString(r.deviceIP, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type TroubleshootingToolsDeviceConnectivityApiPingDeviceRequest struct {
	ctx context.Context
	ApiService *TroubleshootingToolsDeviceConnectivityApiService
	deviceIP string
	body *map[string]interface{}
}

// Ping parameter
func (r TroubleshootingToolsDeviceConnectivityApiPingDeviceRequest) Body(body map[string]interface{}) TroubleshootingToolsDeviceConnectivityApiPingDeviceRequest {
	r.body = &body
	return r
}

func (r TroubleshootingToolsDeviceConnectivityApiPingDeviceRequest) Execute() (*http.Response, error) {
	return r.ApiService.PingDeviceExecute(r)
}

/*
PingDevice Method for PingDevice

Ping device

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceIP Device IP
 @return TroubleshootingToolsDeviceConnectivityApiPingDeviceRequest
*/
func (a *TroubleshootingToolsDeviceConnectivityApiService) PingDevice(ctx context.Context, deviceIP string) TroubleshootingToolsDeviceConnectivityApiPingDeviceRequest {
	return TroubleshootingToolsDeviceConnectivityApiPingDeviceRequest{
		ApiService: a,
		ctx: ctx,
		deviceIP: deviceIP,
	}
}

// Execute executes the request
func (a *TroubleshootingToolsDeviceConnectivityApiService) PingDeviceExecute(r TroubleshootingToolsDeviceConnectivityApiPingDeviceRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TroubleshootingToolsDeviceConnectivityApiService.PingDevice")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/tools/ping/{deviceIP}"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceIP"+"}", url.PathEscape(parameterToString(r.deviceIP, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type TroubleshootingToolsDeviceConnectivityApiProcessInterfaceResetRequest struct {
	ctx context.Context
	ApiService *TroubleshootingToolsDeviceConnectivityApiService
	deviceIP string
	body *map[string]interface{}
}

// Device interface
func (r TroubleshootingToolsDeviceConnectivityApiProcessInterfaceResetRequest) Body(body map[string]interface{}) TroubleshootingToolsDeviceConnectivityApiProcessInterfaceResetRequest {
	r.body = &body
	return r
}

func (r TroubleshootingToolsDeviceConnectivityApiProcessInterfaceResetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ProcessInterfaceResetExecute(r)
}

/*
ProcessInterfaceReset Method for ProcessInterfaceReset

Reset device interface

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceIP Device IP
 @return TroubleshootingToolsDeviceConnectivityApiProcessInterfaceResetRequest
*/
func (a *TroubleshootingToolsDeviceConnectivityApiService) ProcessInterfaceReset(ctx context.Context, deviceIP string) TroubleshootingToolsDeviceConnectivityApiProcessInterfaceResetRequest {
	return TroubleshootingToolsDeviceConnectivityApiProcessInterfaceResetRequest{
		ApiService: a,
		ctx: ctx,
		deviceIP: deviceIP,
	}
}

// Execute executes the request
func (a *TroubleshootingToolsDeviceConnectivityApiService) ProcessInterfaceResetExecute(r TroubleshootingToolsDeviceConnectivityApiProcessInterfaceResetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TroubleshootingToolsDeviceConnectivityApiService.ProcessInterfaceReset")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/tools/reset/interface/{deviceIP}"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceIP"+"}", url.PathEscape(parameterToString(r.deviceIP, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type TroubleshootingToolsDeviceConnectivityApiProcessPortHopColorRequest struct {
	ctx context.Context
	ApiService *TroubleshootingToolsDeviceConnectivityApiService
	deviceIP string
	body *map[string]interface{}
}

// Device port hop color
func (r TroubleshootingToolsDeviceConnectivityApiProcessPortHopColorRequest) Body(body map[string]interface{}) TroubleshootingToolsDeviceConnectivityApiProcessPortHopColorRequest {
	r.body = &body
	return r
}

func (r TroubleshootingToolsDeviceConnectivityApiProcessPortHopColorRequest) Execute() (*http.Response, error) {
	return r.ApiService.ProcessPortHopColorExecute(r)
}

/*
ProcessPortHopColor Method for ProcessPortHopColor

Request port hop color

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceIP Device IP
 @return TroubleshootingToolsDeviceConnectivityApiProcessPortHopColorRequest
*/
func (a *TroubleshootingToolsDeviceConnectivityApiService) ProcessPortHopColor(ctx context.Context, deviceIP string) TroubleshootingToolsDeviceConnectivityApiProcessPortHopColorRequest {
	return TroubleshootingToolsDeviceConnectivityApiProcessPortHopColorRequest{
		ApiService: a,
		ctx: ctx,
		deviceIP: deviceIP,
	}
}

// Execute executes the request
func (a *TroubleshootingToolsDeviceConnectivityApiService) ProcessPortHopColorExecute(r TroubleshootingToolsDeviceConnectivityApiProcessPortHopColorRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TroubleshootingToolsDeviceConnectivityApiService.ProcessPortHopColor")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/tools/porthopcolor/{deviceIP}"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceIP"+"}", url.PathEscape(parameterToString(r.deviceIP, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type TroubleshootingToolsDeviceConnectivityApiProcessResetUserRequest struct {
	ctx context.Context
	ApiService *TroubleshootingToolsDeviceConnectivityApiService
	deviceIP string
	body *map[string]interface{}
}

// Device user reset
func (r TroubleshootingToolsDeviceConnectivityApiProcessResetUserRequest) Body(body map[string]interface{}) TroubleshootingToolsDeviceConnectivityApiProcessResetUserRequest {
	r.body = &body
	return r
}

func (r TroubleshootingToolsDeviceConnectivityApiProcessResetUserRequest) Execute() (*http.Response, error) {
	return r.ApiService.ProcessResetUserExecute(r)
}

/*
ProcessResetUser Method for ProcessResetUser

Request reset user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceIP Device IP
 @return TroubleshootingToolsDeviceConnectivityApiProcessResetUserRequest
*/
func (a *TroubleshootingToolsDeviceConnectivityApiService) ProcessResetUser(ctx context.Context, deviceIP string) TroubleshootingToolsDeviceConnectivityApiProcessResetUserRequest {
	return TroubleshootingToolsDeviceConnectivityApiProcessResetUserRequest{
		ApiService: a,
		ctx: ctx,
		deviceIP: deviceIP,
	}
}

// Execute executes the request
func (a *TroubleshootingToolsDeviceConnectivityApiService) ProcessResetUserExecute(r TroubleshootingToolsDeviceConnectivityApiProcessResetUserRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TroubleshootingToolsDeviceConnectivityApiService.ProcessResetUser")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/tools/resetuser/{deviceIP}"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceIP"+"}", url.PathEscape(parameterToString(r.deviceIP, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type TroubleshootingToolsDeviceConnectivityApiServicePathRequest struct {
	ctx context.Context
	ApiService *TroubleshootingToolsDeviceConnectivityApiService
	deviceIP string
	body *map[string]interface{}
}

// Service path parameter
func (r TroubleshootingToolsDeviceConnectivityApiServicePathRequest) Body(body map[string]interface{}) TroubleshootingToolsDeviceConnectivityApiServicePathRequest {
	r.body = &body
	return r
}

func (r TroubleshootingToolsDeviceConnectivityApiServicePathRequest) Execute() (*http.Response, error) {
	return r.ApiService.ServicePathExecute(r)
}

/*
ServicePath Method for ServicePath

Service path

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceIP Device IP
 @return TroubleshootingToolsDeviceConnectivityApiServicePathRequest
*/
func (a *TroubleshootingToolsDeviceConnectivityApiService) ServicePath(ctx context.Context, deviceIP string) TroubleshootingToolsDeviceConnectivityApiServicePathRequest {
	return TroubleshootingToolsDeviceConnectivityApiServicePathRequest{
		ApiService: a,
		ctx: ctx,
		deviceIP: deviceIP,
	}
}

// Execute executes the request
func (a *TroubleshootingToolsDeviceConnectivityApiService) ServicePathExecute(r TroubleshootingToolsDeviceConnectivityApiServicePathRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TroubleshootingToolsDeviceConnectivityApiService.ServicePath")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/tools/servicepath/{deviceIP}"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceIP"+"}", url.PathEscape(parameterToString(r.deviceIP, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type TroubleshootingToolsDeviceConnectivityApiStageDeviceRequest struct {
	ctx context.Context
	ApiService *TroubleshootingToolsDeviceConnectivityApiService
	body *map[string]interface{}
}

// vEdge device info
func (r TroubleshootingToolsDeviceConnectivityApiStageDeviceRequest) Body(body map[string]interface{}) TroubleshootingToolsDeviceConnectivityApiStageDeviceRequest {
	r.body = &body
	return r
}

func (r TroubleshootingToolsDeviceConnectivityApiStageDeviceRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.StageDeviceExecute(r)
}

/*
StageDevice Method for StageDevice

Stop data traffic to device

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TroubleshootingToolsDeviceConnectivityApiStageDeviceRequest
*/
func (a *TroubleshootingToolsDeviceConnectivityApiService) StageDevice(ctx context.Context) TroubleshootingToolsDeviceConnectivityApiStageDeviceRequest {
	return TroubleshootingToolsDeviceConnectivityApiStageDeviceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *TroubleshootingToolsDeviceConnectivityApiService) StageDeviceExecute(r TroubleshootingToolsDeviceConnectivityApiStageDeviceRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TroubleshootingToolsDeviceConnectivityApiService.StageDevice")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/certificate/device/stage"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TroubleshootingToolsDeviceConnectivityApiTracerouteDeviceRequest struct {
	ctx context.Context
	ApiService *TroubleshootingToolsDeviceConnectivityApiService
	deviceIP string
	body *map[string]interface{}
}

// Traceroute parameter
func (r TroubleshootingToolsDeviceConnectivityApiTracerouteDeviceRequest) Body(body map[string]interface{}) TroubleshootingToolsDeviceConnectivityApiTracerouteDeviceRequest {
	r.body = &body
	return r
}

func (r TroubleshootingToolsDeviceConnectivityApiTracerouteDeviceRequest) Execute() (*http.Response, error) {
	return r.ApiService.TracerouteDeviceExecute(r)
}

/*
TracerouteDevice Method for TracerouteDevice

Traceroute

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceIP Device IP
 @return TroubleshootingToolsDeviceConnectivityApiTracerouteDeviceRequest
*/
func (a *TroubleshootingToolsDeviceConnectivityApiService) TracerouteDevice(ctx context.Context, deviceIP string) TroubleshootingToolsDeviceConnectivityApiTracerouteDeviceRequest {
	return TroubleshootingToolsDeviceConnectivityApiTracerouteDeviceRequest{
		ApiService: a,
		ctx: ctx,
		deviceIP: deviceIP,
	}
}

// Execute executes the request
func (a *TroubleshootingToolsDeviceConnectivityApiService) TracerouteDeviceExecute(r TroubleshootingToolsDeviceConnectivityApiTracerouteDeviceRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TroubleshootingToolsDeviceConnectivityApiService.TracerouteDevice")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/tools/traceroute/{deviceIP}"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceIP"+"}", url.PathEscape(parameterToString(r.deviceIP, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type TroubleshootingToolsDeviceConnectivityApiTunnelPathRequest struct {
	ctx context.Context
	ApiService *TroubleshootingToolsDeviceConnectivityApiService
	deviceIP string
	body *map[string]interface{}
}

// TunnelPath parameter
func (r TroubleshootingToolsDeviceConnectivityApiTunnelPathRequest) Body(body map[string]interface{}) TroubleshootingToolsDeviceConnectivityApiTunnelPathRequest {
	r.body = &body
	return r
}

func (r TroubleshootingToolsDeviceConnectivityApiTunnelPathRequest) Execute() (*http.Response, error) {
	return r.ApiService.TunnelPathExecute(r)
}

/*
TunnelPath Method for TunnelPath

TunnelPath

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceIP Device IP
 @return TroubleshootingToolsDeviceConnectivityApiTunnelPathRequest
*/
func (a *TroubleshootingToolsDeviceConnectivityApiService) TunnelPath(ctx context.Context, deviceIP string) TroubleshootingToolsDeviceConnectivityApiTunnelPathRequest {
	return TroubleshootingToolsDeviceConnectivityApiTunnelPathRequest{
		ApiService: a,
		ctx: ctx,
		deviceIP: deviceIP,
	}
}

// Execute executes the request
func (a *TroubleshootingToolsDeviceConnectivityApiService) TunnelPathExecute(r TroubleshootingToolsDeviceConnectivityApiTunnelPathRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TroubleshootingToolsDeviceConnectivityApiService.TunnelPath")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/tools/tunnelpath/{deviceIP}"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceIP"+"}", url.PathEscape(parameterToString(r.deviceIP, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type TroubleshootingToolsDeviceConnectivityApiUploadAdminTechRequest struct {
	ctx context.Context
	ApiService *TroubleshootingToolsDeviceConnectivityApiService
	body *map[string]interface{}
}

// Admin tech upload request
func (r TroubleshootingToolsDeviceConnectivityApiUploadAdminTechRequest) Body(body map[string]interface{}) TroubleshootingToolsDeviceConnectivityApiUploadAdminTechRequest {
	r.body = &body
	return r
}

func (r TroubleshootingToolsDeviceConnectivityApiUploadAdminTechRequest) Execute() (*http.Response, error) {
	return r.ApiService.UploadAdminTechExecute(r)
}

/*
UploadAdminTech Method for UploadAdminTech

upload admin tech to SR

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TroubleshootingToolsDeviceConnectivityApiUploadAdminTechRequest
*/
func (a *TroubleshootingToolsDeviceConnectivityApiService) UploadAdminTech(ctx context.Context) TroubleshootingToolsDeviceConnectivityApiUploadAdminTechRequest {
	return TroubleshootingToolsDeviceConnectivityApiUploadAdminTechRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *TroubleshootingToolsDeviceConnectivityApiService) UploadAdminTechExecute(r TroubleshootingToolsDeviceConnectivityApiUploadAdminTechRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TroubleshootingToolsDeviceConnectivityApiService.UploadAdminTech")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/tools/admintechs/upload"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
