/*
Cisco SD-WAN vManage API

The vManage API exposes the functionality of operations maintaining devices and the overlay network

API version: 2.0.0
Contact: vmanage@cisco.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// MonitoringAlarmsDetailsApiService MonitoringAlarmsDetailsApi service
type MonitoringAlarmsDetailsApiService service

type MonitoringAlarmsDetailsApiClearStaleAlarmRequest struct {
	ctx context.Context
	ApiService *MonitoringAlarmsDetailsApiService
	requestBody *[]map[string]interface{}
}

// alarm_uuid
func (r MonitoringAlarmsDetailsApiClearStaleAlarmRequest) RequestBody(requestBody []map[string]interface{}) MonitoringAlarmsDetailsApiClearStaleAlarmRequest {
	r.requestBody = &requestBody
	return r
}

func (r MonitoringAlarmsDetailsApiClearStaleAlarmRequest) Execute() (*http.Response, error) {
	return r.ApiService.ClearStaleAlarmExecute(r)
}

/*
ClearStaleAlarm Method for ClearStaleAlarm

Clears specific stale alarm

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MonitoringAlarmsDetailsApiClearStaleAlarmRequest
*/
func (a *MonitoringAlarmsDetailsApiService) ClearStaleAlarm(ctx context.Context) MonitoringAlarmsDetailsApiClearStaleAlarmRequest {
	return MonitoringAlarmsDetailsApiClearStaleAlarmRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *MonitoringAlarmsDetailsApiService) ClearStaleAlarmExecute(r MonitoringAlarmsDetailsApiClearStaleAlarmRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitoringAlarmsDetailsApiService.ClearStaleAlarm")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/alarms/clear"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type MonitoringAlarmsDetailsApiCorrelAntiEntropyRequest struct {
	ctx context.Context
	ApiService *MonitoringAlarmsDetailsApiService
}

func (r MonitoringAlarmsDetailsApiCorrelAntiEntropyRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.CorrelAntiEntropyExecute(r)
}

/*
CorrelAntiEntropy Method for CorrelAntiEntropy

Reset correlation engine data

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MonitoringAlarmsDetailsApiCorrelAntiEntropyRequest
*/
func (a *MonitoringAlarmsDetailsApiService) CorrelAntiEntropy(ctx context.Context) MonitoringAlarmsDetailsApiCorrelAntiEntropyRequest {
	return MonitoringAlarmsDetailsApiCorrelAntiEntropyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *MonitoringAlarmsDetailsApiService) CorrelAntiEntropyExecute(r MonitoringAlarmsDetailsApiCorrelAntiEntropyRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitoringAlarmsDetailsApiService.CorrelAntiEntropy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/alarms/reset"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MonitoringAlarmsDetailsApiCreateAlarmQueryConfigRequest struct {
	ctx context.Context
	ApiService *MonitoringAlarmsDetailsApiService
}

func (r MonitoringAlarmsDetailsApiCreateAlarmQueryConfigRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.CreateAlarmQueryConfigExecute(r)
}

/*
CreateAlarmQueryConfig Method for CreateAlarmQueryConfig

Get query configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MonitoringAlarmsDetailsApiCreateAlarmQueryConfigRequest
*/
func (a *MonitoringAlarmsDetailsApiService) CreateAlarmQueryConfig(ctx context.Context) MonitoringAlarmsDetailsApiCreateAlarmQueryConfigRequest {
	return MonitoringAlarmsDetailsApiCreateAlarmQueryConfigRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *MonitoringAlarmsDetailsApiService) CreateAlarmQueryConfigExecute(r MonitoringAlarmsDetailsApiCreateAlarmQueryConfigRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitoringAlarmsDetailsApiService.CreateAlarmQueryConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/alarms/query/input"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MonitoringAlarmsDetailsApiCreateNotificationRuleRequest struct {
	ctx context.Context
	ApiService *MonitoringAlarmsDetailsApiService
	body *map[string]interface{}
}

// Notification rule
func (r MonitoringAlarmsDetailsApiCreateNotificationRuleRequest) Body(body map[string]interface{}) MonitoringAlarmsDetailsApiCreateNotificationRuleRequest {
	r.body = &body
	return r
}

func (r MonitoringAlarmsDetailsApiCreateNotificationRuleRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.CreateNotificationRuleExecute(r)
}

/*
CreateNotificationRule Method for CreateNotificationRule

Add notification rule

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MonitoringAlarmsDetailsApiCreateNotificationRuleRequest
*/
func (a *MonitoringAlarmsDetailsApiService) CreateNotificationRule(ctx context.Context) MonitoringAlarmsDetailsApiCreateNotificationRuleRequest {
	return MonitoringAlarmsDetailsApiCreateNotificationRuleRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *MonitoringAlarmsDetailsApiService) CreateNotificationRuleExecute(r MonitoringAlarmsDetailsApiCreateNotificationRuleRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitoringAlarmsDetailsApiService.CreateNotificationRule")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/rule"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MonitoringAlarmsDetailsApiDeleteNotificationRuleRequest struct {
	ctx context.Context
	ApiService *MonitoringAlarmsDetailsApiService
	ruleId *string
}

// Rule Id
func (r MonitoringAlarmsDetailsApiDeleteNotificationRuleRequest) RuleId(ruleId string) MonitoringAlarmsDetailsApiDeleteNotificationRuleRequest {
	r.ruleId = &ruleId
	return r
}

func (r MonitoringAlarmsDetailsApiDeleteNotificationRuleRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteNotificationRuleExecute(r)
}

/*
DeleteNotificationRule Method for DeleteNotificationRule

Delete notification rule

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MonitoringAlarmsDetailsApiDeleteNotificationRuleRequest
*/
func (a *MonitoringAlarmsDetailsApiService) DeleteNotificationRule(ctx context.Context) MonitoringAlarmsDetailsApiDeleteNotificationRuleRequest {
	return MonitoringAlarmsDetailsApiDeleteNotificationRuleRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *MonitoringAlarmsDetailsApiService) DeleteNotificationRuleExecute(r MonitoringAlarmsDetailsApiDeleteNotificationRuleRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitoringAlarmsDetailsApiService.DeleteNotificationRule")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/rules"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ruleId == nil {
		return nil, reportError("ruleId is required and must be specified")
	}

	localVarQueryParams.Add("ruleId", parameterToString(*r.ruleId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type MonitoringAlarmsDetailsApiDisableEnableAlarmRequest struct {
	ctx context.Context
	ApiService *MonitoringAlarmsDetailsApiService
	eventName *string
	disable *bool
	time *int64
	body *map[string]interface{}
}

// Event name
func (r MonitoringAlarmsDetailsApiDisableEnableAlarmRequest) EventName(eventName string) MonitoringAlarmsDetailsApiDisableEnableAlarmRequest {
	r.eventName = &eventName
	return r
}

// Disable
func (r MonitoringAlarmsDetailsApiDisableEnableAlarmRequest) Disable(disable bool) MonitoringAlarmsDetailsApiDisableEnableAlarmRequest {
	r.disable = &disable
	return r
}

// time in hours [1, 72], -1 means infinite
func (r MonitoringAlarmsDetailsApiDisableEnableAlarmRequest) Time(time int64) MonitoringAlarmsDetailsApiDisableEnableAlarmRequest {
	r.time = &time
	return r
}

// alarm config
func (r MonitoringAlarmsDetailsApiDisableEnableAlarmRequest) Body(body map[string]interface{}) MonitoringAlarmsDetailsApiDisableEnableAlarmRequest {
	r.body = &body
	return r
}

func (r MonitoringAlarmsDetailsApiDisableEnableAlarmRequest) Execute() (*http.Response, error) {
	return r.ApiService.DisableEnableAlarmExecute(r)
}

/*
DisableEnableAlarm Method for DisableEnableAlarm

Enable/Disable a specific alarm

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MonitoringAlarmsDetailsApiDisableEnableAlarmRequest
*/
func (a *MonitoringAlarmsDetailsApiService) DisableEnableAlarm(ctx context.Context) MonitoringAlarmsDetailsApiDisableEnableAlarmRequest {
	return MonitoringAlarmsDetailsApiDisableEnableAlarmRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *MonitoringAlarmsDetailsApiService) DisableEnableAlarmExecute(r MonitoringAlarmsDetailsApiDisableEnableAlarmRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitoringAlarmsDetailsApiService.DisableEnableAlarm")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/alarms/disabled"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.eventName == nil {
		return nil, reportError("eventName is required and must be specified")
	}
	if r.disable == nil {
		return nil, reportError("disable is required and must be specified")
	}
	if r.time == nil {
		return nil, reportError("time is required and must be specified")
	}

	localVarQueryParams.Add("eventName", parameterToString(*r.eventName, ""))
	localVarQueryParams.Add("disable", parameterToString(*r.disable, ""))
	localVarQueryParams.Add("time", parameterToString(*r.time, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type MonitoringAlarmsDetailsApiDumpCorrelationEngineDataRequest struct {
	ctx context.Context
	ApiService *MonitoringAlarmsDetailsApiService
}

func (r MonitoringAlarmsDetailsApiDumpCorrelationEngineDataRequest) Execute() (*http.Response, error) {
	return r.ApiService.DumpCorrelationEngineDataExecute(r)
}

/*
DumpCorrelationEngineData Method for DumpCorrelationEngineData

dump correlation engine server data

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MonitoringAlarmsDetailsApiDumpCorrelationEngineDataRequest
*/
func (a *MonitoringAlarmsDetailsApiService) DumpCorrelationEngineData(ctx context.Context) MonitoringAlarmsDetailsApiDumpCorrelationEngineDataRequest {
	return MonitoringAlarmsDetailsApiDumpCorrelationEngineDataRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *MonitoringAlarmsDetailsApiService) DumpCorrelationEngineDataExecute(r MonitoringAlarmsDetailsApiDumpCorrelationEngineDataRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitoringAlarmsDetailsApiService.DumpCorrelationEngineData")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/alarms/dump"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type MonitoringAlarmsDetailsApiEnableDisableLinkStateAlarmRequest struct {
	ctx context.Context
	ApiService *MonitoringAlarmsDetailsApiService
	linkName *string
	enable *bool
	body *map[string]interface{}
}

// Link name (bgp, ospf)
func (r MonitoringAlarmsDetailsApiEnableDisableLinkStateAlarmRequest) LinkName(linkName string) MonitoringAlarmsDetailsApiEnableDisableLinkStateAlarmRequest {
	r.linkName = &linkName
	return r
}

// Enable
func (r MonitoringAlarmsDetailsApiEnableDisableLinkStateAlarmRequest) Enable(enable bool) MonitoringAlarmsDetailsApiEnableDisableLinkStateAlarmRequest {
	r.enable = &enable
	return r
}

// alarm config
func (r MonitoringAlarmsDetailsApiEnableDisableLinkStateAlarmRequest) Body(body map[string]interface{}) MonitoringAlarmsDetailsApiEnableDisableLinkStateAlarmRequest {
	r.body = &body
	return r
}

func (r MonitoringAlarmsDetailsApiEnableDisableLinkStateAlarmRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnableDisableLinkStateAlarmExecute(r)
}

/*
EnableDisableLinkStateAlarm Method for EnableDisableLinkStateAlarm

Enable/Disable a specific link-state alarm

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MonitoringAlarmsDetailsApiEnableDisableLinkStateAlarmRequest
*/
func (a *MonitoringAlarmsDetailsApiService) EnableDisableLinkStateAlarm(ctx context.Context) MonitoringAlarmsDetailsApiEnableDisableLinkStateAlarmRequest {
	return MonitoringAlarmsDetailsApiEnableDisableLinkStateAlarmRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *MonitoringAlarmsDetailsApiService) EnableDisableLinkStateAlarmExecute(r MonitoringAlarmsDetailsApiEnableDisableLinkStateAlarmRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitoringAlarmsDetailsApiService.EnableDisableLinkStateAlarm")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/alarms/link-state-alarm"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.linkName == nil {
		return nil, reportError("linkName is required and must be specified")
	}
	if r.enable == nil {
		return nil, reportError("enable is required and must be specified")
	}

	localVarQueryParams.Add("linkName", parameterToString(*r.linkName, ""))
	localVarQueryParams.Add("enable", parameterToString(*r.enable, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type MonitoringAlarmsDetailsApiGetAlarmAggregationDataRequest struct {
	ctx context.Context
	ApiService *MonitoringAlarmsDetailsApiService
	query *string
}

// Alarm query string
func (r MonitoringAlarmsDetailsApiGetAlarmAggregationDataRequest) Query(query string) MonitoringAlarmsDetailsApiGetAlarmAggregationDataRequest {
	r.query = &query
	return r
}

func (r MonitoringAlarmsDetailsApiGetAlarmAggregationDataRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetAlarmAggregationDataExecute(r)
}

/*
GetAlarmAggregationData Method for GetAlarmAggregationData

Gets aggregated list of alarms along with the raw alarm data of each aggregation

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MonitoringAlarmsDetailsApiGetAlarmAggregationDataRequest
*/
func (a *MonitoringAlarmsDetailsApiService) GetAlarmAggregationData(ctx context.Context) MonitoringAlarmsDetailsApiGetAlarmAggregationDataRequest {
	return MonitoringAlarmsDetailsApiGetAlarmAggregationDataRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *MonitoringAlarmsDetailsApiService) GetAlarmAggregationDataExecute(r MonitoringAlarmsDetailsApiGetAlarmAggregationDataRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitoringAlarmsDetailsApiService.GetAlarmAggregationData")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/alarms/aggregation"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.query != nil {
		localVarQueryParams.Add("query", parameterToString(*r.query, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MonitoringAlarmsDetailsApiGetAlarmDetailsRequest struct {
	ctx context.Context
	ApiService *MonitoringAlarmsDetailsApiService
	alarmUuid string
}

func (r MonitoringAlarmsDetailsApiGetAlarmDetailsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetAlarmDetailsExecute(r)
}

/*
GetAlarmDetails Method for GetAlarmDetails

Get alarm detail

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param alarmUuid Alarm Id
 @return MonitoringAlarmsDetailsApiGetAlarmDetailsRequest
*/
func (a *MonitoringAlarmsDetailsApiService) GetAlarmDetails(ctx context.Context, alarmUuid string) MonitoringAlarmsDetailsApiGetAlarmDetailsRequest {
	return MonitoringAlarmsDetailsApiGetAlarmDetailsRequest{
		ApiService: a,
		ctx: ctx,
		alarmUuid: alarmUuid,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *MonitoringAlarmsDetailsApiService) GetAlarmDetailsExecute(r MonitoringAlarmsDetailsApiGetAlarmDetailsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitoringAlarmsDetailsApiService.GetAlarmDetails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/alarms/uuid/{alarm_uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"alarm_uuid"+"}", url.PathEscape(parameterToString(r.alarmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MonitoringAlarmsDetailsApiGetAlarmSeverityCustomHistogramRequest struct {
	ctx context.Context
	ApiService *MonitoringAlarmsDetailsApiService
	query *string
}

// Alarm histogram query string
func (r MonitoringAlarmsDetailsApiGetAlarmSeverityCustomHistogramRequest) Query(query string) MonitoringAlarmsDetailsApiGetAlarmSeverityCustomHistogramRequest {
	r.query = &query
	return r
}

func (r MonitoringAlarmsDetailsApiGetAlarmSeverityCustomHistogramRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetAlarmSeverityCustomHistogramExecute(r)
}

/*
GetAlarmSeverityCustomHistogram Method for GetAlarmSeverityCustomHistogram

Get alarm severity histogram

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MonitoringAlarmsDetailsApiGetAlarmSeverityCustomHistogramRequest
*/
func (a *MonitoringAlarmsDetailsApiService) GetAlarmSeverityCustomHistogram(ctx context.Context) MonitoringAlarmsDetailsApiGetAlarmSeverityCustomHistogramRequest {
	return MonitoringAlarmsDetailsApiGetAlarmSeverityCustomHistogramRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *MonitoringAlarmsDetailsApiService) GetAlarmSeverityCustomHistogramExecute(r MonitoringAlarmsDetailsApiGetAlarmSeverityCustomHistogramRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitoringAlarmsDetailsApiService.GetAlarmSeverityCustomHistogram")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/alarms/severity/summary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.query == nil {
		return localVarReturnValue, nil, reportError("query is required and must be specified")
	}

	localVarQueryParams.Add("query", parameterToString(*r.query, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MonitoringAlarmsDetailsApiGetAlarmSeverityMappingsRequest struct {
	ctx context.Context
	ApiService *MonitoringAlarmsDetailsApiService
}

func (r MonitoringAlarmsDetailsApiGetAlarmSeverityMappingsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetAlarmSeverityMappingsExecute(r)
}

/*
GetAlarmSeverityMappings Method for GetAlarmSeverityMappings

Gets alarm severity mappings

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MonitoringAlarmsDetailsApiGetAlarmSeverityMappingsRequest
*/
func (a *MonitoringAlarmsDetailsApiService) GetAlarmSeverityMappings(ctx context.Context) MonitoringAlarmsDetailsApiGetAlarmSeverityMappingsRequest {
	return MonitoringAlarmsDetailsApiGetAlarmSeverityMappingsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *MonitoringAlarmsDetailsApiService) GetAlarmSeverityMappingsExecute(r MonitoringAlarmsDetailsApiGetAlarmSeverityMappingsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitoringAlarmsDetailsApiService.GetAlarmSeverityMappings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/alarms/severitymappings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MonitoringAlarmsDetailsApiGetAlarmTypesAsKeyValueRequest struct {
	ctx context.Context
	ApiService *MonitoringAlarmsDetailsApiService
}

func (r MonitoringAlarmsDetailsApiGetAlarmTypesAsKeyValueRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetAlarmTypesAsKeyValueExecute(r)
}

/*
GetAlarmTypesAsKeyValue Method for GetAlarmTypesAsKeyValue

Gets alarm type as key value pair

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MonitoringAlarmsDetailsApiGetAlarmTypesAsKeyValueRequest
*/
func (a *MonitoringAlarmsDetailsApiService) GetAlarmTypesAsKeyValue(ctx context.Context) MonitoringAlarmsDetailsApiGetAlarmTypesAsKeyValueRequest {
	return MonitoringAlarmsDetailsApiGetAlarmTypesAsKeyValueRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *MonitoringAlarmsDetailsApiService) GetAlarmTypesAsKeyValueExecute(r MonitoringAlarmsDetailsApiGetAlarmTypesAsKeyValueRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitoringAlarmsDetailsApiService.GetAlarmTypesAsKeyValue")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/alarms/rulenamedisplay/keyvalue"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MonitoringAlarmsDetailsApiGetAlarmsRequest struct {
	ctx context.Context
	ApiService *MonitoringAlarmsDetailsApiService
	query *string
}

// Alarm query string
func (r MonitoringAlarmsDetailsApiGetAlarmsRequest) Query(query string) MonitoringAlarmsDetailsApiGetAlarmsRequest {
	r.query = &query
	return r
}

func (r MonitoringAlarmsDetailsApiGetAlarmsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetAlarmsExecute(r)
}

/*
GetAlarms Method for GetAlarms

Get alarms for last 30min if vManage query is not specified

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MonitoringAlarmsDetailsApiGetAlarmsRequest
*/
func (a *MonitoringAlarmsDetailsApiService) GetAlarms(ctx context.Context) MonitoringAlarmsDetailsApiGetAlarmsRequest {
	return MonitoringAlarmsDetailsApiGetAlarmsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *MonitoringAlarmsDetailsApiService) GetAlarmsExecute(r MonitoringAlarmsDetailsApiGetAlarmsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitoringAlarmsDetailsApiService.GetAlarms")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/alarms"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.query != nil {
		localVarQueryParams.Add("query", parameterToString(*r.query, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MonitoringAlarmsDetailsApiGetAlarmsBySeverityRequest struct {
	ctx context.Context
	ApiService *MonitoringAlarmsDetailsApiService
	severityLevel *[]string
	deviceId *[]string
	query *string
}

// Alarm severity
func (r MonitoringAlarmsDetailsApiGetAlarmsBySeverityRequest) SeverityLevel(severityLevel []string) MonitoringAlarmsDetailsApiGetAlarmsBySeverityRequest {
	r.severityLevel = &severityLevel
	return r
}

// Device Id
func (r MonitoringAlarmsDetailsApiGetAlarmsBySeverityRequest) DeviceId(deviceId []string) MonitoringAlarmsDetailsApiGetAlarmsBySeverityRequest {
	r.deviceId = &deviceId
	return r
}

// Query filter
func (r MonitoringAlarmsDetailsApiGetAlarmsBySeverityRequest) Query(query string) MonitoringAlarmsDetailsApiGetAlarmsBySeverityRequest {
	r.query = &query
	return r
}

func (r MonitoringAlarmsDetailsApiGetAlarmsBySeverityRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetAlarmsBySeverityExecute(r)
}

/*
GetAlarmsBySeverity Method for GetAlarmsBySeverity

Get alarm by severity

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MonitoringAlarmsDetailsApiGetAlarmsBySeverityRequest
*/
func (a *MonitoringAlarmsDetailsApiService) GetAlarmsBySeverity(ctx context.Context) MonitoringAlarmsDetailsApiGetAlarmsBySeverityRequest {
	return MonitoringAlarmsDetailsApiGetAlarmsBySeverityRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *MonitoringAlarmsDetailsApiService) GetAlarmsBySeverityExecute(r MonitoringAlarmsDetailsApiGetAlarmsBySeverityRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitoringAlarmsDetailsApiService.GetAlarmsBySeverity")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/alarms/severity"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.severityLevel == nil {
		return localVarReturnValue, nil, reportError("severityLevel is required and must be specified")
	}
	if r.deviceId == nil {
		return localVarReturnValue, nil, reportError("deviceId is required and must be specified")
	}
	if r.query == nil {
		return localVarReturnValue, nil, reportError("query is required and must be specified")
	}

	{
		t := *r.severityLevel
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("severity-level", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("severity-level", parameterToString(t, "multi"))
		}
	}
	{
		t := *r.deviceId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("deviceId", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("deviceId", parameterToString(t, "multi"))
		}
	}
	localVarQueryParams.Add("query", parameterToString(*r.query, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MonitoringAlarmsDetailsApiGetCount1Request struct {
	ctx context.Context
	ApiService *MonitoringAlarmsDetailsApiService
	query *string
}

// Query
func (r MonitoringAlarmsDetailsApiGetCount1Request) Query(query string) MonitoringAlarmsDetailsApiGetCount1Request {
	r.query = &query
	return r
}

func (r MonitoringAlarmsDetailsApiGetCount1Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetCount1Execute(r)
}

/*
GetCount1 Method for GetCount1

Get response count of a query

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MonitoringAlarmsDetailsApiGetCount1Request
*/
func (a *MonitoringAlarmsDetailsApiService) GetCount1(ctx context.Context) MonitoringAlarmsDetailsApiGetCount1Request {
	return MonitoringAlarmsDetailsApiGetCount1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *MonitoringAlarmsDetailsApiService) GetCount1Execute(r MonitoringAlarmsDetailsApiGetCount1Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitoringAlarmsDetailsApiService.GetCount1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/alarms/doccount"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.query == nil {
		return localVarReturnValue, nil, reportError("query is required and must be specified")
	}

	localVarQueryParams.Add("query", parameterToString(*r.query, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MonitoringAlarmsDetailsApiGetCountPost1Request struct {
	ctx context.Context
	ApiService *MonitoringAlarmsDetailsApiService
	body *map[string]interface{}
}

// Query
func (r MonitoringAlarmsDetailsApiGetCountPost1Request) Body(body map[string]interface{}) MonitoringAlarmsDetailsApiGetCountPost1Request {
	r.body = &body
	return r
}

func (r MonitoringAlarmsDetailsApiGetCountPost1Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetCountPost1Execute(r)
}

/*
GetCountPost1 Method for GetCountPost1

Get response count of a query

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MonitoringAlarmsDetailsApiGetCountPost1Request
*/
func (a *MonitoringAlarmsDetailsApiService) GetCountPost1(ctx context.Context) MonitoringAlarmsDetailsApiGetCountPost1Request {
	return MonitoringAlarmsDetailsApiGetCountPost1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *MonitoringAlarmsDetailsApiService) GetCountPost1Execute(r MonitoringAlarmsDetailsApiGetCountPost1Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitoringAlarmsDetailsApiService.GetCountPost1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/alarms/doccount"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MonitoringAlarmsDetailsApiGetDeviceTopicRequest struct {
	ctx context.Context
	ApiService *MonitoringAlarmsDetailsApiService
	ip *string
}

// Query topic
func (r MonitoringAlarmsDetailsApiGetDeviceTopicRequest) Ip(ip string) MonitoringAlarmsDetailsApiGetDeviceTopicRequest {
	r.ip = &ip
	return r
}

func (r MonitoringAlarmsDetailsApiGetDeviceTopicRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetDeviceTopicExecute(r)
}

/*
GetDeviceTopic Method for GetDeviceTopic

Get device topic state

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MonitoringAlarmsDetailsApiGetDeviceTopicRequest
*/
func (a *MonitoringAlarmsDetailsApiService) GetDeviceTopic(ctx context.Context) MonitoringAlarmsDetailsApiGetDeviceTopicRequest {
	return MonitoringAlarmsDetailsApiGetDeviceTopicRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *MonitoringAlarmsDetailsApiService) GetDeviceTopicExecute(r MonitoringAlarmsDetailsApiGetDeviceTopicRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitoringAlarmsDetailsApiService.GetDeviceTopic")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/alarms/topic"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ip == nil {
		return nil, reportError("ip is required and must be specified")
	}

	localVarQueryParams.Add("ip", parameterToString(*r.ip, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type MonitoringAlarmsDetailsApiGetLinkStateAlarmConfigRequest struct {
	ctx context.Context
	ApiService *MonitoringAlarmsDetailsApiService
}

func (r MonitoringAlarmsDetailsApiGetLinkStateAlarmConfigRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetLinkStateAlarmConfigExecute(r)
}

/*
GetLinkStateAlarmConfig Method for GetLinkStateAlarmConfig

Get configuration for link-state alarm

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MonitoringAlarmsDetailsApiGetLinkStateAlarmConfigRequest
*/
func (a *MonitoringAlarmsDetailsApiService) GetLinkStateAlarmConfig(ctx context.Context) MonitoringAlarmsDetailsApiGetLinkStateAlarmConfigRequest {
	return MonitoringAlarmsDetailsApiGetLinkStateAlarmConfigRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *MonitoringAlarmsDetailsApiService) GetLinkStateAlarmConfigExecute(r MonitoringAlarmsDetailsApiGetLinkStateAlarmConfigRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitoringAlarmsDetailsApiService.GetLinkStateAlarmConfig")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/alarms/link-state-alarm"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type MonitoringAlarmsDetailsApiGetMasterManagerStateRequest struct {
	ctx context.Context
	ApiService *MonitoringAlarmsDetailsApiService
}

func (r MonitoringAlarmsDetailsApiGetMasterManagerStateRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetMasterManagerStateExecute(r)
}

/*
GetMasterManagerState Method for GetMasterManagerState

Get master manager state

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MonitoringAlarmsDetailsApiGetMasterManagerStateRequest
*/
func (a *MonitoringAlarmsDetailsApiService) GetMasterManagerState(ctx context.Context) MonitoringAlarmsDetailsApiGetMasterManagerStateRequest {
	return MonitoringAlarmsDetailsApiGetMasterManagerStateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *MonitoringAlarmsDetailsApiService) GetMasterManagerStateExecute(r MonitoringAlarmsDetailsApiGetMasterManagerStateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitoringAlarmsDetailsApiService.GetMasterManagerState")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/alarms/master"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type MonitoringAlarmsDetailsApiGetNonViewedActiveAlarmsCountRequest struct {
	ctx context.Context
	ApiService *MonitoringAlarmsDetailsApiService
}

func (r MonitoringAlarmsDetailsApiGetNonViewedActiveAlarmsCountRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetNonViewedActiveAlarmsCountExecute(r)
}

/*
GetNonViewedActiveAlarmsCount Method for GetNonViewedActiveAlarmsCount

Get count of the alarms which are active and acknowledged by the user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MonitoringAlarmsDetailsApiGetNonViewedActiveAlarmsCountRequest
*/
func (a *MonitoringAlarmsDetailsApiService) GetNonViewedActiveAlarmsCount(ctx context.Context) MonitoringAlarmsDetailsApiGetNonViewedActiveAlarmsCountRequest {
	return MonitoringAlarmsDetailsApiGetNonViewedActiveAlarmsCountRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *MonitoringAlarmsDetailsApiService) GetNonViewedActiveAlarmsCountExecute(r MonitoringAlarmsDetailsApiGetNonViewedActiveAlarmsCountRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitoringAlarmsDetailsApiService.GetNonViewedActiveAlarmsCount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/alarms/count"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MonitoringAlarmsDetailsApiGetNonViewedAlarmsRequest struct {
	ctx context.Context
	ApiService *MonitoringAlarmsDetailsApiService
}

func (r MonitoringAlarmsDetailsApiGetNonViewedAlarmsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetNonViewedAlarmsExecute(r)
}

/*
GetNonViewedAlarms Method for GetNonViewedAlarms

Get alarms which are active and acknowledged by the user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MonitoringAlarmsDetailsApiGetNonViewedAlarmsRequest
*/
func (a *MonitoringAlarmsDetailsApiService) GetNonViewedAlarms(ctx context.Context) MonitoringAlarmsDetailsApiGetNonViewedAlarmsRequest {
	return MonitoringAlarmsDetailsApiGetNonViewedAlarmsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *MonitoringAlarmsDetailsApiService) GetNonViewedAlarmsExecute(r MonitoringAlarmsDetailsApiGetNonViewedAlarmsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitoringAlarmsDetailsApiService.GetNonViewedAlarms")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/alarms/notviewed"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MonitoringAlarmsDetailsApiGetNotificationRuleRequest struct {
	ctx context.Context
	ApiService *MonitoringAlarmsDetailsApiService
	ruleId *string
}

// Rule Id
func (r MonitoringAlarmsDetailsApiGetNotificationRuleRequest) RuleId(ruleId string) MonitoringAlarmsDetailsApiGetNotificationRuleRequest {
	r.ruleId = &ruleId
	return r
}

func (r MonitoringAlarmsDetailsApiGetNotificationRuleRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetNotificationRuleExecute(r)
}

/*
GetNotificationRule Method for GetNotificationRule

Get all rules or specific notification rule by its Id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MonitoringAlarmsDetailsApiGetNotificationRuleRequest
*/
func (a *MonitoringAlarmsDetailsApiService) GetNotificationRule(ctx context.Context) MonitoringAlarmsDetailsApiGetNotificationRuleRequest {
	return MonitoringAlarmsDetailsApiGetNotificationRuleRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *MonitoringAlarmsDetailsApiService) GetNotificationRuleExecute(r MonitoringAlarmsDetailsApiGetNotificationRuleRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitoringAlarmsDetailsApiService.GetNotificationRule")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/rules"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ruleId != nil {
		localVarQueryParams.Add("ruleId", parameterToString(*r.ruleId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MonitoringAlarmsDetailsApiGetPostAlarmAggregationDataRequest struct {
	ctx context.Context
	ApiService *MonitoringAlarmsDetailsApiService
	body *map[string]interface{}
}

// Input query
func (r MonitoringAlarmsDetailsApiGetPostAlarmAggregationDataRequest) Body(body map[string]interface{}) MonitoringAlarmsDetailsApiGetPostAlarmAggregationDataRequest {
	r.body = &body
	return r
}

func (r MonitoringAlarmsDetailsApiGetPostAlarmAggregationDataRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetPostAlarmAggregationDataExecute(r)
}

/*
GetPostAlarmAggregationData Method for GetPostAlarmAggregationData

Gets aggregated list of alarms along with the raw alarm data of each aggregation

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MonitoringAlarmsDetailsApiGetPostAlarmAggregationDataRequest
*/
func (a *MonitoringAlarmsDetailsApiService) GetPostAlarmAggregationData(ctx context.Context) MonitoringAlarmsDetailsApiGetPostAlarmAggregationDataRequest {
	return MonitoringAlarmsDetailsApiGetPostAlarmAggregationDataRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *MonitoringAlarmsDetailsApiService) GetPostAlarmAggregationDataExecute(r MonitoringAlarmsDetailsApiGetPostAlarmAggregationDataRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitoringAlarmsDetailsApiService.GetPostAlarmAggregationData")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/alarms/aggregation"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MonitoringAlarmsDetailsApiGetPostStatBulkAlarmRawDataRequest struct {
	ctx context.Context
	ApiService *MonitoringAlarmsDetailsApiService
	scrollId *string
	count *int64
	body *map[string]interface{}
}

// Query offset
func (r MonitoringAlarmsDetailsApiGetPostStatBulkAlarmRawDataRequest) ScrollId(scrollId string) MonitoringAlarmsDetailsApiGetPostStatBulkAlarmRawDataRequest {
	r.scrollId = &scrollId
	return r
}

// Query size
func (r MonitoringAlarmsDetailsApiGetPostStatBulkAlarmRawDataRequest) Count(count int64) MonitoringAlarmsDetailsApiGetPostStatBulkAlarmRawDataRequest {
	r.count = &count
	return r
}

// Alarm query string
func (r MonitoringAlarmsDetailsApiGetPostStatBulkAlarmRawDataRequest) Body(body map[string]interface{}) MonitoringAlarmsDetailsApiGetPostStatBulkAlarmRawDataRequest {
	r.body = &body
	return r
}

func (r MonitoringAlarmsDetailsApiGetPostStatBulkAlarmRawDataRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetPostStatBulkAlarmRawDataExecute(r)
}

/*
GetPostStatBulkAlarmRawData Method for GetPostStatBulkAlarmRawData

Get paginated alarm raw data

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MonitoringAlarmsDetailsApiGetPostStatBulkAlarmRawDataRequest
*/
func (a *MonitoringAlarmsDetailsApiService) GetPostStatBulkAlarmRawData(ctx context.Context) MonitoringAlarmsDetailsApiGetPostStatBulkAlarmRawDataRequest {
	return MonitoringAlarmsDetailsApiGetPostStatBulkAlarmRawDataRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *MonitoringAlarmsDetailsApiService) GetPostStatBulkAlarmRawDataExecute(r MonitoringAlarmsDetailsApiGetPostStatBulkAlarmRawDataRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitoringAlarmsDetailsApiService.GetPostStatBulkAlarmRawData")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/alarms/page"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.scrollId == nil {
		return localVarReturnValue, nil, reportError("scrollId is required and must be specified")
	}
	if r.count == nil {
		return localVarReturnValue, nil, reportError("count is required and must be specified")
	}

	localVarQueryParams.Add("scrollId", parameterToString(*r.scrollId, ""))
	localVarQueryParams.Add("count", parameterToString(*r.count, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MonitoringAlarmsDetailsApiGetRawAlarmDataRequest struct {
	ctx context.Context
	ApiService *MonitoringAlarmsDetailsApiService
	page *int64
	pageSize *int64
	sortBy *string
	sortOrder *string
	body *map[string]interface{}
}

// page number
func (r MonitoringAlarmsDetailsApiGetRawAlarmDataRequest) Page(page int64) MonitoringAlarmsDetailsApiGetRawAlarmDataRequest {
	r.page = &page
	return r
}

// page size
func (r MonitoringAlarmsDetailsApiGetRawAlarmDataRequest) PageSize(pageSize int64) MonitoringAlarmsDetailsApiGetRawAlarmDataRequest {
	r.pageSize = &pageSize
	return r
}

// sort by
func (r MonitoringAlarmsDetailsApiGetRawAlarmDataRequest) SortBy(sortBy string) MonitoringAlarmsDetailsApiGetRawAlarmDataRequest {
	r.sortBy = &sortBy
	return r
}

// sort order
func (r MonitoringAlarmsDetailsApiGetRawAlarmDataRequest) SortOrder(sortOrder string) MonitoringAlarmsDetailsApiGetRawAlarmDataRequest {
	r.sortOrder = &sortOrder
	return r
}

// Alarm query string
func (r MonitoringAlarmsDetailsApiGetRawAlarmDataRequest) Body(body map[string]interface{}) MonitoringAlarmsDetailsApiGetRawAlarmDataRequest {
	r.body = &body
	return r
}

func (r MonitoringAlarmsDetailsApiGetRawAlarmDataRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetRawAlarmDataExecute(r)
}

/*
GetRawAlarmData Method for GetRawAlarmData

Gets lists of alarms along with the raw alarm data of each.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MonitoringAlarmsDetailsApiGetRawAlarmDataRequest
*/
func (a *MonitoringAlarmsDetailsApiService) GetRawAlarmData(ctx context.Context) MonitoringAlarmsDetailsApiGetRawAlarmDataRequest {
	return MonitoringAlarmsDetailsApiGetRawAlarmDataRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *MonitoringAlarmsDetailsApiService) GetRawAlarmDataExecute(r MonitoringAlarmsDetailsApiGetRawAlarmDataRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitoringAlarmsDetailsApiService.GetRawAlarmData")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/alarms"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	if r.sortBy != nil {
		localVarQueryParams.Add("sortBy", parameterToString(*r.sortBy, ""))
	}
	if r.sortOrder != nil {
		localVarQueryParams.Add("sortOrder", parameterToString(*r.sortOrder, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MonitoringAlarmsDetailsApiGetStatBulkAlarmRawDataRequest struct {
	ctx context.Context
	ApiService *MonitoringAlarmsDetailsApiService
	query *string
	scrollId *string
	count *int64
}

// Alarm query string
func (r MonitoringAlarmsDetailsApiGetStatBulkAlarmRawDataRequest) Query(query string) MonitoringAlarmsDetailsApiGetStatBulkAlarmRawDataRequest {
	r.query = &query
	return r
}

// Query offset
func (r MonitoringAlarmsDetailsApiGetStatBulkAlarmRawDataRequest) ScrollId(scrollId string) MonitoringAlarmsDetailsApiGetStatBulkAlarmRawDataRequest {
	r.scrollId = &scrollId
	return r
}

// Query size
func (r MonitoringAlarmsDetailsApiGetStatBulkAlarmRawDataRequest) Count(count int64) MonitoringAlarmsDetailsApiGetStatBulkAlarmRawDataRequest {
	r.count = &count
	return r
}

func (r MonitoringAlarmsDetailsApiGetStatBulkAlarmRawDataRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetStatBulkAlarmRawDataExecute(r)
}

/*
GetStatBulkAlarmRawData Method for GetStatBulkAlarmRawData

Get paginated alarm raw data

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MonitoringAlarmsDetailsApiGetStatBulkAlarmRawDataRequest
*/
func (a *MonitoringAlarmsDetailsApiService) GetStatBulkAlarmRawData(ctx context.Context) MonitoringAlarmsDetailsApiGetStatBulkAlarmRawDataRequest {
	return MonitoringAlarmsDetailsApiGetStatBulkAlarmRawDataRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *MonitoringAlarmsDetailsApiService) GetStatBulkAlarmRawDataExecute(r MonitoringAlarmsDetailsApiGetStatBulkAlarmRawDataRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitoringAlarmsDetailsApiService.GetStatBulkAlarmRawData")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/alarms/page"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.query == nil {
		return localVarReturnValue, nil, reportError("query is required and must be specified")
	}
	if r.scrollId == nil {
		return localVarReturnValue, nil, reportError("scrollId is required and must be specified")
	}
	if r.count == nil {
		return localVarReturnValue, nil, reportError("count is required and must be specified")
	}

	localVarQueryParams.Add("query", parameterToString(*r.query, ""))
	localVarQueryParams.Add("scrollId", parameterToString(*r.scrollId, ""))
	localVarQueryParams.Add("count", parameterToString(*r.count, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MonitoringAlarmsDetailsApiGetStatDataFields1Request struct {
	ctx context.Context
	ApiService *MonitoringAlarmsDetailsApiService
}

func (r MonitoringAlarmsDetailsApiGetStatDataFields1Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetStatDataFields1Execute(r)
}

/*
GetStatDataFields1 Method for GetStatDataFields1

Get fields and type

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MonitoringAlarmsDetailsApiGetStatDataFields1Request
*/
func (a *MonitoringAlarmsDetailsApiService) GetStatDataFields1(ctx context.Context) MonitoringAlarmsDetailsApiGetStatDataFields1Request {
	return MonitoringAlarmsDetailsApiGetStatDataFields1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *MonitoringAlarmsDetailsApiService) GetStatDataFields1Execute(r MonitoringAlarmsDetailsApiGetStatDataFields1Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitoringAlarmsDetailsApiService.GetStatDataFields1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/alarms/fields"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MonitoringAlarmsDetailsApiGetStatQueryFields1Request struct {
	ctx context.Context
	ApiService *MonitoringAlarmsDetailsApiService
}

func (r MonitoringAlarmsDetailsApiGetStatQueryFields1Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetStatQueryFields1Execute(r)
}

/*
GetStatQueryFields1 Method for GetStatQueryFields1

Get query fields

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MonitoringAlarmsDetailsApiGetStatQueryFields1Request
*/
func (a *MonitoringAlarmsDetailsApiService) GetStatQueryFields1(ctx context.Context) MonitoringAlarmsDetailsApiGetStatQueryFields1Request {
	return MonitoringAlarmsDetailsApiGetStatQueryFields1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *MonitoringAlarmsDetailsApiService) GetStatQueryFields1Execute(r MonitoringAlarmsDetailsApiGetStatQueryFields1Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitoringAlarmsDetailsApiService.GetStatQueryFields1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/alarms/query/fields"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MonitoringAlarmsDetailsApiGetStatsRequest struct {
	ctx context.Context
	ApiService *MonitoringAlarmsDetailsApiService
}

func (r MonitoringAlarmsDetailsApiGetStatsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetStatsExecute(r)
}

/*
GetStats Method for GetStats

Get alarm statistics

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MonitoringAlarmsDetailsApiGetStatsRequest
*/
func (a *MonitoringAlarmsDetailsApiService) GetStats(ctx context.Context) MonitoringAlarmsDetailsApiGetStatsRequest {
	return MonitoringAlarmsDetailsApiGetStatsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *MonitoringAlarmsDetailsApiService) GetStatsExecute(r MonitoringAlarmsDetailsApiGetStatsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitoringAlarmsDetailsApiService.GetStats")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/alarms/stats"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MonitoringAlarmsDetailsApiListDisabledAlarmRequest struct {
	ctx context.Context
	ApiService *MonitoringAlarmsDetailsApiService
}

func (r MonitoringAlarmsDetailsApiListDisabledAlarmRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.ListDisabledAlarmExecute(r)
}

/*
ListDisabledAlarm Method for ListDisabledAlarm

List all disabled alarms

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MonitoringAlarmsDetailsApiListDisabledAlarmRequest
*/
func (a *MonitoringAlarmsDetailsApiService) ListDisabledAlarm(ctx context.Context) MonitoringAlarmsDetailsApiListDisabledAlarmRequest {
	return MonitoringAlarmsDetailsApiListDisabledAlarmRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *MonitoringAlarmsDetailsApiService) ListDisabledAlarmExecute(r MonitoringAlarmsDetailsApiListDisabledAlarmRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitoringAlarmsDetailsApiService.ListDisabledAlarm")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/alarms/disabled"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MonitoringAlarmsDetailsApiMarkAlarmsAsViewedRequest struct {
	ctx context.Context
	ApiService *MonitoringAlarmsDetailsApiService
	requestBody *[]map[string]interface{}
}

// List of alarms
func (r MonitoringAlarmsDetailsApiMarkAlarmsAsViewedRequest) RequestBody(requestBody []map[string]interface{}) MonitoringAlarmsDetailsApiMarkAlarmsAsViewedRequest {
	r.requestBody = &requestBody
	return r
}

func (r MonitoringAlarmsDetailsApiMarkAlarmsAsViewedRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.MarkAlarmsAsViewedExecute(r)
}

/*
MarkAlarmsAsViewed Method for MarkAlarmsAsViewed

Mark alarms as acknowledged by the user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MonitoringAlarmsDetailsApiMarkAlarmsAsViewedRequest
*/
func (a *MonitoringAlarmsDetailsApiService) MarkAlarmsAsViewed(ctx context.Context) MonitoringAlarmsDetailsApiMarkAlarmsAsViewedRequest {
	return MonitoringAlarmsDetailsApiMarkAlarmsAsViewedRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *MonitoringAlarmsDetailsApiService) MarkAlarmsAsViewedExecute(r MonitoringAlarmsDetailsApiMarkAlarmsAsViewedRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitoringAlarmsDetailsApiService.MarkAlarmsAsViewed")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/alarms/markviewed"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MonitoringAlarmsDetailsApiMarkAllAlarmsAsViewedRequest struct {
	ctx context.Context
	ApiService *MonitoringAlarmsDetailsApiService
	type_ *string
	body *string
}

// Query filter, possible value are \&quot;active\&quot; \&quot;cleared\&quot;
func (r MonitoringAlarmsDetailsApiMarkAllAlarmsAsViewedRequest) Type_(type_ string) MonitoringAlarmsDetailsApiMarkAllAlarmsAsViewedRequest {
	r.type_ = &type_
	return r
}

func (r MonitoringAlarmsDetailsApiMarkAllAlarmsAsViewedRequest) Body(body string) MonitoringAlarmsDetailsApiMarkAllAlarmsAsViewedRequest {
	r.body = &body
	return r
}

func (r MonitoringAlarmsDetailsApiMarkAllAlarmsAsViewedRequest) Execute() (*http.Response, error) {
	return r.ApiService.MarkAllAlarmsAsViewedExecute(r)
}

/*
MarkAllAlarmsAsViewed Method for MarkAllAlarmsAsViewed

Mark all larms as acknowledged by the user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MonitoringAlarmsDetailsApiMarkAllAlarmsAsViewedRequest
*/
func (a *MonitoringAlarmsDetailsApiService) MarkAllAlarmsAsViewed(ctx context.Context) MonitoringAlarmsDetailsApiMarkAllAlarmsAsViewedRequest {
	return MonitoringAlarmsDetailsApiMarkAllAlarmsAsViewedRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *MonitoringAlarmsDetailsApiService) MarkAllAlarmsAsViewedExecute(r MonitoringAlarmsDetailsApiMarkAllAlarmsAsViewedRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitoringAlarmsDetailsApiService.MarkAllAlarmsAsViewed")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/alarms/markallasviewed"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.type_ != nil {
		localVarQueryParams.Add("type", parameterToString(*r.type_, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type MonitoringAlarmsDetailsApiRestartCorrelationEngineRequest struct {
	ctx context.Context
	ApiService *MonitoringAlarmsDetailsApiService
}

func (r MonitoringAlarmsDetailsApiRestartCorrelationEngineRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.RestartCorrelationEngineExecute(r)
}

/*
RestartCorrelationEngine Method for RestartCorrelationEngine

Restart correlation engine

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MonitoringAlarmsDetailsApiRestartCorrelationEngineRequest
*/
func (a *MonitoringAlarmsDetailsApiService) RestartCorrelationEngine(ctx context.Context) MonitoringAlarmsDetailsApiRestartCorrelationEngineRequest {
	return MonitoringAlarmsDetailsApiRestartCorrelationEngineRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *MonitoringAlarmsDetailsApiService) RestartCorrelationEngineExecute(r MonitoringAlarmsDetailsApiRestartCorrelationEngineRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitoringAlarmsDetailsApiService.RestartCorrelationEngine")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/alarms/restart"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MonitoringAlarmsDetailsApiSetPeriodicPurgeTimerRequest struct {
	ctx context.Context
	ApiService *MonitoringAlarmsDetailsApiService
	interval *string
	activeTime *string
}

// Purge interval
func (r MonitoringAlarmsDetailsApiSetPeriodicPurgeTimerRequest) Interval(interval string) MonitoringAlarmsDetailsApiSetPeriodicPurgeTimerRequest {
	r.interval = &interval
	return r
}

// Purge activeTime
func (r MonitoringAlarmsDetailsApiSetPeriodicPurgeTimerRequest) ActiveTime(activeTime string) MonitoringAlarmsDetailsApiSetPeriodicPurgeTimerRequest {
	r.activeTime = &activeTime
	return r
}

func (r MonitoringAlarmsDetailsApiSetPeriodicPurgeTimerRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.SetPeriodicPurgeTimerExecute(r)
}

/*
SetPeriodicPurgeTimer Method for SetPeriodicPurgeTimer

Set alarm purge timer

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MonitoringAlarmsDetailsApiSetPeriodicPurgeTimerRequest
*/
func (a *MonitoringAlarmsDetailsApiService) SetPeriodicPurgeTimer(ctx context.Context) MonitoringAlarmsDetailsApiSetPeriodicPurgeTimerRequest {
	return MonitoringAlarmsDetailsApiSetPeriodicPurgeTimerRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *MonitoringAlarmsDetailsApiService) SetPeriodicPurgeTimerExecute(r MonitoringAlarmsDetailsApiSetPeriodicPurgeTimerRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitoringAlarmsDetailsApiService.SetPeriodicPurgeTimer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/alarms/purgefrequency"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.interval != nil {
		localVarQueryParams.Add("interval", parameterToString(*r.interval, ""))
	}
	if r.activeTime != nil {
		localVarQueryParams.Add("activeTime", parameterToString(*r.activeTime, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MonitoringAlarmsDetailsApiStartTrackingRequest struct {
	ctx context.Context
	ApiService *MonitoringAlarmsDetailsApiService
	testName string
}

func (r MonitoringAlarmsDetailsApiStartTrackingRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.StartTrackingExecute(r)
}

/*
StartTracking Method for StartTracking

Start tracking events

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param testName test name
 @return MonitoringAlarmsDetailsApiStartTrackingRequest
*/
func (a *MonitoringAlarmsDetailsApiService) StartTracking(ctx context.Context, testName string) MonitoringAlarmsDetailsApiStartTrackingRequest {
	return MonitoringAlarmsDetailsApiStartTrackingRequest{
		ApiService: a,
		ctx: ctx,
		testName: testName,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *MonitoringAlarmsDetailsApiService) StartTrackingExecute(r MonitoringAlarmsDetailsApiStartTrackingRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitoringAlarmsDetailsApiService.StartTracking")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/alarms/starttracking/{testName}"
	localVarPath = strings.Replace(localVarPath, "{"+"testName"+"}", url.PathEscape(parameterToString(r.testName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MonitoringAlarmsDetailsApiStopTrackingRequest struct {
	ctx context.Context
	ApiService *MonitoringAlarmsDetailsApiService
	testName string
}

func (r MonitoringAlarmsDetailsApiStopTrackingRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.StopTrackingExecute(r)
}

/*
StopTracking Method for StopTracking

Stop tracking events

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param testName test name
 @return MonitoringAlarmsDetailsApiStopTrackingRequest
*/
func (a *MonitoringAlarmsDetailsApiService) StopTracking(ctx context.Context, testName string) MonitoringAlarmsDetailsApiStopTrackingRequest {
	return MonitoringAlarmsDetailsApiStopTrackingRequest{
		ApiService: a,
		ctx: ctx,
		testName: testName,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *MonitoringAlarmsDetailsApiService) StopTrackingExecute(r MonitoringAlarmsDetailsApiStopTrackingRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitoringAlarmsDetailsApiService.StopTracking")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/alarms/stoptracking/{testName}"
	localVarPath = strings.Replace(localVarPath, "{"+"testName"+"}", url.PathEscape(parameterToString(r.testName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MonitoringAlarmsDetailsApiUpdateNotificationRuleRequest struct {
	ctx context.Context
	ApiService *MonitoringAlarmsDetailsApiService
	ruleId *string
	body *map[string]interface{}
}

// Rule Id
func (r MonitoringAlarmsDetailsApiUpdateNotificationRuleRequest) RuleId(ruleId string) MonitoringAlarmsDetailsApiUpdateNotificationRuleRequest {
	r.ruleId = &ruleId
	return r
}

// Notification rule
func (r MonitoringAlarmsDetailsApiUpdateNotificationRuleRequest) Body(body map[string]interface{}) MonitoringAlarmsDetailsApiUpdateNotificationRuleRequest {
	r.body = &body
	return r
}

func (r MonitoringAlarmsDetailsApiUpdateNotificationRuleRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateNotificationRuleExecute(r)
}

/*
UpdateNotificationRule Method for UpdateNotificationRule

Update notification rule

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MonitoringAlarmsDetailsApiUpdateNotificationRuleRequest
*/
func (a *MonitoringAlarmsDetailsApiService) UpdateNotificationRule(ctx context.Context) MonitoringAlarmsDetailsApiUpdateNotificationRuleRequest {
	return MonitoringAlarmsDetailsApiUpdateNotificationRuleRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *MonitoringAlarmsDetailsApiService) UpdateNotificationRuleExecute(r MonitoringAlarmsDetailsApiUpdateNotificationRuleRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitoringAlarmsDetailsApiService.UpdateNotificationRule")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/rule"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ruleId == nil {
		return nil, reportError("ruleId is required and must be specified")
	}

	localVarQueryParams.Add("ruleId", parameterToString(*r.ruleId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
