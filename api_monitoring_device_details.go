/*
Cisco SD-WAN vManage API

The vManage API exposes the functionality of operations maintaining devices and the overlay network

API version: 2.0.0
Contact: vmanage@cisco.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// MonitoringDeviceDetailsApiService MonitoringDeviceDetailsApi service
type MonitoringDeviceDetailsApiService service

type MonitoringDeviceDetailsApiEnableSDAVCOnDeviceRequest struct {
	ctx context.Context
	ApiService *MonitoringDeviceDetailsApiService
	deviceIP string
	enable bool
}

func (r MonitoringDeviceDetailsApiEnableSDAVCOnDeviceRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnableSDAVCOnDeviceExecute(r)
}

/*
EnableSDAVCOnDevice Method for EnableSDAVCOnDevice

Enable/Disable SDAVC on device

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceIP Device IP
 @param enable Enable/Disable flag
 @return MonitoringDeviceDetailsApiEnableSDAVCOnDeviceRequest
*/
func (a *MonitoringDeviceDetailsApiService) EnableSDAVCOnDevice(ctx context.Context, deviceIP string, enable bool) MonitoringDeviceDetailsApiEnableSDAVCOnDeviceRequest {
	return MonitoringDeviceDetailsApiEnableSDAVCOnDeviceRequest{
		ApiService: a,
		ctx: ctx,
		deviceIP: deviceIP,
		enable: enable,
	}
}

// Execute executes the request
func (a *MonitoringDeviceDetailsApiService) EnableSDAVCOnDeviceExecute(r MonitoringDeviceDetailsApiEnableSDAVCOnDeviceRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitoringDeviceDetailsApiService.EnableSDAVCOnDevice")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/enableSDAVC/{deviceIP}/{enable}"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceIP"+"}", url.PathEscape(parameterToString(r.deviceIP, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"enable"+"}", url.PathEscape(parameterToString(r.enable, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type MonitoringDeviceDetailsApiGenerateDeviceStateDataRequest struct {
	ctx context.Context
	ApiService *MonitoringDeviceDetailsApiService
	stateDataType string
	startId *string
	count *string
}

// Start Id
func (r MonitoringDeviceDetailsApiGenerateDeviceStateDataRequest) StartId(startId string) MonitoringDeviceDetailsApiGenerateDeviceStateDataRequest {
	r.startId = &startId
	return r
}

// Count
func (r MonitoringDeviceDetailsApiGenerateDeviceStateDataRequest) Count(count string) MonitoringDeviceDetailsApiGenerateDeviceStateDataRequest {
	r.count = &count
	return r
}

func (r MonitoringDeviceDetailsApiGenerateDeviceStateDataRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GenerateDeviceStateDataExecute(r)
}

/*
GenerateDeviceStateData Method for GenerateDeviceStateData

Get device state data

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param stateDataType State data type
 @return MonitoringDeviceDetailsApiGenerateDeviceStateDataRequest
*/
func (a *MonitoringDeviceDetailsApiService) GenerateDeviceStateData(ctx context.Context, stateDataType string) MonitoringDeviceDetailsApiGenerateDeviceStateDataRequest {
	return MonitoringDeviceDetailsApiGenerateDeviceStateDataRequest{
		ApiService: a,
		ctx: ctx,
		stateDataType: stateDataType,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *MonitoringDeviceDetailsApiService) GenerateDeviceStateDataExecute(r MonitoringDeviceDetailsApiGenerateDeviceStateDataRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitoringDeviceDetailsApiService.GenerateDeviceStateData")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data/device/state/{state_data_type}"
	localVarPath = strings.Replace(localVarPath, "{"+"state_data_type"+"}", url.PathEscape(parameterToString(r.stateDataType, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.startId == nil {
		return localVarReturnValue, nil, reportError("startId is required and must be specified")
	}

	localVarQueryParams.Add("startId", parameterToString(*r.startId, ""))
	if r.count != nil {
		localVarQueryParams.Add("count", parameterToString(*r.count, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MonitoringDeviceDetailsApiGenerateDeviceStateDataFieldsRequest struct {
	ctx context.Context
	ApiService *MonitoringDeviceDetailsApiService
	stateDataType string
}

func (r MonitoringDeviceDetailsApiGenerateDeviceStateDataFieldsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GenerateDeviceStateDataFieldsExecute(r)
}

/*
GenerateDeviceStateDataFields Method for GenerateDeviceStateDataFields

Get device state data fileds

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param stateDataType State data type
 @return MonitoringDeviceDetailsApiGenerateDeviceStateDataFieldsRequest
*/
func (a *MonitoringDeviceDetailsApiService) GenerateDeviceStateDataFields(ctx context.Context, stateDataType string) MonitoringDeviceDetailsApiGenerateDeviceStateDataFieldsRequest {
	return MonitoringDeviceDetailsApiGenerateDeviceStateDataFieldsRequest{
		ApiService: a,
		ctx: ctx,
		stateDataType: stateDataType,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *MonitoringDeviceDetailsApiService) GenerateDeviceStateDataFieldsExecute(r MonitoringDeviceDetailsApiGenerateDeviceStateDataFieldsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitoringDeviceDetailsApiService.GenerateDeviceStateDataFields")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data/device/state/{state_data_type}/fields"
	localVarPath = strings.Replace(localVarPath, "{"+"state_data_type"+"}", url.PathEscape(parameterToString(r.stateDataType, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MonitoringDeviceDetailsApiGenerateDeviceStateDataWithQueryStringRequest struct {
	ctx context.Context
	ApiService *MonitoringDeviceDetailsApiService
	stateDataType string
}

func (r MonitoringDeviceDetailsApiGenerateDeviceStateDataWithQueryStringRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GenerateDeviceStateDataWithQueryStringExecute(r)
}

/*
GenerateDeviceStateDataWithQueryString Method for GenerateDeviceStateDataWithQueryString

Get device state data fileds

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param stateDataType State data type
 @return MonitoringDeviceDetailsApiGenerateDeviceStateDataWithQueryStringRequest
*/
func (a *MonitoringDeviceDetailsApiService) GenerateDeviceStateDataWithQueryString(ctx context.Context, stateDataType string) MonitoringDeviceDetailsApiGenerateDeviceStateDataWithQueryStringRequest {
	return MonitoringDeviceDetailsApiGenerateDeviceStateDataWithQueryStringRequest{
		ApiService: a,
		ctx: ctx,
		stateDataType: stateDataType,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *MonitoringDeviceDetailsApiService) GenerateDeviceStateDataWithQueryStringExecute(r MonitoringDeviceDetailsApiGenerateDeviceStateDataWithQueryStringRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitoringDeviceDetailsApiService.GenerateDeviceStateDataWithQueryString")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data/device/state/{state_data_type}/query"
	localVarPath = strings.Replace(localVarPath, "{"+"state_data_type"+"}", url.PathEscape(parameterToString(r.stateDataType, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MonitoringDeviceDetailsApiGetAllDeviceStatusRequest struct {
	ctx context.Context
	ApiService *MonitoringDeviceDetailsApiService
}

func (r MonitoringDeviceDetailsApiGetAllDeviceStatusRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetAllDeviceStatusExecute(r)
}

/*
GetAllDeviceStatus Method for GetAllDeviceStatus

Get devices status for vSmart,vBond,vEdge, and cEdge

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MonitoringDeviceDetailsApiGetAllDeviceStatusRequest
*/
func (a *MonitoringDeviceDetailsApiService) GetAllDeviceStatus(ctx context.Context) MonitoringDeviceDetailsApiGetAllDeviceStatusRequest {
	return MonitoringDeviceDetailsApiGetAllDeviceStatusRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *MonitoringDeviceDetailsApiService) GetAllDeviceStatusExecute(r MonitoringDeviceDetailsApiGetAllDeviceStatusRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitoringDeviceDetailsApiService.GetAllDeviceStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/status"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MonitoringDeviceDetailsApiGetDeviceCountersRequest struct {
	ctx context.Context
	ApiService *MonitoringDeviceDetailsApiService
}

func (r MonitoringDeviceDetailsApiGetDeviceCountersRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetDeviceCountersExecute(r)
}

/*
GetDeviceCounters Method for GetDeviceCounters

Get device counters

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MonitoringDeviceDetailsApiGetDeviceCountersRequest
*/
func (a *MonitoringDeviceDetailsApiService) GetDeviceCounters(ctx context.Context) MonitoringDeviceDetailsApiGetDeviceCountersRequest {
	return MonitoringDeviceDetailsApiGetDeviceCountersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *MonitoringDeviceDetailsApiService) GetDeviceCountersExecute(r MonitoringDeviceDetailsApiGetDeviceCountersRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitoringDeviceDetailsApiService.GetDeviceCounters")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/counters"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MonitoringDeviceDetailsApiGetDeviceListAsKeyValueRequest struct {
	ctx context.Context
	ApiService *MonitoringDeviceDetailsApiService
}

func (r MonitoringDeviceDetailsApiGetDeviceListAsKeyValueRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetDeviceListAsKeyValueExecute(r)
}

/*
GetDeviceListAsKeyValue Method for GetDeviceListAsKeyValue

Get vEdge inventory as key value (key as systemIp value as hostName)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MonitoringDeviceDetailsApiGetDeviceListAsKeyValueRequest
*/
func (a *MonitoringDeviceDetailsApiService) GetDeviceListAsKeyValue(ctx context.Context) MonitoringDeviceDetailsApiGetDeviceListAsKeyValueRequest {
	return MonitoringDeviceDetailsApiGetDeviceListAsKeyValueRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *MonitoringDeviceDetailsApiService) GetDeviceListAsKeyValueExecute(r MonitoringDeviceDetailsApiGetDeviceListAsKeyValueRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitoringDeviceDetailsApiService.GetDeviceListAsKeyValue")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/keyvalue"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MonitoringDeviceDetailsApiGetDeviceModelsRequest struct {
	ctx context.Context
	ApiService *MonitoringDeviceDetailsApiService
	uuid string
}

func (r MonitoringDeviceDetailsApiGetDeviceModelsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetDeviceModelsExecute(r)
}

/*
GetDeviceModels Method for GetDeviceModels

Get device model for the device

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid Device uuid
 @return MonitoringDeviceDetailsApiGetDeviceModelsRequest
*/
func (a *MonitoringDeviceDetailsApiService) GetDeviceModels(ctx context.Context, uuid string) MonitoringDeviceDetailsApiGetDeviceModelsRequest {
	return MonitoringDeviceDetailsApiGetDeviceModelsRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *MonitoringDeviceDetailsApiService) GetDeviceModelsExecute(r MonitoringDeviceDetailsApiGetDeviceModelsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitoringDeviceDetailsApiService.GetDeviceModels")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/models/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterToString(r.uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MonitoringDeviceDetailsApiGetDeviceOnlyStatusRequest struct {
	ctx context.Context
	ApiService *MonitoringDeviceDetailsApiService
}

func (r MonitoringDeviceDetailsApiGetDeviceOnlyStatusRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetDeviceOnlyStatusExecute(r)
}

/*
GetDeviceOnlyStatus Method for GetDeviceOnlyStatus

Get devices status per type

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MonitoringDeviceDetailsApiGetDeviceOnlyStatusRequest
*/
func (a *MonitoringDeviceDetailsApiService) GetDeviceOnlyStatus(ctx context.Context) MonitoringDeviceDetailsApiGetDeviceOnlyStatusRequest {
	return MonitoringDeviceDetailsApiGetDeviceOnlyStatusRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *MonitoringDeviceDetailsApiService) GetDeviceOnlyStatusExecute(r MonitoringDeviceDetailsApiGetDeviceOnlyStatusRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitoringDeviceDetailsApiService.GetDeviceOnlyStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/devicestatus"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MonitoringDeviceDetailsApiGetDeviceRunningConfigRequest struct {
	ctx context.Context
	ApiService *MonitoringDeviceDetailsApiService
	deviceId *[]string
}

// Device Id list
func (r MonitoringDeviceDetailsApiGetDeviceRunningConfigRequest) DeviceId(deviceId []string) MonitoringDeviceDetailsApiGetDeviceRunningConfigRequest {
	r.deviceId = &deviceId
	return r
}

func (r MonitoringDeviceDetailsApiGetDeviceRunningConfigRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.GetDeviceRunningConfigExecute(r)
}

/*
GetDeviceRunningConfig Method for GetDeviceRunningConfig

Get device running configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MonitoringDeviceDetailsApiGetDeviceRunningConfigRequest
*/
func (a *MonitoringDeviceDetailsApiService) GetDeviceRunningConfig(ctx context.Context) MonitoringDeviceDetailsApiGetDeviceRunningConfigRequest {
	return MonitoringDeviceDetailsApiGetDeviceRunningConfigRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return string
func (a *MonitoringDeviceDetailsApiService) GetDeviceRunningConfigExecute(r MonitoringDeviceDetailsApiGetDeviceRunningConfigRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitoringDeviceDetailsApiService.GetDeviceRunningConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/config"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deviceId == nil {
		return localVarReturnValue, nil, reportError("deviceId is required and must be specified")
	}

	{
		t := *r.deviceId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("deviceId", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("deviceId", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "text/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MonitoringDeviceDetailsApiGetDeviceRunningConfigHTMLRequest struct {
	ctx context.Context
	ApiService *MonitoringDeviceDetailsApiService
	deviceId *[]string
}

// Device Id list
func (r MonitoringDeviceDetailsApiGetDeviceRunningConfigHTMLRequest) DeviceId(deviceId []string) MonitoringDeviceDetailsApiGetDeviceRunningConfigHTMLRequest {
	r.deviceId = &deviceId
	return r
}

func (r MonitoringDeviceDetailsApiGetDeviceRunningConfigHTMLRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.GetDeviceRunningConfigHTMLExecute(r)
}

/*
GetDeviceRunningConfigHTML Method for GetDeviceRunningConfigHTML

Get device running configuration in HTML format

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MonitoringDeviceDetailsApiGetDeviceRunningConfigHTMLRequest

Deprecated
*/
func (a *MonitoringDeviceDetailsApiService) GetDeviceRunningConfigHTML(ctx context.Context) MonitoringDeviceDetailsApiGetDeviceRunningConfigHTMLRequest {
	return MonitoringDeviceDetailsApiGetDeviceRunningConfigHTMLRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return string
// Deprecated
func (a *MonitoringDeviceDetailsApiService) GetDeviceRunningConfigHTMLExecute(r MonitoringDeviceDetailsApiGetDeviceRunningConfigHTMLRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitoringDeviceDetailsApiService.GetDeviceRunningConfigHTML")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/config/html"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deviceId == nil {
		return localVarReturnValue, nil, reportError("deviceId is required and must be specified")
	}

	{
		t := *r.deviceId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("deviceId", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("deviceId", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/html"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MonitoringDeviceDetailsApiGetDeviceTlocStatusRequest struct {
	ctx context.Context
	ApiService *MonitoringDeviceDetailsApiService
	deviceId *string
	color *string
}

// Device Id
func (r MonitoringDeviceDetailsApiGetDeviceTlocStatusRequest) DeviceId(deviceId string) MonitoringDeviceDetailsApiGetDeviceTlocStatusRequest {
	r.deviceId = &deviceId
	return r
}

// Status color
func (r MonitoringDeviceDetailsApiGetDeviceTlocStatusRequest) Color(color string) MonitoringDeviceDetailsApiGetDeviceTlocStatusRequest {
	r.color = &color
	return r
}

func (r MonitoringDeviceDetailsApiGetDeviceTlocStatusRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetDeviceTlocStatusExecute(r)
}

/*
GetDeviceTlocStatus Method for GetDeviceTlocStatus

Get TLOC status list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MonitoringDeviceDetailsApiGetDeviceTlocStatusRequest
*/
func (a *MonitoringDeviceDetailsApiService) GetDeviceTlocStatus(ctx context.Context) MonitoringDeviceDetailsApiGetDeviceTlocStatusRequest {
	return MonitoringDeviceDetailsApiGetDeviceTlocStatusRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *MonitoringDeviceDetailsApiService) GetDeviceTlocStatusExecute(r MonitoringDeviceDetailsApiGetDeviceTlocStatusRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitoringDeviceDetailsApiService.GetDeviceTlocStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/tloc"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.deviceId != nil {
		localVarQueryParams.Add("deviceId", parameterToString(*r.deviceId, ""))
	}
	if r.color != nil {
		localVarQueryParams.Add("color", parameterToString(*r.color, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MonitoringDeviceDetailsApiGetDeviceTlocUtilRequest struct {
	ctx context.Context
	ApiService *MonitoringDeviceDetailsApiService
}

func (r MonitoringDeviceDetailsApiGetDeviceTlocUtilRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetDeviceTlocUtilExecute(r)
}

/*
GetDeviceTlocUtil Method for GetDeviceTlocUtil

Get TLOC list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MonitoringDeviceDetailsApiGetDeviceTlocUtilRequest
*/
func (a *MonitoringDeviceDetailsApiService) GetDeviceTlocUtil(ctx context.Context) MonitoringDeviceDetailsApiGetDeviceTlocUtilRequest {
	return MonitoringDeviceDetailsApiGetDeviceTlocUtilRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *MonitoringDeviceDetailsApiService) GetDeviceTlocUtilExecute(r MonitoringDeviceDetailsApiGetDeviceTlocUtilRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitoringDeviceDetailsApiService.GetDeviceTlocUtil")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/tlocutil"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MonitoringDeviceDetailsApiGetDeviceTlocUtilDetailsRequest struct {
	ctx context.Context
	ApiService *MonitoringDeviceDetailsApiService
	util *string
}

// Tloc util
func (r MonitoringDeviceDetailsApiGetDeviceTlocUtilDetailsRequest) Util(util string) MonitoringDeviceDetailsApiGetDeviceTlocUtilDetailsRequest {
	r.util = &util
	return r
}

func (r MonitoringDeviceDetailsApiGetDeviceTlocUtilDetailsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetDeviceTlocUtilDetailsExecute(r)
}

/*
GetDeviceTlocUtilDetails Method for GetDeviceTlocUtilDetails

Get detailed TLOC list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MonitoringDeviceDetailsApiGetDeviceTlocUtilDetailsRequest
*/
func (a *MonitoringDeviceDetailsApiService) GetDeviceTlocUtilDetails(ctx context.Context) MonitoringDeviceDetailsApiGetDeviceTlocUtilDetailsRequest {
	return MonitoringDeviceDetailsApiGetDeviceTlocUtilDetailsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *MonitoringDeviceDetailsApiService) GetDeviceTlocUtilDetailsExecute(r MonitoringDeviceDetailsApiGetDeviceTlocUtilDetailsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitoringDeviceDetailsApiService.GetDeviceTlocUtilDetails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/tlocutil/detail"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.util != nil {
		localVarQueryParams.Add("util", parameterToString(*r.util, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MonitoringDeviceDetailsApiGetHardwareHealthDetailsRequest struct {
	ctx context.Context
	ApiService *MonitoringDeviceDetailsApiService
	deviceId *string
	state *string
}

// Device Id
func (r MonitoringDeviceDetailsApiGetHardwareHealthDetailsRequest) DeviceId(deviceId string) MonitoringDeviceDetailsApiGetHardwareHealthDetailsRequest {
	r.deviceId = &deviceId
	return r
}

// Device state
func (r MonitoringDeviceDetailsApiGetHardwareHealthDetailsRequest) State(state string) MonitoringDeviceDetailsApiGetHardwareHealthDetailsRequest {
	r.state = &state
	return r
}

func (r MonitoringDeviceDetailsApiGetHardwareHealthDetailsRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetHardwareHealthDetailsExecute(r)
}

/*
GetHardwareHealthDetails Method for GetHardwareHealthDetails

Get hardware health details for device

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MonitoringDeviceDetailsApiGetHardwareHealthDetailsRequest
*/
func (a *MonitoringDeviceDetailsApiService) GetHardwareHealthDetails(ctx context.Context) MonitoringDeviceDetailsApiGetHardwareHealthDetailsRequest {
	return MonitoringDeviceDetailsApiGetHardwareHealthDetailsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *MonitoringDeviceDetailsApiService) GetHardwareHealthDetailsExecute(r MonitoringDeviceDetailsApiGetHardwareHealthDetailsRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitoringDeviceDetailsApiService.GetHardwareHealthDetails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/hardwarehealth/detail"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.deviceId != nil {
		localVarQueryParams.Add("deviceId", parameterToString(*r.deviceId, ""))
	}
	if r.state != nil {
		localVarQueryParams.Add("state", parameterToString(*r.state, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MonitoringDeviceDetailsApiGetHardwareHealthSummaryRequest struct {
	ctx context.Context
	ApiService *MonitoringDeviceDetailsApiService
	vpnId *[]string
	isCached *bool
}

// VPN Id
func (r MonitoringDeviceDetailsApiGetHardwareHealthSummaryRequest) VpnId(vpnId []string) MonitoringDeviceDetailsApiGetHardwareHealthSummaryRequest {
	r.vpnId = &vpnId
	return r
}

// Status cached
func (r MonitoringDeviceDetailsApiGetHardwareHealthSummaryRequest) IsCached(isCached bool) MonitoringDeviceDetailsApiGetHardwareHealthSummaryRequest {
	r.isCached = &isCached
	return r
}

func (r MonitoringDeviceDetailsApiGetHardwareHealthSummaryRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetHardwareHealthSummaryExecute(r)
}

/*
GetHardwareHealthSummary Method for GetHardwareHealthSummary

Get hardware health summary for device

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MonitoringDeviceDetailsApiGetHardwareHealthSummaryRequest
*/
func (a *MonitoringDeviceDetailsApiService) GetHardwareHealthSummary(ctx context.Context) MonitoringDeviceDetailsApiGetHardwareHealthSummaryRequest {
	return MonitoringDeviceDetailsApiGetHardwareHealthSummaryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *MonitoringDeviceDetailsApiService) GetHardwareHealthSummaryExecute(r MonitoringDeviceDetailsApiGetHardwareHealthSummaryRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitoringDeviceDetailsApiService.GetHardwareHealthSummary")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/hardwarehealth/summary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vpnId == nil {
		return localVarReturnValue, nil, reportError("vpnId is required and must be specified")
	}

	if r.isCached != nil {
		localVarQueryParams.Add("isCached", parameterToString(*r.isCached, ""))
	}
	{
		t := *r.vpnId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("vpnId", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("vpnId", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MonitoringDeviceDetailsApiGetStatsQueuesRequest struct {
	ctx context.Context
	ApiService *MonitoringDeviceDetailsApiService
}

func (r MonitoringDeviceDetailsApiGetStatsQueuesRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetStatsQueuesExecute(r)
}

/*
GetStatsQueues Method for GetStatsQueues

Get stats queue information

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MonitoringDeviceDetailsApiGetStatsQueuesRequest
*/
func (a *MonitoringDeviceDetailsApiService) GetStatsQueues(ctx context.Context) MonitoringDeviceDetailsApiGetStatsQueuesRequest {
	return MonitoringDeviceDetailsApiGetStatsQueuesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *MonitoringDeviceDetailsApiService) GetStatsQueuesExecute(r MonitoringDeviceDetailsApiGetStatsQueuesRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitoringDeviceDetailsApiService.GetStatsQueues")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/stats"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MonitoringDeviceDetailsApiGetSyncQueuesRequest struct {
	ctx context.Context
	ApiService *MonitoringDeviceDetailsApiService
}

func (r MonitoringDeviceDetailsApiGetSyncQueuesRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetSyncQueuesExecute(r)
}

/*
GetSyncQueues Method for GetSyncQueues

Get synchronized queue information, returns information about syncing, queued and stuck devices

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MonitoringDeviceDetailsApiGetSyncQueuesRequest
*/
func (a *MonitoringDeviceDetailsApiService) GetSyncQueues(ctx context.Context) MonitoringDeviceDetailsApiGetSyncQueuesRequest {
	return MonitoringDeviceDetailsApiGetSyncQueuesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *MonitoringDeviceDetailsApiService) GetSyncQueuesExecute(r MonitoringDeviceDetailsApiGetSyncQueuesRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitoringDeviceDetailsApiService.GetSyncQueues")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/queues"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MonitoringDeviceDetailsApiGetUnconfiguredRequest struct {
	ctx context.Context
	ApiService *MonitoringDeviceDetailsApiService
}

func (r MonitoringDeviceDetailsApiGetUnconfiguredRequest) Execute() ([]Device, *http.Response, error) {
	return r.ApiService.GetUnconfiguredExecute(r)
}

/*
GetUnconfigured Method for GetUnconfigured

Get wan edge devices not configured by vManage (that is, those in CLI mode)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MonitoringDeviceDetailsApiGetUnconfiguredRequest
*/
func (a *MonitoringDeviceDetailsApiService) GetUnconfigured(ctx context.Context) MonitoringDeviceDetailsApiGetUnconfiguredRequest {
	return MonitoringDeviceDetailsApiGetUnconfiguredRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []Device
func (a *MonitoringDeviceDetailsApiService) GetUnconfiguredExecute(r MonitoringDeviceDetailsApiGetUnconfiguredRequest) ([]Device, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Device
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitoringDeviceDetailsApiService.GetUnconfigured")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/unconfigured"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MonitoringDeviceDetailsApiGetVManageSystemIPRequest struct {
	ctx context.Context
	ApiService *MonitoringDeviceDetailsApiService
}

func (r MonitoringDeviceDetailsApiGetVManageSystemIPRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetVManageSystemIPExecute(r)
}

/*
GetVManageSystemIP Method for GetVManageSystemIP

Get vManage system IP

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MonitoringDeviceDetailsApiGetVManageSystemIPRequest
*/
func (a *MonitoringDeviceDetailsApiService) GetVManageSystemIP(ctx context.Context) MonitoringDeviceDetailsApiGetVManageSystemIPRequest {
	return MonitoringDeviceDetailsApiGetVManageSystemIPRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *MonitoringDeviceDetailsApiService) GetVManageSystemIPExecute(r MonitoringDeviceDetailsApiGetVManageSystemIPRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitoringDeviceDetailsApiService.GetVManageSystemIP")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/vmanage"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MonitoringDeviceDetailsApiGetVedgeInventoryRequest struct {
	ctx context.Context
	ApiService *MonitoringDeviceDetailsApiService
	status *string
}

// Device status
func (r MonitoringDeviceDetailsApiGetVedgeInventoryRequest) Status(status string) MonitoringDeviceDetailsApiGetVedgeInventoryRequest {
	r.status = &status
	return r
}

func (r MonitoringDeviceDetailsApiGetVedgeInventoryRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetVedgeInventoryExecute(r)
}

/*
GetVedgeInventory Method for GetVedgeInventory

Get detailed vEdge inventory

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MonitoringDeviceDetailsApiGetVedgeInventoryRequest
*/
func (a *MonitoringDeviceDetailsApiService) GetVedgeInventory(ctx context.Context) MonitoringDeviceDetailsApiGetVedgeInventoryRequest {
	return MonitoringDeviceDetailsApiGetVedgeInventoryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *MonitoringDeviceDetailsApiService) GetVedgeInventoryExecute(r MonitoringDeviceDetailsApiGetVedgeInventoryRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitoringDeviceDetailsApiService.GetVedgeInventory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/vedgeinventory/detail"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.status != nil {
		localVarQueryParams.Add("status", parameterToString(*r.status, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MonitoringDeviceDetailsApiGetVedgeInventorySummaryRequest struct {
	ctx context.Context
	ApiService *MonitoringDeviceDetailsApiService
}

func (r MonitoringDeviceDetailsApiGetVedgeInventorySummaryRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetVedgeInventorySummaryExecute(r)
}

/*
GetVedgeInventorySummary Method for GetVedgeInventorySummary

Get vEdge inventory

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MonitoringDeviceDetailsApiGetVedgeInventorySummaryRequest
*/
func (a *MonitoringDeviceDetailsApiService) GetVedgeInventorySummary(ctx context.Context) MonitoringDeviceDetailsApiGetVedgeInventorySummaryRequest {
	return MonitoringDeviceDetailsApiGetVedgeInventorySummaryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *MonitoringDeviceDetailsApiService) GetVedgeInventorySummaryExecute(r MonitoringDeviceDetailsApiGetVedgeInventorySummaryRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitoringDeviceDetailsApiService.GetVedgeInventorySummary")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/vedgeinventory/summary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MonitoringDeviceDetailsApiListAllDeviceModelsRequest struct {
	ctx context.Context
	ApiService *MonitoringDeviceDetailsApiService
	list *string
}

// List type of device
func (r MonitoringDeviceDetailsApiListAllDeviceModelsRequest) List(list string) MonitoringDeviceDetailsApiListAllDeviceModelsRequest {
	r.list = &list
	return r
}

func (r MonitoringDeviceDetailsApiListAllDeviceModelsRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.ListAllDeviceModelsExecute(r)
}

/*
ListAllDeviceModels Method for ListAllDeviceModels

Get all device models supported by the vManage

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MonitoringDeviceDetailsApiListAllDeviceModelsRequest
*/
func (a *MonitoringDeviceDetailsApiService) ListAllDeviceModels(ctx context.Context) MonitoringDeviceDetailsApiListAllDeviceModelsRequest {
	return MonitoringDeviceDetailsApiListAllDeviceModelsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *MonitoringDeviceDetailsApiService) ListAllDeviceModelsExecute(r MonitoringDeviceDetailsApiListAllDeviceModelsRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitoringDeviceDetailsApiService.ListAllDeviceModels")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/models"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.list == nil {
		return localVarReturnValue, nil, reportError("list is required and must be specified")
	}

	localVarQueryParams.Add("list", parameterToString(*r.list, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MonitoringDeviceDetailsApiListAllDevicesRequest struct {
	ctx context.Context
	ApiService *MonitoringDeviceDetailsApiService
}

func (r MonitoringDeviceDetailsApiListAllDevicesRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.ListAllDevicesExecute(r)
}

/*
ListAllDevices Method for ListAllDevices

List all devices

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MonitoringDeviceDetailsApiListAllDevicesRequest
*/
func (a *MonitoringDeviceDetailsApiService) ListAllDevices(ctx context.Context) MonitoringDeviceDetailsApiListAllDevicesRequest {
	return MonitoringDeviceDetailsApiListAllDevicesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *MonitoringDeviceDetailsApiService) ListAllDevicesExecute(r MonitoringDeviceDetailsApiListAllDevicesRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitoringDeviceDetailsApiService.ListAllDevices")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MonitoringDeviceDetailsApiListAllMonitorDetailsDevicesRequest struct {
	ctx context.Context
	ApiService *MonitoringDeviceDetailsApiService
}

func (r MonitoringDeviceDetailsApiListAllMonitorDetailsDevicesRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ListAllMonitorDetailsDevicesExecute(r)
}

/*
ListAllMonitorDetailsDevices Method for ListAllMonitorDetailsDevices

Get all monitoring details of the devices

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MonitoringDeviceDetailsApiListAllMonitorDetailsDevicesRequest
*/
func (a *MonitoringDeviceDetailsApiService) ListAllMonitorDetailsDevices(ctx context.Context) MonitoringDeviceDetailsApiListAllMonitorDetailsDevicesRequest {
	return MonitoringDeviceDetailsApiListAllMonitorDetailsDevicesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *MonitoringDeviceDetailsApiService) ListAllMonitorDetailsDevicesExecute(r MonitoringDeviceDetailsApiListAllMonitorDetailsDevicesRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitoringDeviceDetailsApiService.ListAllMonitorDetailsDevices")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/monitor"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MonitoringDeviceDetailsApiListCurrentlySyncingDevicesRequest struct {
	ctx context.Context
	ApiService *MonitoringDeviceDetailsApiService
	groupId *string
}

// Group Id
func (r MonitoringDeviceDetailsApiListCurrentlySyncingDevicesRequest) GroupId(groupId string) MonitoringDeviceDetailsApiListCurrentlySyncingDevicesRequest {
	r.groupId = &groupId
	return r
}

func (r MonitoringDeviceDetailsApiListCurrentlySyncingDevicesRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.ListCurrentlySyncingDevicesExecute(r)
}

/*
ListCurrentlySyncingDevices Method for ListCurrentlySyncingDevices

Get list of currently syncing devices

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MonitoringDeviceDetailsApiListCurrentlySyncingDevicesRequest
*/
func (a *MonitoringDeviceDetailsApiService) ListCurrentlySyncingDevices(ctx context.Context) MonitoringDeviceDetailsApiListCurrentlySyncingDevicesRequest {
	return MonitoringDeviceDetailsApiListCurrentlySyncingDevicesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *MonitoringDeviceDetailsApiService) ListCurrentlySyncingDevicesExecute(r MonitoringDeviceDetailsApiListCurrentlySyncingDevicesRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitoringDeviceDetailsApiService.ListCurrentlySyncingDevices")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/sync_status"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.groupId == nil {
		return localVarReturnValue, nil, reportError("groupId is required and must be specified")
	}

	localVarQueryParams.Add("groupId", parameterToString(*r.groupId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MonitoringDeviceDetailsApiListReachableDevicesRequest struct {
	ctx context.Context
	ApiService *MonitoringDeviceDetailsApiService
}

func (r MonitoringDeviceDetailsApiListReachableDevicesRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.ListReachableDevicesExecute(r)
}

/*
ListReachableDevices Method for ListReachableDevices

Get list of reachable devices

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MonitoringDeviceDetailsApiListReachableDevicesRequest
*/
func (a *MonitoringDeviceDetailsApiService) ListReachableDevices(ctx context.Context) MonitoringDeviceDetailsApiListReachableDevicesRequest {
	return MonitoringDeviceDetailsApiListReachableDevicesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *MonitoringDeviceDetailsApiService) ListReachableDevicesExecute(r MonitoringDeviceDetailsApiListReachableDevicesRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitoringDeviceDetailsApiService.ListReachableDevices")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/reachable"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MonitoringDeviceDetailsApiListUnreachableDevicesRequest struct {
	ctx context.Context
	ApiService *MonitoringDeviceDetailsApiService
	personality *string
}

// Device personality
func (r MonitoringDeviceDetailsApiListUnreachableDevicesRequest) Personality(personality string) MonitoringDeviceDetailsApiListUnreachableDevicesRequest {
	r.personality = &personality
	return r
}

func (r MonitoringDeviceDetailsApiListUnreachableDevicesRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.ListUnreachableDevicesExecute(r)
}

/*
ListUnreachableDevices Method for ListUnreachableDevices

Get list of unreachable devices

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MonitoringDeviceDetailsApiListUnreachableDevicesRequest
*/
func (a *MonitoringDeviceDetailsApiService) ListUnreachableDevices(ctx context.Context) MonitoringDeviceDetailsApiListUnreachableDevicesRequest {
	return MonitoringDeviceDetailsApiListUnreachableDevicesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *MonitoringDeviceDetailsApiService) ListUnreachableDevicesExecute(r MonitoringDeviceDetailsApiListUnreachableDevicesRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitoringDeviceDetailsApiService.ListUnreachableDevices")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/unreachable"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.personality == nil {
		return localVarReturnValue, nil, reportError("personality is required and must be specified")
	}

	localVarQueryParams.Add("personality", parameterToString(*r.personality, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MonitoringDeviceDetailsApiRemoveUnreachableDeviceRequest struct {
	ctx context.Context
	ApiService *MonitoringDeviceDetailsApiService
	deviceIP string
}

func (r MonitoringDeviceDetailsApiRemoveUnreachableDeviceRequest) Execute() (*http.Response, error) {
	return r.ApiService.RemoveUnreachableDeviceExecute(r)
}

/*
RemoveUnreachableDevice Method for RemoveUnreachableDevice

Delete unreachable device

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceIP Device IP
 @return MonitoringDeviceDetailsApiRemoveUnreachableDeviceRequest
*/
func (a *MonitoringDeviceDetailsApiService) RemoveUnreachableDevice(ctx context.Context, deviceIP string) MonitoringDeviceDetailsApiRemoveUnreachableDeviceRequest {
	return MonitoringDeviceDetailsApiRemoveUnreachableDeviceRequest{
		ApiService: a,
		ctx: ctx,
		deviceIP: deviceIP,
	}
}

// Execute executes the request
func (a *MonitoringDeviceDetailsApiService) RemoveUnreachableDeviceExecute(r MonitoringDeviceDetailsApiRemoveUnreachableDeviceRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitoringDeviceDetailsApiService.RemoveUnreachableDevice")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/unreachable/{deviceIP}"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceIP"+"}", url.PathEscape(parameterToString(r.deviceIP, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type MonitoringDeviceDetailsApiSetBlockSyncRequest struct {
	ctx context.Context
	ApiService *MonitoringDeviceDetailsApiService
	blockSync *string
}

// Block sync flag
func (r MonitoringDeviceDetailsApiSetBlockSyncRequest) BlockSync(blockSync string) MonitoringDeviceDetailsApiSetBlockSyncRequest {
	r.blockSync = &blockSync
	return r
}

func (r MonitoringDeviceDetailsApiSetBlockSyncRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.SetBlockSyncExecute(r)
}

/*
SetBlockSync Method for SetBlockSync

Set collection manager block set flag

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MonitoringDeviceDetailsApiSetBlockSyncRequest
*/
func (a *MonitoringDeviceDetailsApiService) SetBlockSync(ctx context.Context) MonitoringDeviceDetailsApiSetBlockSyncRequest {
	return MonitoringDeviceDetailsApiSetBlockSyncRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *MonitoringDeviceDetailsApiService) SetBlockSyncExecute(r MonitoringDeviceDetailsApiSetBlockSyncRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitoringDeviceDetailsApiService.SetBlockSync")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/blockSync"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.blockSync == nil {
		return localVarReturnValue, nil, reportError("blockSync is required and must be specified")
	}

	localVarQueryParams.Add("blockSync", parameterToString(*r.blockSync, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type MonitoringDeviceDetailsApiSyncAllDevicesMemDBRequest struct {
	ctx context.Context
	ApiService *MonitoringDeviceDetailsApiService
}

func (r MonitoringDeviceDetailsApiSyncAllDevicesMemDBRequest) Execute() (*http.Response, error) {
	return r.ApiService.SyncAllDevicesMemDBExecute(r)
}

/*
SyncAllDevicesMemDB Method for SyncAllDevicesMemDB

Synchronize memory database for all devices

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return MonitoringDeviceDetailsApiSyncAllDevicesMemDBRequest
*/
func (a *MonitoringDeviceDetailsApiService) SyncAllDevicesMemDB(ctx context.Context) MonitoringDeviceDetailsApiSyncAllDevicesMemDBRequest {
	return MonitoringDeviceDetailsApiSyncAllDevicesMemDBRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *MonitoringDeviceDetailsApiService) SyncAllDevicesMemDBExecute(r MonitoringDeviceDetailsApiSyncAllDevicesMemDBRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitoringDeviceDetailsApiService.SyncAllDevicesMemDB")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/syncall/memorydb"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
