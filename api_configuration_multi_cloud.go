/*
Cisco SD-WAN vManage API

The vManage API exposes the functionality of operations maintaining devices and the overlay network

API version: 2.0.0
Contact: vmanage@cisco.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// ConfigurationMultiCloudApiService ConfigurationMultiCloudApi service
type ConfigurationMultiCloudApiService service

type ConfigurationMultiCloudApiAddEdgeGlobalSettingsRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	body *map[string]interface{}
}

// Global setting
func (r ConfigurationMultiCloudApiAddEdgeGlobalSettingsRequest) Body(body map[string]interface{}) ConfigurationMultiCloudApiAddEdgeGlobalSettingsRequest {
	r.body = &body
	return r
}

func (r ConfigurationMultiCloudApiAddEdgeGlobalSettingsRequest) Execute() (*http.Response, error) {
	return r.ApiService.AddEdgeGlobalSettingsExecute(r)
}

/*
AddEdgeGlobalSettings Method for AddEdgeGlobalSettings

Add global settings for Edge provider

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationMultiCloudApiAddEdgeGlobalSettingsRequest
*/
func (a *ConfigurationMultiCloudApiService) AddEdgeGlobalSettings(ctx context.Context) ConfigurationMultiCloudApiAddEdgeGlobalSettingsRequest {
	return ConfigurationMultiCloudApiAddEdgeGlobalSettingsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ConfigurationMultiCloudApiService) AddEdgeGlobalSettingsExecute(r ConfigurationMultiCloudApiAddEdgeGlobalSettingsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.AddEdgeGlobalSettings")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/settings/edge/global"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiAddGlobalSettingsRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	body *map[string]interface{}
}

// Global setting
func (r ConfigurationMultiCloudApiAddGlobalSettingsRequest) Body(body map[string]interface{}) ConfigurationMultiCloudApiAddGlobalSettingsRequest {
	r.body = &body
	return r
}

func (r ConfigurationMultiCloudApiAddGlobalSettingsRequest) Execute() (*http.Response, error) {
	return r.ApiService.AddGlobalSettingsExecute(r)
}

/*
AddGlobalSettings Method for AddGlobalSettings

Acquire ip from resource pool

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationMultiCloudApiAddGlobalSettingsRequest
*/
func (a *ConfigurationMultiCloudApiService) AddGlobalSettings(ctx context.Context) ConfigurationMultiCloudApiAddGlobalSettingsRequest {
	return ConfigurationMultiCloudApiAddGlobalSettingsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ConfigurationMultiCloudApiService) AddGlobalSettingsExecute(r ConfigurationMultiCloudApiAddGlobalSettingsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.AddGlobalSettings")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/settings/global"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiAttachSitesRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	cloudGatewayName string
	body *map[string]interface{}
}

// Site information
func (r ConfigurationMultiCloudApiAttachSitesRequest) Body(body map[string]interface{}) ConfigurationMultiCloudApiAttachSitesRequest {
	r.body = &body
	return r
}

func (r ConfigurationMultiCloudApiAttachSitesRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.AttachSitesExecute(r)
}

/*
AttachSites Method for AttachSites

Attach sites to cloud gateway

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cloudGatewayName Cloud gateway name
 @return ConfigurationMultiCloudApiAttachSitesRequest
*/
func (a *ConfigurationMultiCloudApiService) AttachSites(ctx context.Context, cloudGatewayName string) ConfigurationMultiCloudApiAttachSitesRequest {
	return ConfigurationMultiCloudApiAttachSitesRequest{
		ApiService: a,
		ctx: ctx,
		cloudGatewayName: cloudGatewayName,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) AttachSitesExecute(r ConfigurationMultiCloudApiAttachSitesRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.AttachSites")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/cloudgateway/{cloudGatewayName}/site"
	localVarPath = strings.Replace(localVarPath, "{"+"cloudGatewayName"+"}", url.PathEscape(parameterToString(r.cloudGatewayName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiAuditRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	body *map[string]interface{}
}

// Audit
func (r ConfigurationMultiCloudApiAuditRequest) Body(body map[string]interface{}) ConfigurationMultiCloudApiAuditRequest {
	r.body = &body
	return r
}

func (r ConfigurationMultiCloudApiAuditRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.AuditExecute(r)
}

/*
Audit Method for Audit

Call an audit

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationMultiCloudApiAuditRequest
*/
func (a *ConfigurationMultiCloudApiService) Audit(ctx context.Context) ConfigurationMultiCloudApiAuditRequest {
	return ConfigurationMultiCloudApiAuditRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) AuditExecute(r ConfigurationMultiCloudApiAuditRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.Audit")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/audit"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiAuditDryRunRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	cloudType *string
	cloudRegion *string
}

// Cloud type
func (r ConfigurationMultiCloudApiAuditDryRunRequest) CloudType(cloudType string) ConfigurationMultiCloudApiAuditDryRunRequest {
	r.cloudType = &cloudType
	return r
}

// Region
func (r ConfigurationMultiCloudApiAuditDryRunRequest) CloudRegion(cloudRegion string) ConfigurationMultiCloudApiAuditDryRunRequest {
	r.cloudRegion = &cloudRegion
	return r
}

func (r ConfigurationMultiCloudApiAuditDryRunRequest) Execute() (*http.Response, error) {
	return r.ApiService.AuditDryRunExecute(r)
}

/*
AuditDryRun Method for AuditDryRun

Call an audit with dry run

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationMultiCloudApiAuditDryRunRequest
*/
func (a *ConfigurationMultiCloudApiService) AuditDryRun(ctx context.Context) ConfigurationMultiCloudApiAuditDryRunRequest {
	return ConfigurationMultiCloudApiAuditDryRunRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ConfigurationMultiCloudApiService) AuditDryRunExecute(r ConfigurationMultiCloudApiAuditDryRunRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.AuditDryRun")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/audit"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.cloudType != nil {
		localVarQueryParams.Add("cloudType", parameterToString(*r.cloudType, ""))
	}
	if r.cloudRegion != nil {
		localVarQueryParams.Add("cloudRegion", parameterToString(*r.cloudRegion, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiCleanUpAllConnectivityGatewaysInLocalDBRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	deletionType *string
}

// Deletion Type
func (r ConfigurationMultiCloudApiCleanUpAllConnectivityGatewaysInLocalDBRequest) DeletionType(deletionType string) ConfigurationMultiCloudApiCleanUpAllConnectivityGatewaysInLocalDBRequest {
	r.deletionType = &deletionType
	return r
}

func (r ConfigurationMultiCloudApiCleanUpAllConnectivityGatewaysInLocalDBRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.CleanUpAllConnectivityGatewaysInLocalDBExecute(r)
}

/*
CleanUpAllConnectivityGatewaysInLocalDB Method for CleanUpAllConnectivityGatewaysInLocalDB

Delete all Connectivity Gateways in local DB

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationMultiCloudApiCleanUpAllConnectivityGatewaysInLocalDBRequest
*/
func (a *ConfigurationMultiCloudApiService) CleanUpAllConnectivityGatewaysInLocalDB(ctx context.Context) ConfigurationMultiCloudApiCleanUpAllConnectivityGatewaysInLocalDBRequest {
	return ConfigurationMultiCloudApiCleanUpAllConnectivityGatewaysInLocalDBRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) CleanUpAllConnectivityGatewaysInLocalDBExecute(r ConfigurationMultiCloudApiCleanUpAllConnectivityGatewaysInLocalDBRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.CleanUpAllConnectivityGatewaysInLocalDB")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/connectivitygateway"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.deletionType != nil {
		localVarQueryParams.Add("deletionType", parameterToString(*r.deletionType, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiCreateCgwRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	body *map[string]interface{}
}

// Cloud gateway
func (r ConfigurationMultiCloudApiCreateCgwRequest) Body(body map[string]interface{}) ConfigurationMultiCloudApiCreateCgwRequest {
	r.body = &body
	return r
}

func (r ConfigurationMultiCloudApiCreateCgwRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.CreateCgwExecute(r)
}

/*
CreateCgw Method for CreateCgw

Create cloud gateway

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationMultiCloudApiCreateCgwRequest
*/
func (a *ConfigurationMultiCloudApiService) CreateCgw(ctx context.Context) ConfigurationMultiCloudApiCreateCgwRequest {
	return ConfigurationMultiCloudApiCreateCgwRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) CreateCgwExecute(r ConfigurationMultiCloudApiCreateCgwRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.CreateCgw")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/cloudgateway"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiCreateConnectivityGatewayRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	body *map[string]interface{}
}

// Connectivity gateway
func (r ConfigurationMultiCloudApiCreateConnectivityGatewayRequest) Body(body map[string]interface{}) ConfigurationMultiCloudApiCreateConnectivityGatewayRequest {
	r.body = &body
	return r
}

func (r ConfigurationMultiCloudApiCreateConnectivityGatewayRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.CreateConnectivityGatewayExecute(r)
}

/*
CreateConnectivityGateway Method for CreateConnectivityGateway

Create Connectivity gateway

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationMultiCloudApiCreateConnectivityGatewayRequest
*/
func (a *ConfigurationMultiCloudApiService) CreateConnectivityGateway(ctx context.Context) ConfigurationMultiCloudApiCreateConnectivityGatewayRequest {
	return ConfigurationMultiCloudApiCreateConnectivityGatewayRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) CreateConnectivityGatewayExecute(r ConfigurationMultiCloudApiCreateConnectivityGatewayRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.CreateConnectivityGateway")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/connectivitygateway"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiCreateDeviceLinkRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	body *map[string]interface{}
}

// Device Link
func (r ConfigurationMultiCloudApiCreateDeviceLinkRequest) Body(body map[string]interface{}) ConfigurationMultiCloudApiCreateDeviceLinkRequest {
	r.body = &body
	return r
}

func (r ConfigurationMultiCloudApiCreateDeviceLinkRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.CreateDeviceLinkExecute(r)
}

/*
CreateDeviceLink Method for CreateDeviceLink

Create Device Link

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationMultiCloudApiCreateDeviceLinkRequest
*/
func (a *ConfigurationMultiCloudApiService) CreateDeviceLink(ctx context.Context) ConfigurationMultiCloudApiCreateDeviceLinkRequest {
	return ConfigurationMultiCloudApiCreateDeviceLinkRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) CreateDeviceLinkExecute(r ConfigurationMultiCloudApiCreateDeviceLinkRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.CreateDeviceLink")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/devicelink/edge"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiCreateEdgeConnectivityRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	body *map[string]interface{}
}

// Edge connectivity
func (r ConfigurationMultiCloudApiCreateEdgeConnectivityRequest) Body(body map[string]interface{}) ConfigurationMultiCloudApiCreateEdgeConnectivityRequest {
	r.body = &body
	return r
}

func (r ConfigurationMultiCloudApiCreateEdgeConnectivityRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.CreateEdgeConnectivityExecute(r)
}

/*
CreateEdgeConnectivity Method for CreateEdgeConnectivity

Create Interconnect connectivity

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationMultiCloudApiCreateEdgeConnectivityRequest
*/
func (a *ConfigurationMultiCloudApiService) CreateEdgeConnectivity(ctx context.Context) ConfigurationMultiCloudApiCreateEdgeConnectivityRequest {
	return ConfigurationMultiCloudApiCreateEdgeConnectivityRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) CreateEdgeConnectivityExecute(r ConfigurationMultiCloudApiCreateEdgeConnectivityRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.CreateEdgeConnectivity")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/connectivity/edge"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiCreateIcgwRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	body *map[string]interface{}
}

// Interconnect Gateway
func (r ConfigurationMultiCloudApiCreateIcgwRequest) Body(body map[string]interface{}) ConfigurationMultiCloudApiCreateIcgwRequest {
	r.body = &body
	return r
}

func (r ConfigurationMultiCloudApiCreateIcgwRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.CreateIcgwExecute(r)
}

/*
CreateIcgw Method for CreateIcgw

Create Interconnect Gateway

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationMultiCloudApiCreateIcgwRequest
*/
func (a *ConfigurationMultiCloudApiService) CreateIcgw(ctx context.Context) ConfigurationMultiCloudApiCreateIcgwRequest {
	return ConfigurationMultiCloudApiCreateIcgwRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) CreateIcgwExecute(r ConfigurationMultiCloudApiCreateIcgwRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.CreateIcgw")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/gateway/edge"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiCreateVirtualWanRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	body *map[string]interface{}
}

// Virtual WAN
func (r ConfigurationMultiCloudApiCreateVirtualWanRequest) Body(body map[string]interface{}) ConfigurationMultiCloudApiCreateVirtualWanRequest {
	r.body = &body
	return r
}

func (r ConfigurationMultiCloudApiCreateVirtualWanRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.CreateVirtualWanExecute(r)
}

/*
CreateVirtualWan Method for CreateVirtualWan

Create Virtual WAN

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationMultiCloudApiCreateVirtualWanRequest
*/
func (a *ConfigurationMultiCloudApiService) CreateVirtualWan(ctx context.Context) ConfigurationMultiCloudApiCreateVirtualWanRequest {
	return ConfigurationMultiCloudApiCreateVirtualWanRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) CreateVirtualWanExecute(r ConfigurationMultiCloudApiCreateVirtualWanRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.CreateVirtualWan")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/vwan"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiDeleteAccountRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	accountId string
}

func (r ConfigurationMultiCloudApiDeleteAccountRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteAccountExecute(r)
}

/*
DeleteAccount Method for DeleteAccount

Delete cloud account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId Account Id
 @return ConfigurationMultiCloudApiDeleteAccountRequest
*/
func (a *ConfigurationMultiCloudApiService) DeleteAccount(ctx context.Context, accountId string) ConfigurationMultiCloudApiDeleteAccountRequest {
	return ConfigurationMultiCloudApiDeleteAccountRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
	}
}

// Execute executes the request
func (a *ConfigurationMultiCloudApiService) DeleteAccountExecute(r ConfigurationMultiCloudApiDeleteAccountRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.DeleteAccount")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/accounts/{accountId}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterToString(r.accountId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiDeleteCgwRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	cloudGatewayName string
	deleteAllResources *bool
}

// Optional Flag for deletion of Azure Resource Group, Default: True
func (r ConfigurationMultiCloudApiDeleteCgwRequest) DeleteAllResources(deleteAllResources bool) ConfigurationMultiCloudApiDeleteCgwRequest {
	r.deleteAllResources = &deleteAllResources
	return r
}

func (r ConfigurationMultiCloudApiDeleteCgwRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.DeleteCgwExecute(r)
}

/*
DeleteCgw Method for DeleteCgw

Delete cloud gateway

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cloudGatewayName Cloud gateway name
 @return ConfigurationMultiCloudApiDeleteCgwRequest
*/
func (a *ConfigurationMultiCloudApiService) DeleteCgw(ctx context.Context, cloudGatewayName string) ConfigurationMultiCloudApiDeleteCgwRequest {
	return ConfigurationMultiCloudApiDeleteCgwRequest{
		ApiService: a,
		ctx: ctx,
		cloudGatewayName: cloudGatewayName,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) DeleteCgwExecute(r ConfigurationMultiCloudApiDeleteCgwRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.DeleteCgw")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/cloudgateway/{cloudGatewayName}"
	localVarPath = strings.Replace(localVarPath, "{"+"cloudGatewayName"+"}", url.PathEscape(parameterToString(r.cloudGatewayName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.deleteAllResources != nil {
		localVarQueryParams.Add("deleteAllResources", parameterToString(*r.deleteAllResources, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiDeleteConnectivityGatewayRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	cloudProvider string
	connectivityGatewayName string
	connectivityType *string
}

// Cloud Connectivity Type
func (r ConfigurationMultiCloudApiDeleteConnectivityGatewayRequest) ConnectivityType(connectivityType string) ConfigurationMultiCloudApiDeleteConnectivityGatewayRequest {
	r.connectivityType = &connectivityType
	return r
}

func (r ConfigurationMultiCloudApiDeleteConnectivityGatewayRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.DeleteConnectivityGatewayExecute(r)
}

/*
DeleteConnectivityGateway Method for DeleteConnectivityGateway

Delete Connectivity Gateway

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cloudProvider Cloud Provider
 @param connectivityGatewayName Connectivity gateway name
 @return ConfigurationMultiCloudApiDeleteConnectivityGatewayRequest
*/
func (a *ConfigurationMultiCloudApiService) DeleteConnectivityGateway(ctx context.Context, cloudProvider string, connectivityGatewayName string) ConfigurationMultiCloudApiDeleteConnectivityGatewayRequest {
	return ConfigurationMultiCloudApiDeleteConnectivityGatewayRequest{
		ApiService: a,
		ctx: ctx,
		cloudProvider: cloudProvider,
		connectivityGatewayName: connectivityGatewayName,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) DeleteConnectivityGatewayExecute(r ConfigurationMultiCloudApiDeleteConnectivityGatewayRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.DeleteConnectivityGateway")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/connectivitygateway/{cloudProvider}/{connectivityGatewayName}"
	localVarPath = strings.Replace(localVarPath, "{"+"cloudProvider"+"}", url.PathEscape(parameterToString(r.cloudProvider, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"connectivityGatewayName"+"}", url.PathEscape(parameterToString(r.connectivityGatewayName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.connectivityType != nil {
		localVarQueryParams.Add("connectivityType", parameterToString(*r.connectivityType, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiDeleteDeviceLinkRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	deviceLinkName string
}

func (r ConfigurationMultiCloudApiDeleteDeviceLinkRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.DeleteDeviceLinkExecute(r)
}

/*
DeleteDeviceLink Method for DeleteDeviceLink

Delete Device Link

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceLinkName Device Link Name
 @return ConfigurationMultiCloudApiDeleteDeviceLinkRequest
*/
func (a *ConfigurationMultiCloudApiService) DeleteDeviceLink(ctx context.Context, deviceLinkName string) ConfigurationMultiCloudApiDeleteDeviceLinkRequest {
	return ConfigurationMultiCloudApiDeleteDeviceLinkRequest{
		ApiService: a,
		ctx: ctx,
		deviceLinkName: deviceLinkName,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) DeleteDeviceLinkExecute(r ConfigurationMultiCloudApiDeleteDeviceLinkRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.DeleteDeviceLink")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/devicelink/edge/{deviceLinkName}"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceLinkName"+"}", url.PathEscape(parameterToString(r.deviceLinkName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiDeleteEdgeAccountRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	accountId string
}

func (r ConfigurationMultiCloudApiDeleteEdgeAccountRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteEdgeAccountExecute(r)
}

/*
DeleteEdgeAccount Method for DeleteEdgeAccount

Delete edge account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId Edge Account Id
 @return ConfigurationMultiCloudApiDeleteEdgeAccountRequest
*/
func (a *ConfigurationMultiCloudApiService) DeleteEdgeAccount(ctx context.Context, accountId string) ConfigurationMultiCloudApiDeleteEdgeAccountRequest {
	return ConfigurationMultiCloudApiDeleteEdgeAccountRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
	}
}

// Execute executes the request
func (a *ConfigurationMultiCloudApiService) DeleteEdgeAccountExecute(r ConfigurationMultiCloudApiDeleteEdgeAccountRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.DeleteEdgeAccount")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/accounts/edge/{accountId}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterToString(r.accountId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiDeleteEdgeAccount1Request struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	edgeType string
}

func (r ConfigurationMultiCloudApiDeleteEdgeAccount1Request) Execute() (*http.Response, error) {
	return r.ApiService.DeleteEdgeAccount1Execute(r)
}

/*
DeleteEdgeAccount1 Method for DeleteEdgeAccount1

Delete edge account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param edgeType Edge Type
 @return ConfigurationMultiCloudApiDeleteEdgeAccount1Request
*/
func (a *ConfigurationMultiCloudApiService) DeleteEdgeAccount1(ctx context.Context, edgeType string) ConfigurationMultiCloudApiDeleteEdgeAccount1Request {
	return ConfigurationMultiCloudApiDeleteEdgeAccount1Request{
		ApiService: a,
		ctx: ctx,
		edgeType: edgeType,
	}
}

// Execute executes the request
func (a *ConfigurationMultiCloudApiService) DeleteEdgeAccount1Execute(r ConfigurationMultiCloudApiDeleteEdgeAccount1Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.DeleteEdgeAccount1")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/locations/edge/{edgeType}"
	localVarPath = strings.Replace(localVarPath, "{"+"edgeType"+"}", url.PathEscape(parameterToString(r.edgeType, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiDeleteEdgeConnectivityRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	connectionName string
}

func (r ConfigurationMultiCloudApiDeleteEdgeConnectivityRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.DeleteEdgeConnectivityExecute(r)
}

/*
DeleteEdgeConnectivity Method for DeleteEdgeConnectivity

Delete Interconnect connectivity

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param connectionName Edge connectivity name
 @return ConfigurationMultiCloudApiDeleteEdgeConnectivityRequest
*/
func (a *ConfigurationMultiCloudApiService) DeleteEdgeConnectivity(ctx context.Context, connectionName string) ConfigurationMultiCloudApiDeleteEdgeConnectivityRequest {
	return ConfigurationMultiCloudApiDeleteEdgeConnectivityRequest{
		ApiService: a,
		ctx: ctx,
		connectionName: connectionName,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) DeleteEdgeConnectivityExecute(r ConfigurationMultiCloudApiDeleteEdgeConnectivityRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.DeleteEdgeConnectivity")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/connectivity/edge/{connectionName}"
	localVarPath = strings.Replace(localVarPath, "{"+"connectionName"+"}", url.PathEscape(parameterToString(r.connectionName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiDeleteIcgwRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	edgeGatewayName string
}

func (r ConfigurationMultiCloudApiDeleteIcgwRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.DeleteIcgwExecute(r)
}

/*
DeleteIcgw Method for DeleteIcgw

Delete Interconnect Gateway

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param edgeGatewayName Edge gateway name
 @return ConfigurationMultiCloudApiDeleteIcgwRequest
*/
func (a *ConfigurationMultiCloudApiService) DeleteIcgw(ctx context.Context, edgeGatewayName string) ConfigurationMultiCloudApiDeleteIcgwRequest {
	return ConfigurationMultiCloudApiDeleteIcgwRequest{
		ApiService: a,
		ctx: ctx,
		edgeGatewayName: edgeGatewayName,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) DeleteIcgwExecute(r ConfigurationMultiCloudApiDeleteIcgwRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.DeleteIcgw")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/gateway/edge/{edgeGatewayName}"
	localVarPath = strings.Replace(localVarPath, "{"+"edgeGatewayName"+"}", url.PathEscape(parameterToString(r.edgeGatewayName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiDeleteVirtualWanRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	cloudProvider string
	vWanName string
	accountId *string
	resourceGroup *string
}

// Account Id
func (r ConfigurationMultiCloudApiDeleteVirtualWanRequest) AccountId(accountId string) ConfigurationMultiCloudApiDeleteVirtualWanRequest {
	r.accountId = &accountId
	return r
}

// Resource Group
func (r ConfigurationMultiCloudApiDeleteVirtualWanRequest) ResourceGroup(resourceGroup string) ConfigurationMultiCloudApiDeleteVirtualWanRequest {
	r.resourceGroup = &resourceGroup
	return r
}

func (r ConfigurationMultiCloudApiDeleteVirtualWanRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.DeleteVirtualWanExecute(r)
}

/*
DeleteVirtualWan Method for DeleteVirtualWan

Delete Virtual Wan

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cloudProvider Cloud Provider
 @param vWanName Virtual Wan name
 @return ConfigurationMultiCloudApiDeleteVirtualWanRequest
*/
func (a *ConfigurationMultiCloudApiService) DeleteVirtualWan(ctx context.Context, cloudProvider string, vWanName string) ConfigurationMultiCloudApiDeleteVirtualWanRequest {
	return ConfigurationMultiCloudApiDeleteVirtualWanRequest{
		ApiService: a,
		ctx: ctx,
		cloudProvider: cloudProvider,
		vWanName: vWanName,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) DeleteVirtualWanExecute(r ConfigurationMultiCloudApiDeleteVirtualWanRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.DeleteVirtualWan")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/vwan/{cloudProvider}/{vWanName}"
	localVarPath = strings.Replace(localVarPath, "{"+"cloudProvider"+"}", url.PathEscape(parameterToString(r.cloudProvider, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vWanName"+"}", url.PathEscape(parameterToString(r.vWanName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.accountId != nil {
		localVarQueryParams.Add("accountId", parameterToString(*r.accountId, ""))
	}
	if r.resourceGroup != nil {
		localVarQueryParams.Add("resourceGroup", parameterToString(*r.resourceGroup, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiDetachSites1Request struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	cloudGatewayName string
	body *map[string]interface{}
}

// Site information
func (r ConfigurationMultiCloudApiDetachSites1Request) Body(body map[string]interface{}) ConfigurationMultiCloudApiDetachSites1Request {
	r.body = &body
	return r
}

func (r ConfigurationMultiCloudApiDetachSites1Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.DetachSites1Execute(r)
}

/*
DetachSites1 Method for DetachSites1

Detach sites from cloud gateway

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cloudGatewayName Cloud gateway name
 @return ConfigurationMultiCloudApiDetachSites1Request
*/
func (a *ConfigurationMultiCloudApiService) DetachSites1(ctx context.Context, cloudGatewayName string) ConfigurationMultiCloudApiDetachSites1Request {
	return ConfigurationMultiCloudApiDetachSites1Request{
		ApiService: a,
		ctx: ctx,
		cloudGatewayName: cloudGatewayName,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) DetachSites1Execute(r ConfigurationMultiCloudApiDetachSites1Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.DetachSites1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/cloudgateway/{cloudGatewayName}/site"
	localVarPath = strings.Replace(localVarPath, "{"+"cloudGatewayName"+"}", url.PathEscape(parameterToString(r.cloudGatewayName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiEdgeAuditRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	edgeType *string
	cloudType *string
}

// Edge type
func (r ConfigurationMultiCloudApiEdgeAuditRequest) EdgeType(edgeType string) ConfigurationMultiCloudApiEdgeAuditRequest {
	r.edgeType = &edgeType
	return r
}

// Cloud type
func (r ConfigurationMultiCloudApiEdgeAuditRequest) CloudType(cloudType string) ConfigurationMultiCloudApiEdgeAuditRequest {
	r.cloudType = &cloudType
	return r
}

func (r ConfigurationMultiCloudApiEdgeAuditRequest) Execute() (*http.Response, error) {
	return r.ApiService.EdgeAuditExecute(r)
}

/*
EdgeAudit Method for EdgeAudit

Call an edge audit

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationMultiCloudApiEdgeAuditRequest
*/
func (a *ConfigurationMultiCloudApiService) EdgeAudit(ctx context.Context) ConfigurationMultiCloudApiEdgeAuditRequest {
	return ConfigurationMultiCloudApiEdgeAuditRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ConfigurationMultiCloudApiService) EdgeAuditExecute(r ConfigurationMultiCloudApiEdgeAuditRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.EdgeAudit")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/audit/edge"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.edgeType != nil {
		localVarQueryParams.Add("edgeType", parameterToString(*r.edgeType, ""))
	}
	if r.cloudType != nil {
		localVarQueryParams.Add("cloudType", parameterToString(*r.cloudType, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiEdgeAuditDryRunRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	edgeType *string
	cloudType *string
}

// Edge type
func (r ConfigurationMultiCloudApiEdgeAuditDryRunRequest) EdgeType(edgeType string) ConfigurationMultiCloudApiEdgeAuditDryRunRequest {
	r.edgeType = &edgeType
	return r
}

// Cloud type
func (r ConfigurationMultiCloudApiEdgeAuditDryRunRequest) CloudType(cloudType string) ConfigurationMultiCloudApiEdgeAuditDryRunRequest {
	r.cloudType = &cloudType
	return r
}

func (r ConfigurationMultiCloudApiEdgeAuditDryRunRequest) Execute() (*http.Response, error) {
	return r.ApiService.EdgeAuditDryRunExecute(r)
}

/*
EdgeAuditDryRun Method for EdgeAuditDryRun

Call an edge audit with dry run

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationMultiCloudApiEdgeAuditDryRunRequest
*/
func (a *ConfigurationMultiCloudApiService) EdgeAuditDryRun(ctx context.Context) ConfigurationMultiCloudApiEdgeAuditDryRunRequest {
	return ConfigurationMultiCloudApiEdgeAuditDryRunRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ConfigurationMultiCloudApiService) EdgeAuditDryRunExecute(r ConfigurationMultiCloudApiEdgeAuditDryRunRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.EdgeAuditDryRun")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/audit/edge"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.edgeType != nil {
		localVarQueryParams.Add("edgeType", parameterToString(*r.edgeType, ""))
	}
	if r.cloudType != nil {
		localVarQueryParams.Add("cloudType", parameterToString(*r.cloudType, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiEditTagRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	body *map[string]interface{}
}

// VPC tag
func (r ConfigurationMultiCloudApiEditTagRequest) Body(body map[string]interface{}) ConfigurationMultiCloudApiEditTagRequest {
	r.body = &body
	return r
}

func (r ConfigurationMultiCloudApiEditTagRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.EditTagExecute(r)
}

/*
EditTag Method for EditTag

Edit VPCs for a tag

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationMultiCloudApiEditTagRequest
*/
func (a *ConfigurationMultiCloudApiService) EditTag(ctx context.Context) ConfigurationMultiCloudApiEditTagRequest {
	return ConfigurationMultiCloudApiEditTagRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) EditTagExecute(r ConfigurationMultiCloudApiEditTagRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.EditTag")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/hostvpc/tags"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiGetAllCloudAccountsRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	cloudType *string
	cloudGatewayEnabled *bool
}

// Cloud type
func (r ConfigurationMultiCloudApiGetAllCloudAccountsRequest) CloudType(cloudType string) ConfigurationMultiCloudApiGetAllCloudAccountsRequest {
	r.cloudType = &cloudType
	return r
}

// Cloud gateway enabled flag
func (r ConfigurationMultiCloudApiGetAllCloudAccountsRequest) CloudGatewayEnabled(cloudGatewayEnabled bool) ConfigurationMultiCloudApiGetAllCloudAccountsRequest {
	r.cloudGatewayEnabled = &cloudGatewayEnabled
	return r
}

func (r ConfigurationMultiCloudApiGetAllCloudAccountsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetAllCloudAccountsExecute(r)
}

/*
GetAllCloudAccounts Method for GetAllCloudAccounts

Get All cloud accounts

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationMultiCloudApiGetAllCloudAccountsRequest
*/
func (a *ConfigurationMultiCloudApiService) GetAllCloudAccounts(ctx context.Context) ConfigurationMultiCloudApiGetAllCloudAccountsRequest {
	return ConfigurationMultiCloudApiGetAllCloudAccountsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetAllCloudAccountsExecute(r ConfigurationMultiCloudApiGetAllCloudAccountsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetAllCloudAccounts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/accounts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.cloudType != nil {
		localVarQueryParams.Add("cloudType", parameterToString(*r.cloudType, ""))
	}
	if r.cloudGatewayEnabled != nil {
		localVarQueryParams.Add("cloudGatewayEnabled", parameterToString(*r.cloudGatewayEnabled, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiGetAzureNetworkVirtualAppliancesRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	cloudType *string
	accoundId *string
	region *string
	resourceGroupName *string
	resourceGroupSource *string
	vhubName *string
	vhubSource *string
}

// Cloud type
func (r ConfigurationMultiCloudApiGetAzureNetworkVirtualAppliancesRequest) CloudType(cloudType string) ConfigurationMultiCloudApiGetAzureNetworkVirtualAppliancesRequest {
	r.cloudType = &cloudType
	return r
}

// Account ID
func (r ConfigurationMultiCloudApiGetAzureNetworkVirtualAppliancesRequest) AccoundId(accoundId string) ConfigurationMultiCloudApiGetAzureNetworkVirtualAppliancesRequest {
	r.accoundId = &accoundId
	return r
}

// Region
func (r ConfigurationMultiCloudApiGetAzureNetworkVirtualAppliancesRequest) Region(region string) ConfigurationMultiCloudApiGetAzureNetworkVirtualAppliancesRequest {
	r.region = &region
	return r
}

// Resource Group Name
func (r ConfigurationMultiCloudApiGetAzureNetworkVirtualAppliancesRequest) ResourceGroupName(resourceGroupName string) ConfigurationMultiCloudApiGetAzureNetworkVirtualAppliancesRequest {
	r.resourceGroupName = &resourceGroupName
	return r
}

// Resource Group Source
func (r ConfigurationMultiCloudApiGetAzureNetworkVirtualAppliancesRequest) ResourceGroupSource(resourceGroupSource string) ConfigurationMultiCloudApiGetAzureNetworkVirtualAppliancesRequest {
	r.resourceGroupSource = &resourceGroupSource
	return r
}

// VHUB name
func (r ConfigurationMultiCloudApiGetAzureNetworkVirtualAppliancesRequest) VhubName(vhubName string) ConfigurationMultiCloudApiGetAzureNetworkVirtualAppliancesRequest {
	r.vhubName = &vhubName
	return r
}

// VHUB source
func (r ConfigurationMultiCloudApiGetAzureNetworkVirtualAppliancesRequest) VhubSource(vhubSource string) ConfigurationMultiCloudApiGetAzureNetworkVirtualAppliancesRequest {
	r.vhubSource = &vhubSource
	return r
}

func (r ConfigurationMultiCloudApiGetAzureNetworkVirtualAppliancesRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetAzureNetworkVirtualAppliancesExecute(r)
}

/*
GetAzureNetworkVirtualAppliances Method for GetAzureNetworkVirtualAppliances

Discover Azure Virtual NVAs

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationMultiCloudApiGetAzureNetworkVirtualAppliancesRequest
*/
func (a *ConfigurationMultiCloudApiService) GetAzureNetworkVirtualAppliances(ctx context.Context) ConfigurationMultiCloudApiGetAzureNetworkVirtualAppliancesRequest {
	return ConfigurationMultiCloudApiGetAzureNetworkVirtualAppliancesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetAzureNetworkVirtualAppliancesExecute(r ConfigurationMultiCloudApiGetAzureNetworkVirtualAppliancesRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetAzureNetworkVirtualAppliances")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/cloudgateway/nvas"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.cloudType == nil {
		return localVarReturnValue, nil, reportError("cloudType is required and must be specified")
	}
	if r.accoundId == nil {
		return localVarReturnValue, nil, reportError("accoundId is required and must be specified")
	}
	if r.region == nil {
		return localVarReturnValue, nil, reportError("region is required and must be specified")
	}
	if r.resourceGroupName == nil {
		return localVarReturnValue, nil, reportError("resourceGroupName is required and must be specified")
	}
	if r.resourceGroupSource == nil {
		return localVarReturnValue, nil, reportError("resourceGroupSource is required and must be specified")
	}
	if r.vhubName == nil {
		return localVarReturnValue, nil, reportError("vhubName is required and must be specified")
	}
	if r.vhubSource == nil {
		return localVarReturnValue, nil, reportError("vhubSource is required and must be specified")
	}

	localVarQueryParams.Add("cloudType", parameterToString(*r.cloudType, ""))
	localVarQueryParams.Add("accoundId", parameterToString(*r.accoundId, ""))
	localVarQueryParams.Add("region", parameterToString(*r.region, ""))
	localVarQueryParams.Add("resourceGroupName", parameterToString(*r.resourceGroupName, ""))
	localVarQueryParams.Add("resourceGroupSource", parameterToString(*r.resourceGroupSource, ""))
	localVarQueryParams.Add("vhubName", parameterToString(*r.vhubName, ""))
	localVarQueryParams.Add("vhubSource", parameterToString(*r.vhubSource, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiGetAzureNvaSkuListRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
}

func (r ConfigurationMultiCloudApiGetAzureNvaSkuListRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetAzureNvaSkuListExecute(r)
}

/*
GetAzureNvaSkuList Method for GetAzureNvaSkuList

Get Azure NVA SKUs

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationMultiCloudApiGetAzureNvaSkuListRequest
*/
func (a *ConfigurationMultiCloudApiService) GetAzureNvaSkuList(ctx context.Context) ConfigurationMultiCloudApiGetAzureNvaSkuListRequest {
	return ConfigurationMultiCloudApiGetAzureNvaSkuListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetAzureNvaSkuListExecute(r ConfigurationMultiCloudApiGetAzureNvaSkuListRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetAzureNvaSkuList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/cloudgateway/nvasku"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiGetAzureResourceGroupsRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	cloudType *string
	accountId *string
}

// Cloud type
func (r ConfigurationMultiCloudApiGetAzureResourceGroupsRequest) CloudType(cloudType string) ConfigurationMultiCloudApiGetAzureResourceGroupsRequest {
	r.cloudType = &cloudType
	return r
}

// Account ID
func (r ConfigurationMultiCloudApiGetAzureResourceGroupsRequest) AccountId(accountId string) ConfigurationMultiCloudApiGetAzureResourceGroupsRequest {
	r.accountId = &accountId
	return r
}

func (r ConfigurationMultiCloudApiGetAzureResourceGroupsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetAzureResourceGroupsExecute(r)
}

/*
GetAzureResourceGroups Method for GetAzureResourceGroups

Discover Azure Resource Groups

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationMultiCloudApiGetAzureResourceGroupsRequest
*/
func (a *ConfigurationMultiCloudApiService) GetAzureResourceGroups(ctx context.Context) ConfigurationMultiCloudApiGetAzureResourceGroupsRequest {
	return ConfigurationMultiCloudApiGetAzureResourceGroupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetAzureResourceGroupsExecute(r ConfigurationMultiCloudApiGetAzureResourceGroupsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetAzureResourceGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/cloudgateway/resourceGroups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.cloudType == nil {
		return localVarReturnValue, nil, reportError("cloudType is required and must be specified")
	}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}

	localVarQueryParams.Add("cloudType", parameterToString(*r.cloudType, ""))
	localVarQueryParams.Add("accountId", parameterToString(*r.accountId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiGetAzureVirtualHubsRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	cloudType *string
	accoundId *string
	region *string
	resourceGroupName *string
	resourceGroupSource *string
	vwanName *string
	vwanSource *string
}

// Cloud type
func (r ConfigurationMultiCloudApiGetAzureVirtualHubsRequest) CloudType(cloudType string) ConfigurationMultiCloudApiGetAzureVirtualHubsRequest {
	r.cloudType = &cloudType
	return r
}

// Account ID
func (r ConfigurationMultiCloudApiGetAzureVirtualHubsRequest) AccoundId(accoundId string) ConfigurationMultiCloudApiGetAzureVirtualHubsRequest {
	r.accoundId = &accoundId
	return r
}

// Region
func (r ConfigurationMultiCloudApiGetAzureVirtualHubsRequest) Region(region string) ConfigurationMultiCloudApiGetAzureVirtualHubsRequest {
	r.region = &region
	return r
}

// Resource Group Name
func (r ConfigurationMultiCloudApiGetAzureVirtualHubsRequest) ResourceGroupName(resourceGroupName string) ConfigurationMultiCloudApiGetAzureVirtualHubsRequest {
	r.resourceGroupName = &resourceGroupName
	return r
}

// Resource Group Source
func (r ConfigurationMultiCloudApiGetAzureVirtualHubsRequest) ResourceGroupSource(resourceGroupSource string) ConfigurationMultiCloudApiGetAzureVirtualHubsRequest {
	r.resourceGroupSource = &resourceGroupSource
	return r
}

// VWAN name
func (r ConfigurationMultiCloudApiGetAzureVirtualHubsRequest) VwanName(vwanName string) ConfigurationMultiCloudApiGetAzureVirtualHubsRequest {
	r.vwanName = &vwanName
	return r
}

// VWAN source
func (r ConfigurationMultiCloudApiGetAzureVirtualHubsRequest) VwanSource(vwanSource string) ConfigurationMultiCloudApiGetAzureVirtualHubsRequest {
	r.vwanSource = &vwanSource
	return r
}

func (r ConfigurationMultiCloudApiGetAzureVirtualHubsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetAzureVirtualHubsExecute(r)
}

/*
GetAzureVirtualHubs Method for GetAzureVirtualHubs

Discover Azure Virtual HUBs

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationMultiCloudApiGetAzureVirtualHubsRequest
*/
func (a *ConfigurationMultiCloudApiService) GetAzureVirtualHubs(ctx context.Context) ConfigurationMultiCloudApiGetAzureVirtualHubsRequest {
	return ConfigurationMultiCloudApiGetAzureVirtualHubsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetAzureVirtualHubsExecute(r ConfigurationMultiCloudApiGetAzureVirtualHubsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetAzureVirtualHubs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/cloudgateway/vhubs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.cloudType == nil {
		return localVarReturnValue, nil, reportError("cloudType is required and must be specified")
	}
	if r.accoundId == nil {
		return localVarReturnValue, nil, reportError("accoundId is required and must be specified")
	}
	if r.region == nil {
		return localVarReturnValue, nil, reportError("region is required and must be specified")
	}
	if r.resourceGroupName == nil {
		return localVarReturnValue, nil, reportError("resourceGroupName is required and must be specified")
	}
	if r.resourceGroupSource == nil {
		return localVarReturnValue, nil, reportError("resourceGroupSource is required and must be specified")
	}
	if r.vwanName == nil {
		return localVarReturnValue, nil, reportError("vwanName is required and must be specified")
	}
	if r.vwanSource == nil {
		return localVarReturnValue, nil, reportError("vwanSource is required and must be specified")
	}

	localVarQueryParams.Add("cloudType", parameterToString(*r.cloudType, ""))
	localVarQueryParams.Add("accoundId", parameterToString(*r.accoundId, ""))
	localVarQueryParams.Add("region", parameterToString(*r.region, ""))
	localVarQueryParams.Add("resourceGroupName", parameterToString(*r.resourceGroupName, ""))
	localVarQueryParams.Add("resourceGroupSource", parameterToString(*r.resourceGroupSource, ""))
	localVarQueryParams.Add("vwanName", parameterToString(*r.vwanName, ""))
	localVarQueryParams.Add("vwanSource", parameterToString(*r.vwanSource, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiGetAzureVirtualWansRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	cloudType *string
	accoundId *string
	resourceGroupName *string
	resourceGroupSource *string
}

// Cloud type
func (r ConfigurationMultiCloudApiGetAzureVirtualWansRequest) CloudType(cloudType string) ConfigurationMultiCloudApiGetAzureVirtualWansRequest {
	r.cloudType = &cloudType
	return r
}

// Account ID
func (r ConfigurationMultiCloudApiGetAzureVirtualWansRequest) AccoundId(accoundId string) ConfigurationMultiCloudApiGetAzureVirtualWansRequest {
	r.accoundId = &accoundId
	return r
}

// Resource Group Name
func (r ConfigurationMultiCloudApiGetAzureVirtualWansRequest) ResourceGroupName(resourceGroupName string) ConfigurationMultiCloudApiGetAzureVirtualWansRequest {
	r.resourceGroupName = &resourceGroupName
	return r
}

// Resource Group Source
func (r ConfigurationMultiCloudApiGetAzureVirtualWansRequest) ResourceGroupSource(resourceGroupSource string) ConfigurationMultiCloudApiGetAzureVirtualWansRequest {
	r.resourceGroupSource = &resourceGroupSource
	return r
}

func (r ConfigurationMultiCloudApiGetAzureVirtualWansRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetAzureVirtualWansExecute(r)
}

/*
GetAzureVirtualWans Method for GetAzureVirtualWans

Discover Azure Virtual WANs

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationMultiCloudApiGetAzureVirtualWansRequest
*/
func (a *ConfigurationMultiCloudApiService) GetAzureVirtualWans(ctx context.Context) ConfigurationMultiCloudApiGetAzureVirtualWansRequest {
	return ConfigurationMultiCloudApiGetAzureVirtualWansRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetAzureVirtualWansExecute(r ConfigurationMultiCloudApiGetAzureVirtualWansRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetAzureVirtualWans")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/cloudgateway/vwans"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.cloudType == nil {
		return localVarReturnValue, nil, reportError("cloudType is required and must be specified")
	}
	if r.accoundId == nil {
		return localVarReturnValue, nil, reportError("accoundId is required and must be specified")
	}
	if r.resourceGroupName == nil {
		return localVarReturnValue, nil, reportError("resourceGroupName is required and must be specified")
	}
	if r.resourceGroupSource == nil {
		return localVarReturnValue, nil, reportError("resourceGroupSource is required and must be specified")
	}

	localVarQueryParams.Add("cloudType", parameterToString(*r.cloudType, ""))
	localVarQueryParams.Add("accoundId", parameterToString(*r.accoundId, ""))
	localVarQueryParams.Add("resourceGroupName", parameterToString(*r.resourceGroupName, ""))
	localVarQueryParams.Add("resourceGroupSource", parameterToString(*r.resourceGroupSource, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiGetCgwAssociatedMappingsRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	cloudType string
	cloudGatewayName *string
	siteUuid *string
}

// Cloud Gateway Name
func (r ConfigurationMultiCloudApiGetCgwAssociatedMappingsRequest) CloudGatewayName(cloudGatewayName string) ConfigurationMultiCloudApiGetCgwAssociatedMappingsRequest {
	r.cloudGatewayName = &cloudGatewayName
	return r
}

// Site Device UUID
func (r ConfigurationMultiCloudApiGetCgwAssociatedMappingsRequest) SiteUuid(siteUuid string) ConfigurationMultiCloudApiGetCgwAssociatedMappingsRequest {
	r.siteUuid = &siteUuid
	return r
}

func (r ConfigurationMultiCloudApiGetCgwAssociatedMappingsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetCgwAssociatedMappingsExecute(r)
}

/*
GetCgwAssociatedMappings Method for GetCgwAssociatedMappings

Get associated mappings to the CGW

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cloudType Cloud type
 @return ConfigurationMultiCloudApiGetCgwAssociatedMappingsRequest
*/
func (a *ConfigurationMultiCloudApiService) GetCgwAssociatedMappings(ctx context.Context, cloudType string) ConfigurationMultiCloudApiGetCgwAssociatedMappingsRequest {
	return ConfigurationMultiCloudApiGetCgwAssociatedMappingsRequest{
		ApiService: a,
		ctx: ctx,
		cloudType: cloudType,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetCgwAssociatedMappingsExecute(r ConfigurationMultiCloudApiGetCgwAssociatedMappingsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetCgwAssociatedMappings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/mapping/{cloudType}"
	localVarPath = strings.Replace(localVarPath, "{"+"cloudType"+"}", url.PathEscape(parameterToString(r.cloudType, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.cloudGatewayName == nil {
		return localVarReturnValue, nil, reportError("cloudGatewayName is required and must be specified")
	}

	localVarQueryParams.Add("cloudGatewayName", parameterToString(*r.cloudGatewayName, ""))
	if r.siteUuid != nil {
		localVarQueryParams.Add("siteUuid", parameterToString(*r.siteUuid, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiGetCgwCustomSettingDetailsRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	cloudGatewayName string
}

func (r ConfigurationMultiCloudApiGetCgwCustomSettingDetailsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetCgwCustomSettingDetailsExecute(r)
}

/*
GetCgwCustomSettingDetails Method for GetCgwCustomSettingDetails

Get cloud gateway custom setting by cloud gateway name

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cloudGatewayName Cloud gateway name
 @return ConfigurationMultiCloudApiGetCgwCustomSettingDetailsRequest
*/
func (a *ConfigurationMultiCloudApiService) GetCgwCustomSettingDetails(ctx context.Context, cloudGatewayName string) ConfigurationMultiCloudApiGetCgwCustomSettingDetailsRequest {
	return ConfigurationMultiCloudApiGetCgwCustomSettingDetailsRequest{
		ApiService: a,
		ctx: ctx,
		cloudGatewayName: cloudGatewayName,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetCgwCustomSettingDetailsExecute(r ConfigurationMultiCloudApiGetCgwCustomSettingDetailsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetCgwCustomSettingDetails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/cloudgatewaysetting/{cloudGatewayName}"
	localVarPath = strings.Replace(localVarPath, "{"+"cloudGatewayName"+"}", url.PathEscape(parameterToString(r.cloudGatewayName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiGetCgwDetailsRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	cloudGatewayName string
}

func (r ConfigurationMultiCloudApiGetCgwDetailsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetCgwDetailsExecute(r)
}

/*
GetCgwDetails Method for GetCgwDetails

Get cloud gateway by name

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cloudGatewayName Cloud gateway name
 @return ConfigurationMultiCloudApiGetCgwDetailsRequest
*/
func (a *ConfigurationMultiCloudApiService) GetCgwDetails(ctx context.Context, cloudGatewayName string) ConfigurationMultiCloudApiGetCgwDetailsRequest {
	return ConfigurationMultiCloudApiGetCgwDetailsRequest{
		ApiService: a,
		ctx: ctx,
		cloudGatewayName: cloudGatewayName,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetCgwDetailsExecute(r ConfigurationMultiCloudApiGetCgwDetailsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetCgwDetails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/cloudgateway/{cloudGatewayName}"
	localVarPath = strings.Replace(localVarPath, "{"+"cloudGatewayName"+"}", url.PathEscape(parameterToString(r.cloudGatewayName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiGetCgwOrgResourcesRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	cloudGatewayName *string
}

// Cloud gateway name
func (r ConfigurationMultiCloudApiGetCgwOrgResourcesRequest) CloudGatewayName(cloudGatewayName string) ConfigurationMultiCloudApiGetCgwOrgResourcesRequest {
	r.cloudGatewayName = &cloudGatewayName
	return r
}

func (r ConfigurationMultiCloudApiGetCgwOrgResourcesRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetCgwOrgResourcesExecute(r)
}

/*
GetCgwOrgResources Method for GetCgwOrgResources

Get cloud gateways

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationMultiCloudApiGetCgwOrgResourcesRequest
*/
func (a *ConfigurationMultiCloudApiService) GetCgwOrgResources(ctx context.Context) ConfigurationMultiCloudApiGetCgwOrgResourcesRequest {
	return ConfigurationMultiCloudApiGetCgwOrgResourcesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetCgwOrgResourcesExecute(r ConfigurationMultiCloudApiGetCgwOrgResourcesRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetCgwOrgResources")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/cloudgateway/resource"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.cloudGatewayName == nil {
		return localVarReturnValue, nil, reportError("cloudGatewayName is required and must be specified")
	}

	localVarQueryParams.Add("cloudGatewayName", parameterToString(*r.cloudGatewayName, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiGetCgwTypesRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	cloudType *string
}

// Cloud type
func (r ConfigurationMultiCloudApiGetCgwTypesRequest) CloudType(cloudType string) ConfigurationMultiCloudApiGetCgwTypesRequest {
	r.cloudType = &cloudType
	return r
}

func (r ConfigurationMultiCloudApiGetCgwTypesRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetCgwTypesExecute(r)
}

/*
GetCgwTypes Method for GetCgwTypes

Get cloud gateway types for specified cloudType

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationMultiCloudApiGetCgwTypesRequest
*/
func (a *ConfigurationMultiCloudApiService) GetCgwTypes(ctx context.Context) ConfigurationMultiCloudApiGetCgwTypesRequest {
	return ConfigurationMultiCloudApiGetCgwTypesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetCgwTypesExecute(r ConfigurationMultiCloudApiGetCgwTypesRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetCgwTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/cloudgatewaytype"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.cloudType != nil {
		localVarQueryParams.Add("cloudType", parameterToString(*r.cloudType, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiGetCgwsRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	cloudType *string
	accountId *string
	region *string
	cloudGatewayName *string
	connectivityState *string
}

// Cloud type
func (r ConfigurationMultiCloudApiGetCgwsRequest) CloudType(cloudType string) ConfigurationMultiCloudApiGetCgwsRequest {
	r.cloudType = &cloudType
	return r
}

// Account Id
func (r ConfigurationMultiCloudApiGetCgwsRequest) AccountId(accountId string) ConfigurationMultiCloudApiGetCgwsRequest {
	r.accountId = &accountId
	return r
}

// Region
func (r ConfigurationMultiCloudApiGetCgwsRequest) Region(region string) ConfigurationMultiCloudApiGetCgwsRequest {
	r.region = &region
	return r
}

// Cloud gateway name
func (r ConfigurationMultiCloudApiGetCgwsRequest) CloudGatewayName(cloudGatewayName string) ConfigurationMultiCloudApiGetCgwsRequest {
	r.cloudGatewayName = &cloudGatewayName
	return r
}

// Connectivity State
func (r ConfigurationMultiCloudApiGetCgwsRequest) ConnectivityState(connectivityState string) ConfigurationMultiCloudApiGetCgwsRequest {
	r.connectivityState = &connectivityState
	return r
}

func (r ConfigurationMultiCloudApiGetCgwsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetCgwsExecute(r)
}

/*
GetCgws Method for GetCgws

Get cloud gateways

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationMultiCloudApiGetCgwsRequest
*/
func (a *ConfigurationMultiCloudApiService) GetCgws(ctx context.Context) ConfigurationMultiCloudApiGetCgwsRequest {
	return ConfigurationMultiCloudApiGetCgwsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetCgwsExecute(r ConfigurationMultiCloudApiGetCgwsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetCgws")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/cloudgateway"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.cloudType != nil {
		localVarQueryParams.Add("cloudType", parameterToString(*r.cloudType, ""))
	}
	if r.accountId != nil {
		localVarQueryParams.Add("accountId", parameterToString(*r.accountId, ""))
	}
	if r.region != nil {
		localVarQueryParams.Add("region", parameterToString(*r.region, ""))
	}
	if r.cloudGatewayName != nil {
		localVarQueryParams.Add("cloudGatewayName", parameterToString(*r.cloudGatewayName, ""))
	}
	if r.connectivityState != nil {
		localVarQueryParams.Add("connectivityState", parameterToString(*r.connectivityState, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiGetCloudAccountDetailsRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	accountId string
}

func (r ConfigurationMultiCloudApiGetCloudAccountDetailsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetCloudAccountDetailsExecute(r)
}

/*
GetCloudAccountDetails Method for GetCloudAccountDetails

Get cloud account by account Id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId Account Id
 @return ConfigurationMultiCloudApiGetCloudAccountDetailsRequest
*/
func (a *ConfigurationMultiCloudApiService) GetCloudAccountDetails(ctx context.Context, accountId string) ConfigurationMultiCloudApiGetCloudAccountDetailsRequest {
	return ConfigurationMultiCloudApiGetCloudAccountDetailsRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetCloudAccountDetailsExecute(r ConfigurationMultiCloudApiGetCloudAccountDetailsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetCloudAccountDetails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/accounts/{accountId}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterToString(r.accountId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiGetCloudConnectedSitesRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	cloudType string
	cloudGatewayName *string
}

// Cloud Gateway Name
func (r ConfigurationMultiCloudApiGetCloudConnectedSitesRequest) CloudGatewayName(cloudGatewayName string) ConfigurationMultiCloudApiGetCloudConnectedSitesRequest {
	r.cloudGatewayName = &cloudGatewayName
	return r
}

func (r ConfigurationMultiCloudApiGetCloudConnectedSitesRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetCloudConnectedSitesExecute(r)
}

/*
GetCloudConnectedSites Method for GetCloudConnectedSites

Get sites with connectivity to the cloud by cloud type

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cloudType Cloud type
 @return ConfigurationMultiCloudApiGetCloudConnectedSitesRequest
*/
func (a *ConfigurationMultiCloudApiService) GetCloudConnectedSites(ctx context.Context, cloudType string) ConfigurationMultiCloudApiGetCloudConnectedSitesRequest {
	return ConfigurationMultiCloudApiGetCloudConnectedSitesRequest{
		ApiService: a,
		ctx: ctx,
		cloudType: cloudType,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetCloudConnectedSitesExecute(r ConfigurationMultiCloudApiGetCloudConnectedSitesRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetCloudConnectedSites")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/connected-sites/{cloudType}"
	localVarPath = strings.Replace(localVarPath, "{"+"cloudType"+"}", url.PathEscape(parameterToString(r.cloudType, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.cloudGatewayName != nil {
		localVarQueryParams.Add("cloudGatewayName", parameterToString(*r.cloudGatewayName, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiGetCloudConnectedSites1Request struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	edgeType string
	edgeGatewayName *string
}

// Interconnect Gateway Name
func (r ConfigurationMultiCloudApiGetCloudConnectedSites1Request) EdgeGatewayName(edgeGatewayName string) ConfigurationMultiCloudApiGetCloudConnectedSites1Request {
	r.edgeGatewayName = &edgeGatewayName
	return r
}

func (r ConfigurationMultiCloudApiGetCloudConnectedSites1Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetCloudConnectedSites1Execute(r)
}

/*
GetCloudConnectedSites1 Method for GetCloudConnectedSites1

Get sites with connectivity to the interconnect gateways by edge type

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param edgeType Edge type
 @return ConfigurationMultiCloudApiGetCloudConnectedSites1Request
*/
func (a *ConfigurationMultiCloudApiService) GetCloudConnectedSites1(ctx context.Context, edgeType string) ConfigurationMultiCloudApiGetCloudConnectedSites1Request {
	return ConfigurationMultiCloudApiGetCloudConnectedSites1Request{
		ApiService: a,
		ctx: ctx,
		edgeType: edgeType,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetCloudConnectedSites1Execute(r ConfigurationMultiCloudApiGetCloudConnectedSites1Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetCloudConnectedSites1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/connected-sites/edge/{edgeType}"
	localVarPath = strings.Replace(localVarPath, "{"+"edgeType"+"}", url.PathEscape(parameterToString(r.edgeType, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.edgeGatewayName != nil {
		localVarQueryParams.Add("edgeGatewayName", parameterToString(*r.edgeGatewayName, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiGetCloudDevicesRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	cloudType string
	cloudGatewayName *string
}

// Cloud Gateway Name
func (r ConfigurationMultiCloudApiGetCloudDevicesRequest) CloudGatewayName(cloudGatewayName string) ConfigurationMultiCloudApiGetCloudDevicesRequest {
	r.cloudGatewayName = &cloudGatewayName
	return r
}

func (r ConfigurationMultiCloudApiGetCloudDevicesRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetCloudDevicesExecute(r)
}

/*
GetCloudDevices Method for GetCloudDevices

Get cloud devices by cloud type

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cloudType Cloud type
 @return ConfigurationMultiCloudApiGetCloudDevicesRequest
*/
func (a *ConfigurationMultiCloudApiService) GetCloudDevices(ctx context.Context, cloudType string) ConfigurationMultiCloudApiGetCloudDevicesRequest {
	return ConfigurationMultiCloudApiGetCloudDevicesRequest{
		ApiService: a,
		ctx: ctx,
		cloudType: cloudType,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetCloudDevicesExecute(r ConfigurationMultiCloudApiGetCloudDevicesRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetCloudDevices")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/devices/{cloudType}"
	localVarPath = strings.Replace(localVarPath, "{"+"cloudType"+"}", url.PathEscape(parameterToString(r.cloudType, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.cloudGatewayName != nil {
		localVarQueryParams.Add("cloudGatewayName", parameterToString(*r.cloudGatewayName, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiGetCloudDevices1Request struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	edgeType string
	edgeGatewayName *string
}

// Edge Gateway Name
func (r ConfigurationMultiCloudApiGetCloudDevices1Request) EdgeGatewayName(edgeGatewayName string) ConfigurationMultiCloudApiGetCloudDevices1Request {
	r.edgeGatewayName = &edgeGatewayName
	return r
}

func (r ConfigurationMultiCloudApiGetCloudDevices1Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetCloudDevices1Execute(r)
}

/*
GetCloudDevices1 Method for GetCloudDevices1

Get cloud devices by cloud type

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param edgeType Edge type
 @return ConfigurationMultiCloudApiGetCloudDevices1Request
*/
func (a *ConfigurationMultiCloudApiService) GetCloudDevices1(ctx context.Context, edgeType string) ConfigurationMultiCloudApiGetCloudDevices1Request {
	return ConfigurationMultiCloudApiGetCloudDevices1Request{
		ApiService: a,
		ctx: ctx,
		edgeType: edgeType,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetCloudDevices1Execute(r ConfigurationMultiCloudApiGetCloudDevices1Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetCloudDevices1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/devices/edge/{edgeType}"
	localVarPath = strings.Replace(localVarPath, "{"+"edgeType"+"}", url.PathEscape(parameterToString(r.edgeType, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.edgeGatewayName != nil {
		localVarQueryParams.Add("edgeGatewayName", parameterToString(*r.edgeGatewayName, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiGetCloudGatewaysRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	cloudType string
}

func (r ConfigurationMultiCloudApiGetCloudGatewaysRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetCloudGatewaysExecute(r)
}

/*
GetCloudGateways Method for GetCloudGateways

Get sites with connectivity to the cloud by cloud type

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cloudType Cloud type
 @return ConfigurationMultiCloudApiGetCloudGatewaysRequest
*/
func (a *ConfigurationMultiCloudApiService) GetCloudGateways(ctx context.Context, cloudType string) ConfigurationMultiCloudApiGetCloudGatewaysRequest {
	return ConfigurationMultiCloudApiGetCloudGatewaysRequest{
		ApiService: a,
		ctx: ctx,
		cloudType: cloudType,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetCloudGatewaysExecute(r ConfigurationMultiCloudApiGetCloudGatewaysRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetCloudGateways")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/cloudgateways/{cloudType}"
	localVarPath = strings.Replace(localVarPath, "{"+"cloudType"+"}", url.PathEscape(parameterToString(r.cloudType, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiGetCloudRegionsRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	cloudType *string
}

// Cloud type
func (r ConfigurationMultiCloudApiGetCloudRegionsRequest) CloudType(cloudType string) ConfigurationMultiCloudApiGetCloudRegionsRequest {
	r.cloudType = &cloudType
	return r
}

func (r ConfigurationMultiCloudApiGetCloudRegionsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetCloudRegionsExecute(r)
}

/*
GetCloudRegions Method for GetCloudRegions

Get cloud regions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationMultiCloudApiGetCloudRegionsRequest
*/
func (a *ConfigurationMultiCloudApiService) GetCloudRegions(ctx context.Context) ConfigurationMultiCloudApiGetCloudRegionsRequest {
	return ConfigurationMultiCloudApiGetCloudRegionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetCloudRegionsExecute(r ConfigurationMultiCloudApiGetCloudRegionsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetCloudRegions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/regions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.cloudType != nil {
		localVarQueryParams.Add("cloudType", parameterToString(*r.cloudType, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiGetCloudTypesRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
}

func (r ConfigurationMultiCloudApiGetCloudTypesRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetCloudTypesExecute(r)
}

/*
GetCloudTypes Method for GetCloudTypes

Get cloud types

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationMultiCloudApiGetCloudTypesRequest
*/
func (a *ConfigurationMultiCloudApiService) GetCloudTypes(ctx context.Context) ConfigurationMultiCloudApiGetCloudTypesRequest {
	return ConfigurationMultiCloudApiGetCloudTypesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetCloudTypesExecute(r ConfigurationMultiCloudApiGetCloudTypesRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetCloudTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/types"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiGetCloudWidgetRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	cloudType string
}

func (r ConfigurationMultiCloudApiGetCloudWidgetRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetCloudWidgetExecute(r)
}

/*
GetCloudWidget Method for GetCloudWidget

Get cloud widget by cloud type

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cloudType Cloud type
 @return ConfigurationMultiCloudApiGetCloudWidgetRequest
*/
func (a *ConfigurationMultiCloudApiService) GetCloudWidget(ctx context.Context, cloudType string) ConfigurationMultiCloudApiGetCloudWidgetRequest {
	return ConfigurationMultiCloudApiGetCloudWidgetRequest{
		ApiService: a,
		ctx: ctx,
		cloudType: cloudType,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetCloudWidgetExecute(r ConfigurationMultiCloudApiGetCloudWidgetRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetCloudWidget")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/widget/{cloudType}"
	localVarPath = strings.Replace(localVarPath, "{"+"cloudType"+"}", url.PathEscape(parameterToString(r.cloudType, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiGetConnectivityGatewayCreationOptionsRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	accountId *string
	cloudType *string
	connectivityType *string
	refresh *string
}

// Account Id
func (r ConfigurationMultiCloudApiGetConnectivityGatewayCreationOptionsRequest) AccountId(accountId string) ConfigurationMultiCloudApiGetConnectivityGatewayCreationOptionsRequest {
	r.accountId = &accountId
	return r
}

// Cloud Type
func (r ConfigurationMultiCloudApiGetConnectivityGatewayCreationOptionsRequest) CloudType(cloudType string) ConfigurationMultiCloudApiGetConnectivityGatewayCreationOptionsRequest {
	r.cloudType = &cloudType
	return r
}

// Cloud Connectivity Type
func (r ConfigurationMultiCloudApiGetConnectivityGatewayCreationOptionsRequest) ConnectivityType(connectivityType string) ConfigurationMultiCloudApiGetConnectivityGatewayCreationOptionsRequest {
	r.connectivityType = &connectivityType
	return r
}

// Refresh
func (r ConfigurationMultiCloudApiGetConnectivityGatewayCreationOptionsRequest) Refresh(refresh string) ConfigurationMultiCloudApiGetConnectivityGatewayCreationOptionsRequest {
	r.refresh = &refresh
	return r
}

func (r ConfigurationMultiCloudApiGetConnectivityGatewayCreationOptionsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetConnectivityGatewayCreationOptionsExecute(r)
}

/*
GetConnectivityGatewayCreationOptions Method for GetConnectivityGatewayCreationOptions

Get connectivity gateway creation options

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationMultiCloudApiGetConnectivityGatewayCreationOptionsRequest
*/
func (a *ConfigurationMultiCloudApiService) GetConnectivityGatewayCreationOptions(ctx context.Context) ConfigurationMultiCloudApiGetConnectivityGatewayCreationOptionsRequest {
	return ConfigurationMultiCloudApiGetConnectivityGatewayCreationOptionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetConnectivityGatewayCreationOptionsExecute(r ConfigurationMultiCloudApiGetConnectivityGatewayCreationOptionsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetConnectivityGatewayCreationOptions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/connectivitygatewaycreationoptions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.accountId != nil {
		localVarQueryParams.Add("accountId", parameterToString(*r.accountId, ""))
	}
	if r.cloudType != nil {
		localVarQueryParams.Add("cloudType", parameterToString(*r.cloudType, ""))
	}
	if r.connectivityType != nil {
		localVarQueryParams.Add("connectivityType", parameterToString(*r.connectivityType, ""))
	}
	if r.refresh != nil {
		localVarQueryParams.Add("refresh", parameterToString(*r.refresh, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiGetConnectivityGatewaysRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	accountId *string
	cloudType *string
	connectivityType *string
	connectivityGatewayName *string
	region *string
	network *string
	state *string
	refresh *string
	edgeType *string
}

// Account Id
func (r ConfigurationMultiCloudApiGetConnectivityGatewaysRequest) AccountId(accountId string) ConfigurationMultiCloudApiGetConnectivityGatewaysRequest {
	r.accountId = &accountId
	return r
}

// Cloud Type
func (r ConfigurationMultiCloudApiGetConnectivityGatewaysRequest) CloudType(cloudType string) ConfigurationMultiCloudApiGetConnectivityGatewaysRequest {
	r.cloudType = &cloudType
	return r
}

// Cloud Connectivity Type
func (r ConfigurationMultiCloudApiGetConnectivityGatewaysRequest) ConnectivityType(connectivityType string) ConfigurationMultiCloudApiGetConnectivityGatewaysRequest {
	r.connectivityType = &connectivityType
	return r
}

// Connectivity Gateway Name
func (r ConfigurationMultiCloudApiGetConnectivityGatewaysRequest) ConnectivityGatewayName(connectivityGatewayName string) ConfigurationMultiCloudApiGetConnectivityGatewaysRequest {
	r.connectivityGatewayName = &connectivityGatewayName
	return r
}

// Region
func (r ConfigurationMultiCloudApiGetConnectivityGatewaysRequest) Region(region string) ConfigurationMultiCloudApiGetConnectivityGatewaysRequest {
	r.region = &region
	return r
}

// Network
func (r ConfigurationMultiCloudApiGetConnectivityGatewaysRequest) Network(network string) ConfigurationMultiCloudApiGetConnectivityGatewaysRequest {
	r.network = &network
	return r
}

// State
func (r ConfigurationMultiCloudApiGetConnectivityGatewaysRequest) State(state string) ConfigurationMultiCloudApiGetConnectivityGatewaysRequest {
	r.state = &state
	return r
}

// Refresh
func (r ConfigurationMultiCloudApiGetConnectivityGatewaysRequest) Refresh(refresh string) ConfigurationMultiCloudApiGetConnectivityGatewaysRequest {
	r.refresh = &refresh
	return r
}

// Edge type
func (r ConfigurationMultiCloudApiGetConnectivityGatewaysRequest) EdgeType(edgeType string) ConfigurationMultiCloudApiGetConnectivityGatewaysRequest {
	r.edgeType = &edgeType
	return r
}

func (r ConfigurationMultiCloudApiGetConnectivityGatewaysRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetConnectivityGatewaysExecute(r)
}

/*
GetConnectivityGateways Method for GetConnectivityGateways

Get all Connectivity Gateways

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationMultiCloudApiGetConnectivityGatewaysRequest
*/
func (a *ConfigurationMultiCloudApiService) GetConnectivityGateways(ctx context.Context) ConfigurationMultiCloudApiGetConnectivityGatewaysRequest {
	return ConfigurationMultiCloudApiGetConnectivityGatewaysRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetConnectivityGatewaysExecute(r ConfigurationMultiCloudApiGetConnectivityGatewaysRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetConnectivityGateways")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/connectivitygateway"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.accountId != nil {
		localVarQueryParams.Add("accountId", parameterToString(*r.accountId, ""))
	}
	if r.cloudType != nil {
		localVarQueryParams.Add("cloudType", parameterToString(*r.cloudType, ""))
	}
	if r.connectivityType != nil {
		localVarQueryParams.Add("connectivityType", parameterToString(*r.connectivityType, ""))
	}
	if r.connectivityGatewayName != nil {
		localVarQueryParams.Add("connectivityGatewayName", parameterToString(*r.connectivityGatewayName, ""))
	}
	if r.region != nil {
		localVarQueryParams.Add("region", parameterToString(*r.region, ""))
	}
	if r.network != nil {
		localVarQueryParams.Add("network", parameterToString(*r.network, ""))
	}
	if r.state != nil {
		localVarQueryParams.Add("state", parameterToString(*r.state, ""))
	}
	if r.refresh != nil {
		localVarQueryParams.Add("refresh", parameterToString(*r.refresh, ""))
	}
	if r.edgeType != nil {
		localVarQueryParams.Add("edgeType", parameterToString(*r.edgeType, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiGetDashboardEdgeInfoRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
}

func (r ConfigurationMultiCloudApiGetDashboardEdgeInfoRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetDashboardEdgeInfoExecute(r)
}

/*
GetDashboardEdgeInfo Method for GetDashboardEdgeInfo

Get interconnect edge gateway dashboard info

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationMultiCloudApiGetDashboardEdgeInfoRequest
*/
func (a *ConfigurationMultiCloudApiService) GetDashboardEdgeInfo(ctx context.Context) ConfigurationMultiCloudApiGetDashboardEdgeInfoRequest {
	return ConfigurationMultiCloudApiGetDashboardEdgeInfoRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetDashboardEdgeInfoExecute(r ConfigurationMultiCloudApiGetDashboardEdgeInfoRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetDashboardEdgeInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/dashboard/edge"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiGetDefaultMappingValuesRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	cloudType *string
}

// Cloud type
func (r ConfigurationMultiCloudApiGetDefaultMappingValuesRequest) CloudType(cloudType string) ConfigurationMultiCloudApiGetDefaultMappingValuesRequest {
	r.cloudType = &cloudType
	return r
}

func (r ConfigurationMultiCloudApiGetDefaultMappingValuesRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetDefaultMappingValuesExecute(r)
}

/*
GetDefaultMappingValues Method for GetDefaultMappingValues

Get default mapping values

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationMultiCloudApiGetDefaultMappingValuesRequest
*/
func (a *ConfigurationMultiCloudApiService) GetDefaultMappingValues(ctx context.Context) ConfigurationMultiCloudApiGetDefaultMappingValuesRequest {
	return ConfigurationMultiCloudApiGetDefaultMappingValuesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetDefaultMappingValuesExecute(r ConfigurationMultiCloudApiGetDefaultMappingValuesRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetDefaultMappingValues")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/map/defaults"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.cloudType == nil {
		return localVarReturnValue, nil, reportError("cloudType is required and must be specified")
	}

	localVarQueryParams.Add("cloudType", parameterToString(*r.cloudType, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiGetDeviceLinksRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	edgeType *string
	deviceLinkName *string
}

// Edge type
func (r ConfigurationMultiCloudApiGetDeviceLinksRequest) EdgeType(edgeType string) ConfigurationMultiCloudApiGetDeviceLinksRequest {
	r.edgeType = &edgeType
	return r
}

// Device Link Name
func (r ConfigurationMultiCloudApiGetDeviceLinksRequest) DeviceLinkName(deviceLinkName string) ConfigurationMultiCloudApiGetDeviceLinksRequest {
	r.deviceLinkName = &deviceLinkName
	return r
}

func (r ConfigurationMultiCloudApiGetDeviceLinksRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetDeviceLinksExecute(r)
}

/*
GetDeviceLinks Method for GetDeviceLinks

Get Device Links

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationMultiCloudApiGetDeviceLinksRequest
*/
func (a *ConfigurationMultiCloudApiService) GetDeviceLinks(ctx context.Context) ConfigurationMultiCloudApiGetDeviceLinksRequest {
	return ConfigurationMultiCloudApiGetDeviceLinksRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetDeviceLinksExecute(r ConfigurationMultiCloudApiGetDeviceLinksRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetDeviceLinks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/devicelink/edge"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.edgeType != nil {
		localVarQueryParams.Add("edgeType", parameterToString(*r.edgeType, ""))
	}
	if r.deviceLinkName != nil {
		localVarQueryParams.Add("deviceLinkName", parameterToString(*r.deviceLinkName, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiGetDlPortSpeedRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	edgeType string
}

func (r ConfigurationMultiCloudApiGetDlPortSpeedRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetDlPortSpeedExecute(r)
}

/*
GetDlPortSpeed Method for GetDlPortSpeed

Get supported port speed for Device Link

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param edgeType Interconnect Provider
 @return ConfigurationMultiCloudApiGetDlPortSpeedRequest
*/
func (a *ConfigurationMultiCloudApiService) GetDlPortSpeed(ctx context.Context, edgeType string) ConfigurationMultiCloudApiGetDlPortSpeedRequest {
	return ConfigurationMultiCloudApiGetDlPortSpeedRequest{
		ApiService: a,
		ctx: ctx,
		edgeType: edgeType,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetDlPortSpeedExecute(r ConfigurationMultiCloudApiGetDlPortSpeedRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetDlPortSpeed")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/devicelink/edge/portspeed/{edgeType}"
	localVarPath = strings.Replace(localVarPath, "{"+"edgeType"+"}", url.PathEscape(parameterToString(r.edgeType, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiGetEdgeAccountDetailsRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	accountId string
}

func (r ConfigurationMultiCloudApiGetEdgeAccountDetailsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetEdgeAccountDetailsExecute(r)
}

/*
GetEdgeAccountDetails Method for GetEdgeAccountDetails

Get edge account by account Id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId Edge Account Id
 @return ConfigurationMultiCloudApiGetEdgeAccountDetailsRequest
*/
func (a *ConfigurationMultiCloudApiService) GetEdgeAccountDetails(ctx context.Context, accountId string) ConfigurationMultiCloudApiGetEdgeAccountDetailsRequest {
	return ConfigurationMultiCloudApiGetEdgeAccountDetailsRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetEdgeAccountDetailsExecute(r ConfigurationMultiCloudApiGetEdgeAccountDetailsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetEdgeAccountDetails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/accounts/edge/{accountId}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterToString(r.accountId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiGetEdgeAccountsRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	edgeType *string
}

// Edge type
func (r ConfigurationMultiCloudApiGetEdgeAccountsRequest) EdgeType(edgeType string) ConfigurationMultiCloudApiGetEdgeAccountsRequest {
	r.edgeType = &edgeType
	return r
}

func (r ConfigurationMultiCloudApiGetEdgeAccountsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetEdgeAccountsExecute(r)
}

/*
GetEdgeAccounts Method for GetEdgeAccounts

Get all Multicloud edge accounts

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationMultiCloudApiGetEdgeAccountsRequest
*/
func (a *ConfigurationMultiCloudApiService) GetEdgeAccounts(ctx context.Context) ConfigurationMultiCloudApiGetEdgeAccountsRequest {
	return ConfigurationMultiCloudApiGetEdgeAccountsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetEdgeAccountsExecute(r ConfigurationMultiCloudApiGetEdgeAccountsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetEdgeAccounts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/accounts/edge"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.edgeType != nil {
		localVarQueryParams.Add("edgeType", parameterToString(*r.edgeType, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiGetEdgeBillingAccountsRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	edgeType string
	edgeAccountId string
	region *string
}

// Region
func (r ConfigurationMultiCloudApiGetEdgeBillingAccountsRequest) Region(region string) ConfigurationMultiCloudApiGetEdgeBillingAccountsRequest {
	r.region = &region
	return r
}

func (r ConfigurationMultiCloudApiGetEdgeBillingAccountsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetEdgeBillingAccountsExecute(r)
}

/*
GetEdgeBillingAccounts Method for GetEdgeBillingAccounts

Get Edge Billing Accounts

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param edgeType Interconnect Provider
 @param edgeAccountId Interconnect Provider Account ID
 @return ConfigurationMultiCloudApiGetEdgeBillingAccountsRequest
*/
func (a *ConfigurationMultiCloudApiService) GetEdgeBillingAccounts(ctx context.Context, edgeType string, edgeAccountId string) ConfigurationMultiCloudApiGetEdgeBillingAccountsRequest {
	return ConfigurationMultiCloudApiGetEdgeBillingAccountsRequest{
		ApiService: a,
		ctx: ctx,
		edgeType: edgeType,
		edgeAccountId: edgeAccountId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetEdgeBillingAccountsExecute(r ConfigurationMultiCloudApiGetEdgeBillingAccountsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetEdgeBillingAccounts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/billingaccounts/edge/{edgeType}/{edgeAccountId}"
	localVarPath = strings.Replace(localVarPath, "{"+"edgeType"+"}", url.PathEscape(parameterToString(r.edgeType, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"edgeAccountId"+"}", url.PathEscape(parameterToString(r.edgeAccountId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.region != nil {
		localVarQueryParams.Add("region", parameterToString(*r.region, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiGetEdgeConnectivityDetailByNameRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	connectivityName string
}

func (r ConfigurationMultiCloudApiGetEdgeConnectivityDetailByNameRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetEdgeConnectivityDetailByNameExecute(r)
}

/*
GetEdgeConnectivityDetailByName Method for GetEdgeConnectivityDetailByName

Get Interconnect Connectivity by name

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param connectivityName IC-GW connectivity name
 @return ConfigurationMultiCloudApiGetEdgeConnectivityDetailByNameRequest
*/
func (a *ConfigurationMultiCloudApiService) GetEdgeConnectivityDetailByName(ctx context.Context, connectivityName string) ConfigurationMultiCloudApiGetEdgeConnectivityDetailByNameRequest {
	return ConfigurationMultiCloudApiGetEdgeConnectivityDetailByNameRequest{
		ApiService: a,
		ctx: ctx,
		connectivityName: connectivityName,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetEdgeConnectivityDetailByNameExecute(r ConfigurationMultiCloudApiGetEdgeConnectivityDetailByNameRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetEdgeConnectivityDetailByName")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/connectivity/edge/{connectivityName}"
	localVarPath = strings.Replace(localVarPath, "{"+"connectivityName"+"}", url.PathEscape(parameterToString(r.connectivityName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiGetEdgeConnectivityDetailsRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	edgeType *string
	connectivityName *string
	connectivityType *string
	edgeGatewayName *string
}

// Edge type
func (r ConfigurationMultiCloudApiGetEdgeConnectivityDetailsRequest) EdgeType(edgeType string) ConfigurationMultiCloudApiGetEdgeConnectivityDetailsRequest {
	r.edgeType = &edgeType
	return r
}

// Connectivity Name
func (r ConfigurationMultiCloudApiGetEdgeConnectivityDetailsRequest) ConnectivityName(connectivityName string) ConfigurationMultiCloudApiGetEdgeConnectivityDetailsRequest {
	r.connectivityName = &connectivityName
	return r
}

// Connectivity Type
func (r ConfigurationMultiCloudApiGetEdgeConnectivityDetailsRequest) ConnectivityType(connectivityType string) ConfigurationMultiCloudApiGetEdgeConnectivityDetailsRequest {
	r.connectivityType = &connectivityType
	return r
}

// Interconnect Gateway name
func (r ConfigurationMultiCloudApiGetEdgeConnectivityDetailsRequest) EdgeGatewayName(edgeGatewayName string) ConfigurationMultiCloudApiGetEdgeConnectivityDetailsRequest {
	r.edgeGatewayName = &edgeGatewayName
	return r
}

func (r ConfigurationMultiCloudApiGetEdgeConnectivityDetailsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetEdgeConnectivityDetailsExecute(r)
}

/*
GetEdgeConnectivityDetails Method for GetEdgeConnectivityDetails

Get Interconnect Connectivity details

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationMultiCloudApiGetEdgeConnectivityDetailsRequest
*/
func (a *ConfigurationMultiCloudApiService) GetEdgeConnectivityDetails(ctx context.Context) ConfigurationMultiCloudApiGetEdgeConnectivityDetailsRequest {
	return ConfigurationMultiCloudApiGetEdgeConnectivityDetailsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetEdgeConnectivityDetailsExecute(r ConfigurationMultiCloudApiGetEdgeConnectivityDetailsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetEdgeConnectivityDetails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/connectivity/edge"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.edgeType != nil {
		localVarQueryParams.Add("edgeType", parameterToString(*r.edgeType, ""))
	}
	if r.connectivityName != nil {
		localVarQueryParams.Add("connectivityName", parameterToString(*r.connectivityName, ""))
	}
	if r.connectivityType != nil {
		localVarQueryParams.Add("connectivityType", parameterToString(*r.connectivityType, ""))
	}
	if r.edgeGatewayName != nil {
		localVarQueryParams.Add("edgeGatewayName", parameterToString(*r.edgeGatewayName, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiGetEdgeGatewaysRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	edgeType string
}

func (r ConfigurationMultiCloudApiGetEdgeGatewaysRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetEdgeGatewaysExecute(r)
}

/*
GetEdgeGateways Method for GetEdgeGateways

Get sites with connectivity to the interconnect gateways by edge type

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param edgeType Edge type
 @return ConfigurationMultiCloudApiGetEdgeGatewaysRequest
*/
func (a *ConfigurationMultiCloudApiService) GetEdgeGateways(ctx context.Context, edgeType string) ConfigurationMultiCloudApiGetEdgeGatewaysRequest {
	return ConfigurationMultiCloudApiGetEdgeGatewaysRequest{
		ApiService: a,
		ctx: ctx,
		edgeType: edgeType,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetEdgeGatewaysExecute(r ConfigurationMultiCloudApiGetEdgeGatewaysRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetEdgeGateways")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/gateways/edge/{edgeType}"
	localVarPath = strings.Replace(localVarPath, "{"+"edgeType"+"}", url.PathEscape(parameterToString(r.edgeType, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiGetEdgeGlobalSettingsRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	edgeType *string
}

// Edge type
func (r ConfigurationMultiCloudApiGetEdgeGlobalSettingsRequest) EdgeType(edgeType string) ConfigurationMultiCloudApiGetEdgeGlobalSettingsRequest {
	r.edgeType = &edgeType
	return r
}

func (r ConfigurationMultiCloudApiGetEdgeGlobalSettingsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetEdgeGlobalSettingsExecute(r)
}

/*
GetEdgeGlobalSettings Method for GetEdgeGlobalSettings

Get edge global settings

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationMultiCloudApiGetEdgeGlobalSettingsRequest
*/
func (a *ConfigurationMultiCloudApiService) GetEdgeGlobalSettings(ctx context.Context) ConfigurationMultiCloudApiGetEdgeGlobalSettingsRequest {
	return ConfigurationMultiCloudApiGetEdgeGlobalSettingsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetEdgeGlobalSettingsExecute(r ConfigurationMultiCloudApiGetEdgeGlobalSettingsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetEdgeGlobalSettings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/settings/edge/global"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.edgeType == nil {
		return localVarReturnValue, nil, reportError("edgeType is required and must be specified")
	}

	localVarQueryParams.Add("edgeType", parameterToString(*r.edgeType, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiGetEdgeLocationsInfoRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	edgeType string
	accountId *string
	region *string
}

// Edge Account Id
func (r ConfigurationMultiCloudApiGetEdgeLocationsInfoRequest) AccountId(accountId string) ConfigurationMultiCloudApiGetEdgeLocationsInfoRequest {
	r.accountId = &accountId
	return r
}

// Region
func (r ConfigurationMultiCloudApiGetEdgeLocationsInfoRequest) Region(region string) ConfigurationMultiCloudApiGetEdgeLocationsInfoRequest {
	r.region = &region
	return r
}

func (r ConfigurationMultiCloudApiGetEdgeLocationsInfoRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetEdgeLocationsInfoExecute(r)
}

/*
GetEdgeLocationsInfo Method for GetEdgeLocationsInfo

Get Edge Locations

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param edgeType Edge Type
 @return ConfigurationMultiCloudApiGetEdgeLocationsInfoRequest
*/
func (a *ConfigurationMultiCloudApiService) GetEdgeLocationsInfo(ctx context.Context, edgeType string) ConfigurationMultiCloudApiGetEdgeLocationsInfoRequest {
	return ConfigurationMultiCloudApiGetEdgeLocationsInfoRequest{
		ApiService: a,
		ctx: ctx,
		edgeType: edgeType,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetEdgeLocationsInfoExecute(r ConfigurationMultiCloudApiGetEdgeLocationsInfoRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetEdgeLocationsInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/locations/edge/{edgeType}"
	localVarPath = strings.Replace(localVarPath, "{"+"edgeType"+"}", url.PathEscape(parameterToString(r.edgeType, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.accountId != nil {
		localVarQueryParams.Add("accountId", parameterToString(*r.accountId, ""))
	}
	if r.region != nil {
		localVarQueryParams.Add("region", parameterToString(*r.region, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiGetEdgeMappingTagsRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	cloudType *string
	accountId *string
	resourceGroup *string
}

// Cloud type
func (r ConfigurationMultiCloudApiGetEdgeMappingTagsRequest) CloudType(cloudType string) ConfigurationMultiCloudApiGetEdgeMappingTagsRequest {
	r.cloudType = &cloudType
	return r
}

// Cloud Account Id
func (r ConfigurationMultiCloudApiGetEdgeMappingTagsRequest) AccountId(accountId string) ConfigurationMultiCloudApiGetEdgeMappingTagsRequest {
	r.accountId = &accountId
	return r
}

// Resource Group
func (r ConfigurationMultiCloudApiGetEdgeMappingTagsRequest) ResourceGroup(resourceGroup string) ConfigurationMultiCloudApiGetEdgeMappingTagsRequest {
	r.resourceGroup = &resourceGroup
	return r
}

func (r ConfigurationMultiCloudApiGetEdgeMappingTagsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetEdgeMappingTagsExecute(r)
}

/*
GetEdgeMappingTags Method for GetEdgeMappingTags

Get default Interconnect mapping tag values

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationMultiCloudApiGetEdgeMappingTagsRequest
*/
func (a *ConfigurationMultiCloudApiService) GetEdgeMappingTags(ctx context.Context) ConfigurationMultiCloudApiGetEdgeMappingTagsRequest {
	return ConfigurationMultiCloudApiGetEdgeMappingTagsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetEdgeMappingTagsExecute(r ConfigurationMultiCloudApiGetEdgeMappingTagsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetEdgeMappingTags")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/map/tags/edge"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.cloudType == nil {
		return localVarReturnValue, nil, reportError("cloudType is required and must be specified")
	}

	localVarQueryParams.Add("cloudType", parameterToString(*r.cloudType, ""))
	if r.accountId != nil {
		localVarQueryParams.Add("accountId", parameterToString(*r.accountId, ""))
	}
	if r.resourceGroup != nil {
		localVarQueryParams.Add("resourceGroup", parameterToString(*r.resourceGroup, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiGetEdgeTypesRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
}

func (r ConfigurationMultiCloudApiGetEdgeTypesRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetEdgeTypesExecute(r)
}

/*
GetEdgeTypes Method for GetEdgeTypes

Get edge types

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationMultiCloudApiGetEdgeTypesRequest
*/
func (a *ConfigurationMultiCloudApiService) GetEdgeTypes(ctx context.Context) ConfigurationMultiCloudApiGetEdgeTypesRequest {
	return ConfigurationMultiCloudApiGetEdgeTypesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetEdgeTypesExecute(r ConfigurationMultiCloudApiGetEdgeTypesRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetEdgeTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/types/edge"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiGetEdgeWanDevicesRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	edgeType string
}

func (r ConfigurationMultiCloudApiGetEdgeWanDevicesRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetEdgeWanDevicesExecute(r)
}

/*
GetEdgeWanDevices Method for GetEdgeWanDevices

Get available WAN edge devices

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param edgeType Edge Type
 @return ConfigurationMultiCloudApiGetEdgeWanDevicesRequest
*/
func (a *ConfigurationMultiCloudApiService) GetEdgeWanDevices(ctx context.Context, edgeType string) ConfigurationMultiCloudApiGetEdgeWanDevicesRequest {
	return ConfigurationMultiCloudApiGetEdgeWanDevicesRequest{
		ApiService: a,
		ctx: ctx,
		edgeType: edgeType,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetEdgeWanDevicesExecute(r ConfigurationMultiCloudApiGetEdgeWanDevicesRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetEdgeWanDevices")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/edge/{edgeType}/device"
	localVarPath = strings.Replace(localVarPath, "{"+"edgeType"+"}", url.PathEscape(parameterToString(r.edgeType, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiGetEdgeWidgetRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	edgeType string
}

func (r ConfigurationMultiCloudApiGetEdgeWidgetRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetEdgeWidgetExecute(r)
}

/*
GetEdgeWidget Method for GetEdgeWidget

Get Interconnect Edge widget by edge type

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param edgeType Edge type
 @return ConfigurationMultiCloudApiGetEdgeWidgetRequest
*/
func (a *ConfigurationMultiCloudApiService) GetEdgeWidget(ctx context.Context, edgeType string) ConfigurationMultiCloudApiGetEdgeWidgetRequest {
	return ConfigurationMultiCloudApiGetEdgeWidgetRequest{
		ApiService: a,
		ctx: ctx,
		edgeType: edgeType,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetEdgeWidgetExecute(r ConfigurationMultiCloudApiGetEdgeWidgetRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetEdgeWidget")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/widget/edge/{edgeType}"
	localVarPath = strings.Replace(localVarPath, "{"+"edgeType"+"}", url.PathEscape(parameterToString(r.edgeType, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiGetGlobalSettingsRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	cloudType *string
}

// Cloud type
func (r ConfigurationMultiCloudApiGetGlobalSettingsRequest) CloudType(cloudType string) ConfigurationMultiCloudApiGetGlobalSettingsRequest {
	r.cloudType = &cloudType
	return r
}

func (r ConfigurationMultiCloudApiGetGlobalSettingsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetGlobalSettingsExecute(r)
}

/*
GetGlobalSettings Method for GetGlobalSettings

Get global settings

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationMultiCloudApiGetGlobalSettingsRequest
*/
func (a *ConfigurationMultiCloudApiService) GetGlobalSettings(ctx context.Context) ConfigurationMultiCloudApiGetGlobalSettingsRequest {
	return ConfigurationMultiCloudApiGetGlobalSettingsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetGlobalSettingsExecute(r ConfigurationMultiCloudApiGetGlobalSettingsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetGlobalSettings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/settings/global"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.cloudType == nil {
		return localVarReturnValue, nil, reportError("cloudType is required and must be specified")
	}

	localVarQueryParams.Add("cloudType", parameterToString(*r.cloudType, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiGetHostVpcsRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	cloudType *string
	accountIds *string
	region *string
	untagged *string
}

// Cloud type
func (r ConfigurationMultiCloudApiGetHostVpcsRequest) CloudType(cloudType string) ConfigurationMultiCloudApiGetHostVpcsRequest {
	r.cloudType = &cloudType
	return r
}

// Account Id
func (r ConfigurationMultiCloudApiGetHostVpcsRequest) AccountIds(accountIds string) ConfigurationMultiCloudApiGetHostVpcsRequest {
	r.accountIds = &accountIds
	return r
}

// Region
func (r ConfigurationMultiCloudApiGetHostVpcsRequest) Region(region string) ConfigurationMultiCloudApiGetHostVpcsRequest {
	r.region = &region
	return r
}

// Untagged flag
func (r ConfigurationMultiCloudApiGetHostVpcsRequest) Untagged(untagged string) ConfigurationMultiCloudApiGetHostVpcsRequest {
	r.untagged = &untagged
	return r
}

func (r ConfigurationMultiCloudApiGetHostVpcsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetHostVpcsExecute(r)
}

/*
GetHostVpcs Method for GetHostVpcs

Get tagged, untagged, or all Host VPCs

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationMultiCloudApiGetHostVpcsRequest
*/
func (a *ConfigurationMultiCloudApiService) GetHostVpcs(ctx context.Context) ConfigurationMultiCloudApiGetHostVpcsRequest {
	return ConfigurationMultiCloudApiGetHostVpcsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetHostVpcsExecute(r ConfigurationMultiCloudApiGetHostVpcsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetHostVpcs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/hostvpc"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.cloudType == nil {
		return localVarReturnValue, nil, reportError("cloudType is required and must be specified")
	}

	localVarQueryParams.Add("cloudType", parameterToString(*r.cloudType, ""))
	if r.accountIds != nil {
		localVarQueryParams.Add("accountIds", parameterToString(*r.accountIds, ""))
	}
	if r.region != nil {
		localVarQueryParams.Add("region", parameterToString(*r.region, ""))
	}
	if r.untagged != nil {
		localVarQueryParams.Add("untagged", parameterToString(*r.untagged, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiGetIcgwCustomSettingDetailsRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	edgeGatewayName string
}

func (r ConfigurationMultiCloudApiGetIcgwCustomSettingDetailsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetIcgwCustomSettingDetailsExecute(r)
}

/*
GetIcgwCustomSettingDetails Method for GetIcgwCustomSettingDetails

Get Interconnect Gateway custom setting by Interconnect Gateway name

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param edgeGatewayName Edge gateway name
 @return ConfigurationMultiCloudApiGetIcgwCustomSettingDetailsRequest
*/
func (a *ConfigurationMultiCloudApiService) GetIcgwCustomSettingDetails(ctx context.Context, edgeGatewayName string) ConfigurationMultiCloudApiGetIcgwCustomSettingDetailsRequest {
	return ConfigurationMultiCloudApiGetIcgwCustomSettingDetailsRequest{
		ApiService: a,
		ctx: ctx,
		edgeGatewayName: edgeGatewayName,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetIcgwCustomSettingDetailsExecute(r ConfigurationMultiCloudApiGetIcgwCustomSettingDetailsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetIcgwCustomSettingDetails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/gateway/edge/setting/{edgeGatewayName}"
	localVarPath = strings.Replace(localVarPath, "{"+"edgeGatewayName"+"}", url.PathEscape(parameterToString(r.edgeGatewayName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiGetIcgwDetailsRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	edgeGatewayName string
}

func (r ConfigurationMultiCloudApiGetIcgwDetailsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetIcgwDetailsExecute(r)
}

/*
GetIcgwDetails Method for GetIcgwDetails

Get Interconnect Gateway by name

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param edgeGatewayName Edge gateway name
 @return ConfigurationMultiCloudApiGetIcgwDetailsRequest
*/
func (a *ConfigurationMultiCloudApiService) GetIcgwDetails(ctx context.Context, edgeGatewayName string) ConfigurationMultiCloudApiGetIcgwDetailsRequest {
	return ConfigurationMultiCloudApiGetIcgwDetailsRequest{
		ApiService: a,
		ctx: ctx,
		edgeGatewayName: edgeGatewayName,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetIcgwDetailsExecute(r ConfigurationMultiCloudApiGetIcgwDetailsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetIcgwDetails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/gateway/edge/{edgeGatewayName}"
	localVarPath = strings.Replace(localVarPath, "{"+"edgeGatewayName"+"}", url.PathEscape(parameterToString(r.edgeGatewayName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiGetIcgwTypesRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	edgeType *string
}

// Edge type
func (r ConfigurationMultiCloudApiGetIcgwTypesRequest) EdgeType(edgeType string) ConfigurationMultiCloudApiGetIcgwTypesRequest {
	r.edgeType = &edgeType
	return r
}

func (r ConfigurationMultiCloudApiGetIcgwTypesRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetIcgwTypesExecute(r)
}

/*
GetIcgwTypes Method for GetIcgwTypes

Get Interconnect Gateway type for specified Edge Provider

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationMultiCloudApiGetIcgwTypesRequest
*/
func (a *ConfigurationMultiCloudApiService) GetIcgwTypes(ctx context.Context) ConfigurationMultiCloudApiGetIcgwTypesRequest {
	return ConfigurationMultiCloudApiGetIcgwTypesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetIcgwTypesExecute(r ConfigurationMultiCloudApiGetIcgwTypesRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetIcgwTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/gateway/edge/types"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.edgeType != nil {
		localVarQueryParams.Add("edgeType", parameterToString(*r.edgeType, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiGetIcgwsRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	edgeType *string
	accountId *string
	region *string
	regionId *string
	resourceState *string
	edgeGatewayName *string
	billingAccountId *string
}

// Edge type
func (r ConfigurationMultiCloudApiGetIcgwsRequest) EdgeType(edgeType string) ConfigurationMultiCloudApiGetIcgwsRequest {
	r.edgeType = &edgeType
	return r
}

// Account Id
func (r ConfigurationMultiCloudApiGetIcgwsRequest) AccountId(accountId string) ConfigurationMultiCloudApiGetIcgwsRequest {
	r.accountId = &accountId
	return r
}

// Region
func (r ConfigurationMultiCloudApiGetIcgwsRequest) Region(region string) ConfigurationMultiCloudApiGetIcgwsRequest {
	r.region = &region
	return r
}

// Region Id
func (r ConfigurationMultiCloudApiGetIcgwsRequest) RegionId(regionId string) ConfigurationMultiCloudApiGetIcgwsRequest {
	r.regionId = &regionId
	return r
}

// Resource State
func (r ConfigurationMultiCloudApiGetIcgwsRequest) ResourceState(resourceState string) ConfigurationMultiCloudApiGetIcgwsRequest {
	r.resourceState = &resourceState
	return r
}

// Edge gateway name
func (r ConfigurationMultiCloudApiGetIcgwsRequest) EdgeGatewayName(edgeGatewayName string) ConfigurationMultiCloudApiGetIcgwsRequest {
	r.edgeGatewayName = &edgeGatewayName
	return r
}

// billing Account Id
func (r ConfigurationMultiCloudApiGetIcgwsRequest) BillingAccountId(billingAccountId string) ConfigurationMultiCloudApiGetIcgwsRequest {
	r.billingAccountId = &billingAccountId
	return r
}

func (r ConfigurationMultiCloudApiGetIcgwsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetIcgwsExecute(r)
}

/*
GetIcgws Method for GetIcgws

Get Interconnect Gateways

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationMultiCloudApiGetIcgwsRequest
*/
func (a *ConfigurationMultiCloudApiService) GetIcgws(ctx context.Context) ConfigurationMultiCloudApiGetIcgwsRequest {
	return ConfigurationMultiCloudApiGetIcgwsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetIcgwsExecute(r ConfigurationMultiCloudApiGetIcgwsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetIcgws")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/gateway/edge"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.edgeType != nil {
		localVarQueryParams.Add("edgeType", parameterToString(*r.edgeType, ""))
	}
	if r.accountId != nil {
		localVarQueryParams.Add("accountId", parameterToString(*r.accountId, ""))
	}
	if r.region != nil {
		localVarQueryParams.Add("region", parameterToString(*r.region, ""))
	}
	if r.regionId != nil {
		localVarQueryParams.Add("regionId", parameterToString(*r.regionId, ""))
	}
	if r.resourceState != nil {
		localVarQueryParams.Add("resourceState", parameterToString(*r.resourceState, ""))
	}
	if r.edgeGatewayName != nil {
		localVarQueryParams.Add("edgeGatewayName", parameterToString(*r.edgeGatewayName, ""))
	}
	if r.billingAccountId != nil {
		localVarQueryParams.Add("billingAccountId", parameterToString(*r.billingAccountId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiGetMappingMatrixRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	cloudType *string
}

// Cloud type
func (r ConfigurationMultiCloudApiGetMappingMatrixRequest) CloudType(cloudType string) ConfigurationMultiCloudApiGetMappingMatrixRequest {
	r.cloudType = &cloudType
	return r
}

func (r ConfigurationMultiCloudApiGetMappingMatrixRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetMappingMatrixExecute(r)
}

/*
GetMappingMatrix Method for GetMappingMatrix

Get default mapping values

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationMultiCloudApiGetMappingMatrixRequest
*/
func (a *ConfigurationMultiCloudApiService) GetMappingMatrix(ctx context.Context) ConfigurationMultiCloudApiGetMappingMatrixRequest {
	return ConfigurationMultiCloudApiGetMappingMatrixRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetMappingMatrixExecute(r ConfigurationMultiCloudApiGetMappingMatrixRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetMappingMatrix")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/map"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.cloudType == nil {
		return localVarReturnValue, nil, reportError("cloudType is required and must be specified")
	}

	localVarQueryParams.Add("cloudType", parameterToString(*r.cloudType, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiGetMappingStatusRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	cloudType *string
	region *string
}

// Cloud type
func (r ConfigurationMultiCloudApiGetMappingStatusRequest) CloudType(cloudType string) ConfigurationMultiCloudApiGetMappingStatusRequest {
	r.cloudType = &cloudType
	return r
}

// Region
func (r ConfigurationMultiCloudApiGetMappingStatusRequest) Region(region string) ConfigurationMultiCloudApiGetMappingStatusRequest {
	r.region = &region
	return r
}

func (r ConfigurationMultiCloudApiGetMappingStatusRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetMappingStatusExecute(r)
}

/*
GetMappingStatus Method for GetMappingStatus

Get mapping status

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationMultiCloudApiGetMappingStatusRequest
*/
func (a *ConfigurationMultiCloudApiService) GetMappingStatus(ctx context.Context) ConfigurationMultiCloudApiGetMappingStatusRequest {
	return ConfigurationMultiCloudApiGetMappingStatusRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetMappingStatusExecute(r ConfigurationMultiCloudApiGetMappingStatusRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetMappingStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/map/status"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.cloudType != nil {
		localVarQueryParams.Add("cloudType", parameterToString(*r.cloudType, ""))
	}
	if r.region != nil {
		localVarQueryParams.Add("region", parameterToString(*r.region, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiGetMappingSummaryRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	vpnTunnelStatus *bool
	cloudType *string
}

// VPN tunnel status
func (r ConfigurationMultiCloudApiGetMappingSummaryRequest) VpnTunnelStatus(vpnTunnelStatus bool) ConfigurationMultiCloudApiGetMappingSummaryRequest {
	r.vpnTunnelStatus = &vpnTunnelStatus
	return r
}

// Cloud type
func (r ConfigurationMultiCloudApiGetMappingSummaryRequest) CloudType(cloudType string) ConfigurationMultiCloudApiGetMappingSummaryRequest {
	r.cloudType = &cloudType
	return r
}

func (r ConfigurationMultiCloudApiGetMappingSummaryRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetMappingSummaryExecute(r)
}

/*
GetMappingSummary Method for GetMappingSummary

Get mapping summary

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationMultiCloudApiGetMappingSummaryRequest
*/
func (a *ConfigurationMultiCloudApiService) GetMappingSummary(ctx context.Context) ConfigurationMultiCloudApiGetMappingSummaryRequest {
	return ConfigurationMultiCloudApiGetMappingSummaryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetMappingSummaryExecute(r ConfigurationMultiCloudApiGetMappingSummaryRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetMappingSummary")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/map/summary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.vpnTunnelStatus != nil {
		localVarQueryParams.Add("vpnTunnelStatus", parameterToString(*r.vpnTunnelStatus, ""))
	}
	if r.cloudType != nil {
		localVarQueryParams.Add("cloudType", parameterToString(*r.cloudType, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiGetMappingTagsRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	cloudType *string
}

// Cloud type
func (r ConfigurationMultiCloudApiGetMappingTagsRequest) CloudType(cloudType string) ConfigurationMultiCloudApiGetMappingTagsRequest {
	r.cloudType = &cloudType
	return r
}

func (r ConfigurationMultiCloudApiGetMappingTagsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetMappingTagsExecute(r)
}

/*
GetMappingTags Method for GetMappingTags

Get default mapping values

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationMultiCloudApiGetMappingTagsRequest
*/
func (a *ConfigurationMultiCloudApiService) GetMappingTags(ctx context.Context) ConfigurationMultiCloudApiGetMappingTagsRequest {
	return ConfigurationMultiCloudApiGetMappingTagsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetMappingTagsExecute(r ConfigurationMultiCloudApiGetMappingTagsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetMappingTags")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/map/tags"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.cloudType == nil {
		return localVarReturnValue, nil, reportError("cloudType is required and must be specified")
	}

	localVarQueryParams.Add("cloudType", parameterToString(*r.cloudType, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiGetMappingVpnsRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
}

func (r ConfigurationMultiCloudApiGetMappingVpnsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetMappingVpnsExecute(r)
}

/*
GetMappingVpns Method for GetMappingVpns

Get default mapping values

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationMultiCloudApiGetMappingVpnsRequest
*/
func (a *ConfigurationMultiCloudApiService) GetMappingVpns(ctx context.Context) ConfigurationMultiCloudApiGetMappingVpnsRequest {
	return ConfigurationMultiCloudApiGetMappingVpnsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetMappingVpnsExecute(r ConfigurationMultiCloudApiGetMappingVpnsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetMappingVpns")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/map/vpns"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiGetNvaSecurityRulesRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	cloudGatewayName string
	body *map[string]interface{}
}

// Get NVA security Rules
func (r ConfigurationMultiCloudApiGetNvaSecurityRulesRequest) Body(body map[string]interface{}) ConfigurationMultiCloudApiGetNvaSecurityRulesRequest {
	r.body = &body
	return r
}

func (r ConfigurationMultiCloudApiGetNvaSecurityRulesRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetNvaSecurityRulesExecute(r)
}

/*
GetNvaSecurityRules Method for GetNvaSecurityRules

Get NVA Security Rules

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cloudGatewayName Cloud gateway name
 @return ConfigurationMultiCloudApiGetNvaSecurityRulesRequest
*/
func (a *ConfigurationMultiCloudApiService) GetNvaSecurityRules(ctx context.Context, cloudGatewayName string) ConfigurationMultiCloudApiGetNvaSecurityRulesRequest {
	return ConfigurationMultiCloudApiGetNvaSecurityRulesRequest{
		ApiService: a,
		ctx: ctx,
		cloudGatewayName: cloudGatewayName,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetNvaSecurityRulesExecute(r ConfigurationMultiCloudApiGetNvaSecurityRulesRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetNvaSecurityRules")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/cloudgateway/nvaSecurityRules/{cloudGatewayName}"
	localVarPath = strings.Replace(localVarPath, "{"+"cloudGatewayName"+"}", url.PathEscape(parameterToString(r.cloudGatewayName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiGetPartnerPortsRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	edgeType *string
	accountId *string
	cloudType *string
	connectType *string
	vxcPermitted *string
	authorizationKey *string
	refresh *string
}

// Edge type
func (r ConfigurationMultiCloudApiGetPartnerPortsRequest) EdgeType(edgeType string) ConfigurationMultiCloudApiGetPartnerPortsRequest {
	r.edgeType = &edgeType
	return r
}

// Edge Account Id
func (r ConfigurationMultiCloudApiGetPartnerPortsRequest) AccountId(accountId string) ConfigurationMultiCloudApiGetPartnerPortsRequest {
	r.accountId = &accountId
	return r
}

// Cloud Type
func (r ConfigurationMultiCloudApiGetPartnerPortsRequest) CloudType(cloudType string) ConfigurationMultiCloudApiGetPartnerPortsRequest {
	r.cloudType = &cloudType
	return r
}

// Connect Type filter
func (r ConfigurationMultiCloudApiGetPartnerPortsRequest) ConnectType(connectType string) ConfigurationMultiCloudApiGetPartnerPortsRequest {
	r.connectType = &connectType
	return r
}

// VXC Permitted on the port
func (r ConfigurationMultiCloudApiGetPartnerPortsRequest) VxcPermitted(vxcPermitted string) ConfigurationMultiCloudApiGetPartnerPortsRequest {
	r.vxcPermitted = &vxcPermitted
	return r
}

// authorization Key
func (r ConfigurationMultiCloudApiGetPartnerPortsRequest) AuthorizationKey(authorizationKey string) ConfigurationMultiCloudApiGetPartnerPortsRequest {
	r.authorizationKey = &authorizationKey
	return r
}

// Refresh
func (r ConfigurationMultiCloudApiGetPartnerPortsRequest) Refresh(refresh string) ConfigurationMultiCloudApiGetPartnerPortsRequest {
	r.refresh = &refresh
	return r
}

func (r ConfigurationMultiCloudApiGetPartnerPortsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetPartnerPortsExecute(r)
}

/*
GetPartnerPorts Method for GetPartnerPorts

Get partner ports

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationMultiCloudApiGetPartnerPortsRequest
*/
func (a *ConfigurationMultiCloudApiService) GetPartnerPorts(ctx context.Context) ConfigurationMultiCloudApiGetPartnerPortsRequest {
	return ConfigurationMultiCloudApiGetPartnerPortsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetPartnerPortsExecute(r ConfigurationMultiCloudApiGetPartnerPortsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetPartnerPorts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/partnerports/edge"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.edgeType != nil {
		localVarQueryParams.Add("edgeType", parameterToString(*r.edgeType, ""))
	}
	if r.accountId != nil {
		localVarQueryParams.Add("accountId", parameterToString(*r.accountId, ""))
	}
	if r.cloudType != nil {
		localVarQueryParams.Add("cloudType", parameterToString(*r.cloudType, ""))
	}
	if r.connectType != nil {
		localVarQueryParams.Add("connectType", parameterToString(*r.connectType, ""))
	}
	if r.vxcPermitted != nil {
		localVarQueryParams.Add("vxcPermitted", parameterToString(*r.vxcPermitted, ""))
	}
	if r.authorizationKey != nil {
		localVarQueryParams.Add("authorizationKey", parameterToString(*r.authorizationKey, ""))
	}
	if r.refresh != nil {
		localVarQueryParams.Add("refresh", parameterToString(*r.refresh, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiGetPortSpeedRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	edgeType string
	edgeAccountId string
	connectivityType string
	cloudType *string
	cloudAccountId *string
	connectType *string
	connectSubType *string
	connectivityGateway *string
	partnerPort *string
}

// Cloud Service Provider
func (r ConfigurationMultiCloudApiGetPortSpeedRequest) CloudType(cloudType string) ConfigurationMultiCloudApiGetPortSpeedRequest {
	r.cloudType = &cloudType
	return r
}

// Cloud Service Provider Account ID
func (r ConfigurationMultiCloudApiGetPortSpeedRequest) CloudAccountId(cloudAccountId string) ConfigurationMultiCloudApiGetPortSpeedRequest {
	r.cloudAccountId = &cloudAccountId
	return r
}

// Connection Type filter
func (r ConfigurationMultiCloudApiGetPortSpeedRequest) ConnectType(connectType string) ConfigurationMultiCloudApiGetPortSpeedRequest {
	r.connectType = &connectType
	return r
}

// Connection Sub-Type filter
func (r ConfigurationMultiCloudApiGetPortSpeedRequest) ConnectSubType(connectSubType string) ConfigurationMultiCloudApiGetPortSpeedRequest {
	r.connectSubType = &connectSubType
	return r
}

// Connectivity Gateway
func (r ConfigurationMultiCloudApiGetPortSpeedRequest) ConnectivityGateway(connectivityGateway string) ConfigurationMultiCloudApiGetPortSpeedRequest {
	r.connectivityGateway = &connectivityGateway
	return r
}

// partnerPort
func (r ConfigurationMultiCloudApiGetPortSpeedRequest) PartnerPort(partnerPort string) ConfigurationMultiCloudApiGetPortSpeedRequest {
	r.partnerPort = &partnerPort
	return r
}

func (r ConfigurationMultiCloudApiGetPortSpeedRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetPortSpeedExecute(r)
}

/*
GetPortSpeed Method for GetPortSpeed

Get supported port speed

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param edgeType Interconnect Provider
 @param edgeAccountId Interconnect Provider Account ID
 @param connectivityType Interconnect Connectivity Type
 @return ConfigurationMultiCloudApiGetPortSpeedRequest
*/
func (a *ConfigurationMultiCloudApiService) GetPortSpeed(ctx context.Context, edgeType string, edgeAccountId string, connectivityType string) ConfigurationMultiCloudApiGetPortSpeedRequest {
	return ConfigurationMultiCloudApiGetPortSpeedRequest{
		ApiService: a,
		ctx: ctx,
		edgeType: edgeType,
		edgeAccountId: edgeAccountId,
		connectivityType: connectivityType,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetPortSpeedExecute(r ConfigurationMultiCloudApiGetPortSpeedRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetPortSpeed")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/portSpeed/edge/{edgeType}/{edgeAccountId}/{connectivityType}"
	localVarPath = strings.Replace(localVarPath, "{"+"edgeType"+"}", url.PathEscape(parameterToString(r.edgeType, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"edgeAccountId"+"}", url.PathEscape(parameterToString(r.edgeAccountId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"connectivityType"+"}", url.PathEscape(parameterToString(r.connectivityType, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.cloudType != nil {
		localVarQueryParams.Add("cloudType", parameterToString(*r.cloudType, ""))
	}
	if r.cloudAccountId != nil {
		localVarQueryParams.Add("cloudAccountId", parameterToString(*r.cloudAccountId, ""))
	}
	if r.connectType != nil {
		localVarQueryParams.Add("connectType", parameterToString(*r.connectType, ""))
	}
	if r.connectSubType != nil {
		localVarQueryParams.Add("connectSubType", parameterToString(*r.connectSubType, ""))
	}
	if r.connectivityGateway != nil {
		localVarQueryParams.Add("connectivityGateway", parameterToString(*r.connectivityGateway, ""))
	}
	if r.partnerPort != nil {
		localVarQueryParams.Add("partnerPort", parameterToString(*r.partnerPort, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiGetPostAggregationDataByQuery25Request struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	body *map[string]interface{}
}

// Stats query string
func (r ConfigurationMultiCloudApiGetPostAggregationDataByQuery25Request) Body(body map[string]interface{}) ConfigurationMultiCloudApiGetPostAggregationDataByQuery25Request {
	r.body = &body
	return r
}

func (r ConfigurationMultiCloudApiGetPostAggregationDataByQuery25Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetPostAggregationDataByQuery25Execute(r)
}

/*
GetPostAggregationDataByQuery25 Method for GetPostAggregationDataByQuery25

Get aggregated data based on input query and filters. The data can be filtered on time and other unique parameters based upon necessity and intended usage

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationMultiCloudApiGetPostAggregationDataByQuery25Request
*/
func (a *ConfigurationMultiCloudApiService) GetPostAggregationDataByQuery25(ctx context.Context) ConfigurationMultiCloudApiGetPostAggregationDataByQuery25Request {
	return ConfigurationMultiCloudApiGetPostAggregationDataByQuery25Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetPostAggregationDataByQuery25Execute(r ConfigurationMultiCloudApiGetPostAggregationDataByQuery25Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetPostAggregationDataByQuery25")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/statistics/interface/aggregation"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiGetSitesRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	color *string
	attached *bool
}

// Color
func (r ConfigurationMultiCloudApiGetSitesRequest) Color(color string) ConfigurationMultiCloudApiGetSitesRequest {
	r.color = &color
	return r
}

// Is endpoint attached
func (r ConfigurationMultiCloudApiGetSitesRequest) Attached(attached bool) ConfigurationMultiCloudApiGetSitesRequest {
	r.attached = &attached
	return r
}

func (r ConfigurationMultiCloudApiGetSitesRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetSitesExecute(r)
}

/*
GetSites Method for GetSites

Get available sites

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationMultiCloudApiGetSitesRequest
*/
func (a *ConfigurationMultiCloudApiService) GetSites(ctx context.Context) ConfigurationMultiCloudApiGetSitesRequest {
	return ConfigurationMultiCloudApiGetSitesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetSitesExecute(r ConfigurationMultiCloudApiGetSitesRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetSites")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/site"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.color != nil {
		localVarQueryParams.Add("color", parameterToString(*r.color, ""))
	}
	if r.attached != nil {
		localVarQueryParams.Add("attached", parameterToString(*r.attached, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiGetSites1Request struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	cloudGatewayName string
	systemIp *string
	siteId *string
	color *string
	vpnTunnelStatus *bool
}

// System IP
func (r ConfigurationMultiCloudApiGetSites1Request) SystemIp(systemIp string) ConfigurationMultiCloudApiGetSites1Request {
	r.systemIp = &systemIp
	return r
}

// Site Id
func (r ConfigurationMultiCloudApiGetSites1Request) SiteId(siteId string) ConfigurationMultiCloudApiGetSites1Request {
	r.siteId = &siteId
	return r
}

// Color
func (r ConfigurationMultiCloudApiGetSites1Request) Color(color string) ConfigurationMultiCloudApiGetSites1Request {
	r.color = &color
	return r
}

// Fetch vpnTunnelStatus
func (r ConfigurationMultiCloudApiGetSites1Request) VpnTunnelStatus(vpnTunnelStatus bool) ConfigurationMultiCloudApiGetSites1Request {
	r.vpnTunnelStatus = &vpnTunnelStatus
	return r
}

func (r ConfigurationMultiCloudApiGetSites1Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetSites1Execute(r)
}

/*
GetSites1 Method for GetSites1

Get sites attached to CGW

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cloudGatewayName Cloud gateway name
 @return ConfigurationMultiCloudApiGetSites1Request
*/
func (a *ConfigurationMultiCloudApiService) GetSites1(ctx context.Context, cloudGatewayName string) ConfigurationMultiCloudApiGetSites1Request {
	return ConfigurationMultiCloudApiGetSites1Request{
		ApiService: a,
		ctx: ctx,
		cloudGatewayName: cloudGatewayName,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetSites1Execute(r ConfigurationMultiCloudApiGetSites1Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetSites1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/cloudgateway/{cloudGatewayName}/site"
	localVarPath = strings.Replace(localVarPath, "{"+"cloudGatewayName"+"}", url.PathEscape(parameterToString(r.cloudGatewayName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.systemIp != nil {
		localVarQueryParams.Add("systemIp", parameterToString(*r.systemIp, ""))
	}
	if r.siteId != nil {
		localVarQueryParams.Add("siteId", parameterToString(*r.siteId, ""))
	}
	if r.color != nil {
		localVarQueryParams.Add("color", parameterToString(*r.color, ""))
	}
	if r.vpnTunnelStatus != nil {
		localVarQueryParams.Add("vpnTunnelStatus", parameterToString(*r.vpnTunnelStatus, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiGetSshKeyListRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	cloudType *string
	accountId *string
	cloudRegion *string
}

// Cloud type
func (r ConfigurationMultiCloudApiGetSshKeyListRequest) CloudType(cloudType string) ConfigurationMultiCloudApiGetSshKeyListRequest {
	r.cloudType = &cloudType
	return r
}

// Account Id
func (r ConfigurationMultiCloudApiGetSshKeyListRequest) AccountId(accountId string) ConfigurationMultiCloudApiGetSshKeyListRequest {
	r.accountId = &accountId
	return r
}

// Region
func (r ConfigurationMultiCloudApiGetSshKeyListRequest) CloudRegion(cloudRegion string) ConfigurationMultiCloudApiGetSshKeyListRequest {
	r.cloudRegion = &cloudRegion
	return r
}

func (r ConfigurationMultiCloudApiGetSshKeyListRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetSshKeyListExecute(r)
}

/*
GetSshKeyList Method for GetSshKeyList

Get SSH keys

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationMultiCloudApiGetSshKeyListRequest
*/
func (a *ConfigurationMultiCloudApiService) GetSshKeyList(ctx context.Context) ConfigurationMultiCloudApiGetSshKeyListRequest {
	return ConfigurationMultiCloudApiGetSshKeyListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetSshKeyListExecute(r ConfigurationMultiCloudApiGetSshKeyListRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetSshKeyList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/sshkeys"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.cloudType == nil {
		return localVarReturnValue, nil, reportError("cloudType is required and must be specified")
	}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.cloudRegion == nil {
		return localVarReturnValue, nil, reportError("cloudRegion is required and must be specified")
	}

	localVarQueryParams.Add("cloudType", parameterToString(*r.cloudType, ""))
	localVarQueryParams.Add("accountId", parameterToString(*r.accountId, ""))
	localVarQueryParams.Add("cloudRegion", parameterToString(*r.cloudRegion, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiGetSupportedEdgeImageNamesRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	edgeType *string
}

// Edge type
func (r ConfigurationMultiCloudApiGetSupportedEdgeImageNamesRequest) EdgeType(edgeType string) ConfigurationMultiCloudApiGetSupportedEdgeImageNamesRequest {
	r.edgeType = &edgeType
	return r
}

func (r ConfigurationMultiCloudApiGetSupportedEdgeImageNamesRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetSupportedEdgeImageNamesExecute(r)
}

/*
GetSupportedEdgeImageNames Method for GetSupportedEdgeImageNames

Get Edge provider supported images

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationMultiCloudApiGetSupportedEdgeImageNamesRequest
*/
func (a *ConfigurationMultiCloudApiService) GetSupportedEdgeImageNames(ctx context.Context) ConfigurationMultiCloudApiGetSupportedEdgeImageNamesRequest {
	return ConfigurationMultiCloudApiGetSupportedEdgeImageNamesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetSupportedEdgeImageNamesExecute(r ConfigurationMultiCloudApiGetSupportedEdgeImageNamesRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetSupportedEdgeImageNames")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/imagename/edge"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.edgeType != nil {
		localVarQueryParams.Add("edgeType", parameterToString(*r.edgeType, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiGetSupportedEdgeInstanceSizeRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	edgeType *string
}

// Edge type
func (r ConfigurationMultiCloudApiGetSupportedEdgeInstanceSizeRequest) EdgeType(edgeType string) ConfigurationMultiCloudApiGetSupportedEdgeInstanceSizeRequest {
	r.edgeType = &edgeType
	return r
}

func (r ConfigurationMultiCloudApiGetSupportedEdgeInstanceSizeRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetSupportedEdgeInstanceSizeExecute(r)
}

/*
GetSupportedEdgeInstanceSize Method for GetSupportedEdgeInstanceSize

Get Edge provider supported size

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationMultiCloudApiGetSupportedEdgeInstanceSizeRequest
*/
func (a *ConfigurationMultiCloudApiService) GetSupportedEdgeInstanceSize(ctx context.Context) ConfigurationMultiCloudApiGetSupportedEdgeInstanceSizeRequest {
	return ConfigurationMultiCloudApiGetSupportedEdgeInstanceSizeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetSupportedEdgeInstanceSizeExecute(r ConfigurationMultiCloudApiGetSupportedEdgeInstanceSizeRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetSupportedEdgeInstanceSize")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/instancesize/edge"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.edgeType != nil {
		localVarQueryParams.Add("edgeType", parameterToString(*r.edgeType, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiGetSupportedInstanceSizeRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	cloudType *string
	accountId *string
	cloudRegion *string
}

func (r ConfigurationMultiCloudApiGetSupportedInstanceSizeRequest) CloudType(cloudType string) ConfigurationMultiCloudApiGetSupportedInstanceSizeRequest {
	r.cloudType = &cloudType
	return r
}

func (r ConfigurationMultiCloudApiGetSupportedInstanceSizeRequest) AccountId(accountId string) ConfigurationMultiCloudApiGetSupportedInstanceSizeRequest {
	r.accountId = &accountId
	return r
}

func (r ConfigurationMultiCloudApiGetSupportedInstanceSizeRequest) CloudRegion(cloudRegion string) ConfigurationMultiCloudApiGetSupportedInstanceSizeRequest {
	r.cloudRegion = &cloudRegion
	return r
}

func (r ConfigurationMultiCloudApiGetSupportedInstanceSizeRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetSupportedInstanceSizeExecute(r)
}

/*
GetSupportedInstanceSize Method for GetSupportedInstanceSize

Get Transit VPC supported size

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationMultiCloudApiGetSupportedInstanceSizeRequest
*/
func (a *ConfigurationMultiCloudApiService) GetSupportedInstanceSize(ctx context.Context) ConfigurationMultiCloudApiGetSupportedInstanceSizeRequest {
	return ConfigurationMultiCloudApiGetSupportedInstanceSizeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetSupportedInstanceSizeExecute(r ConfigurationMultiCloudApiGetSupportedInstanceSizeRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetSupportedInstanceSize")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/instancesize"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.cloudType == nil {
		return localVarReturnValue, nil, reportError("cloudType is required and must be specified")
	}

	localVarQueryParams.Add("cloudType", parameterToString(*r.cloudType, ""))
	if r.accountId != nil {
		localVarQueryParams.Add("accountId", parameterToString(*r.accountId, ""))
	}
	if r.cloudRegion != nil {
		localVarQueryParams.Add("cloudRegion", parameterToString(*r.cloudRegion, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiGetSupportedLoopbackCgwColorsRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
}

func (r ConfigurationMultiCloudApiGetSupportedLoopbackCgwColorsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetSupportedLoopbackCgwColorsExecute(r)
}

/*
GetSupportedLoopbackCgwColors Method for GetSupportedLoopbackCgwColors

Get Edge Loopback CGW supported colors

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationMultiCloudApiGetSupportedLoopbackCgwColorsRequest
*/
func (a *ConfigurationMultiCloudApiService) GetSupportedLoopbackCgwColors(ctx context.Context) ConfigurationMultiCloudApiGetSupportedLoopbackCgwColorsRequest {
	return ConfigurationMultiCloudApiGetSupportedLoopbackCgwColorsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetSupportedLoopbackCgwColorsExecute(r ConfigurationMultiCloudApiGetSupportedLoopbackCgwColorsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetSupportedLoopbackCgwColors")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/loopbackCGWColor/edge"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiGetSupportedSoftwareImageListRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	cloudType *string
	accountId *string
	cloudRegion *string
}

// Cloud type
func (r ConfigurationMultiCloudApiGetSupportedSoftwareImageListRequest) CloudType(cloudType string) ConfigurationMultiCloudApiGetSupportedSoftwareImageListRequest {
	r.cloudType = &cloudType
	return r
}

// Account Id
func (r ConfigurationMultiCloudApiGetSupportedSoftwareImageListRequest) AccountId(accountId string) ConfigurationMultiCloudApiGetSupportedSoftwareImageListRequest {
	r.accountId = &accountId
	return r
}

// Region
func (r ConfigurationMultiCloudApiGetSupportedSoftwareImageListRequest) CloudRegion(cloudRegion string) ConfigurationMultiCloudApiGetSupportedSoftwareImageListRequest {
	r.cloudRegion = &cloudRegion
	return r
}

func (r ConfigurationMultiCloudApiGetSupportedSoftwareImageListRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetSupportedSoftwareImageListExecute(r)
}

/*
GetSupportedSoftwareImageList Method for GetSupportedSoftwareImageList

Get software image list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationMultiCloudApiGetSupportedSoftwareImageListRequest
*/
func (a *ConfigurationMultiCloudApiService) GetSupportedSoftwareImageList(ctx context.Context) ConfigurationMultiCloudApiGetSupportedSoftwareImageListRequest {
	return ConfigurationMultiCloudApiGetSupportedSoftwareImageListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetSupportedSoftwareImageListExecute(r ConfigurationMultiCloudApiGetSupportedSoftwareImageListRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetSupportedSoftwareImageList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/swimages"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.cloudType == nil {
		return localVarReturnValue, nil, reportError("cloudType is required and must be specified")
	}

	localVarQueryParams.Add("cloudType", parameterToString(*r.cloudType, ""))
	if r.accountId != nil {
		localVarQueryParams.Add("accountId", parameterToString(*r.accountId, ""))
	}
	if r.cloudRegion != nil {
		localVarQueryParams.Add("cloudRegion", parameterToString(*r.cloudRegion, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiGetTunnelNamesRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	cloudType string
	cloudGatewayName *string
}

// Cloud gateway name
func (r ConfigurationMultiCloudApiGetTunnelNamesRequest) CloudGatewayName(cloudGatewayName string) ConfigurationMultiCloudApiGetTunnelNamesRequest {
	r.cloudGatewayName = &cloudGatewayName
	return r
}

func (r ConfigurationMultiCloudApiGetTunnelNamesRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetTunnelNamesExecute(r)
}

/*
GetTunnelNames Method for GetTunnelNames

Get tunnel names

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cloudType Cloud type
 @return ConfigurationMultiCloudApiGetTunnelNamesRequest
*/
func (a *ConfigurationMultiCloudApiService) GetTunnelNames(ctx context.Context, cloudType string) ConfigurationMultiCloudApiGetTunnelNamesRequest {
	return ConfigurationMultiCloudApiGetTunnelNamesRequest{
		ApiService: a,
		ctx: ctx,
		cloudType: cloudType,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetTunnelNamesExecute(r ConfigurationMultiCloudApiGetTunnelNamesRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetTunnelNames")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/tunnels/{cloudType}"
	localVarPath = strings.Replace(localVarPath, "{"+"cloudType"+"}", url.PathEscape(parameterToString(r.cloudType, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.cloudGatewayName != nil {
		localVarQueryParams.Add("cloudGatewayName", parameterToString(*r.cloudGatewayName, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiGetVHubsRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	cloudType *string
	accountId *string
	resourceGroup *string
	vWanName *string
	vNetTags *string
}

// Cloud Type
func (r ConfigurationMultiCloudApiGetVHubsRequest) CloudType(cloudType string) ConfigurationMultiCloudApiGetVHubsRequest {
	r.cloudType = &cloudType
	return r
}

// Account Id
func (r ConfigurationMultiCloudApiGetVHubsRequest) AccountId(accountId string) ConfigurationMultiCloudApiGetVHubsRequest {
	r.accountId = &accountId
	return r
}

// Resource Group
func (r ConfigurationMultiCloudApiGetVHubsRequest) ResourceGroup(resourceGroup string) ConfigurationMultiCloudApiGetVHubsRequest {
	r.resourceGroup = &resourceGroup
	return r
}

// VWan Name
func (r ConfigurationMultiCloudApiGetVHubsRequest) VWanName(vWanName string) ConfigurationMultiCloudApiGetVHubsRequest {
	r.vWanName = &vWanName
	return r
}

// VNet Tags
func (r ConfigurationMultiCloudApiGetVHubsRequest) VNetTags(vNetTags string) ConfigurationMultiCloudApiGetVHubsRequest {
	r.vNetTags = &vNetTags
	return r
}

func (r ConfigurationMultiCloudApiGetVHubsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetVHubsExecute(r)
}

/*
GetVHubs Method for GetVHubs

Get Virtual Hubs

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationMultiCloudApiGetVHubsRequest
*/
func (a *ConfigurationMultiCloudApiService) GetVHubs(ctx context.Context) ConfigurationMultiCloudApiGetVHubsRequest {
	return ConfigurationMultiCloudApiGetVHubsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetVHubsExecute(r ConfigurationMultiCloudApiGetVHubsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetVHubs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/vhubs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.cloudType != nil {
		localVarQueryParams.Add("cloudType", parameterToString(*r.cloudType, ""))
	}
	if r.accountId != nil {
		localVarQueryParams.Add("accountId", parameterToString(*r.accountId, ""))
	}
	if r.resourceGroup != nil {
		localVarQueryParams.Add("resourceGroup", parameterToString(*r.resourceGroup, ""))
	}
	if r.vWanName != nil {
		localVarQueryParams.Add("vWanName", parameterToString(*r.vWanName, ""))
	}
	if r.vNetTags != nil {
		localVarQueryParams.Add("vNetTags", parameterToString(*r.vNetTags, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiGetVWansRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	accountId *string
	cloudType *string
	resourceGroup *string
	refresh *string
}

// Account Id
func (r ConfigurationMultiCloudApiGetVWansRequest) AccountId(accountId string) ConfigurationMultiCloudApiGetVWansRequest {
	r.accountId = &accountId
	return r
}

// Cloud Type
func (r ConfigurationMultiCloudApiGetVWansRequest) CloudType(cloudType string) ConfigurationMultiCloudApiGetVWansRequest {
	r.cloudType = &cloudType
	return r
}

// Resource Group
func (r ConfigurationMultiCloudApiGetVWansRequest) ResourceGroup(resourceGroup string) ConfigurationMultiCloudApiGetVWansRequest {
	r.resourceGroup = &resourceGroup
	return r
}

// Refresh
func (r ConfigurationMultiCloudApiGetVWansRequest) Refresh(refresh string) ConfigurationMultiCloudApiGetVWansRequest {
	r.refresh = &refresh
	return r
}

func (r ConfigurationMultiCloudApiGetVWansRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetVWansExecute(r)
}

/*
GetVWans Method for GetVWans

Get Virtual Wans

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationMultiCloudApiGetVWansRequest
*/
func (a *ConfigurationMultiCloudApiService) GetVWans(ctx context.Context) ConfigurationMultiCloudApiGetVWansRequest {
	return ConfigurationMultiCloudApiGetVWansRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetVWansExecute(r ConfigurationMultiCloudApiGetVWansRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetVWans")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/vwans"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.accountId != nil {
		localVarQueryParams.Add("accountId", parameterToString(*r.accountId, ""))
	}
	if r.cloudType != nil {
		localVarQueryParams.Add("cloudType", parameterToString(*r.cloudType, ""))
	}
	if r.resourceGroup != nil {
		localVarQueryParams.Add("resourceGroup", parameterToString(*r.resourceGroup, ""))
	}
	if r.refresh != nil {
		localVarQueryParams.Add("refresh", parameterToString(*r.refresh, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiGetVpcTagsRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	cloudType *string
	region *string
	tagName *string
}

// Cloud type
func (r ConfigurationMultiCloudApiGetVpcTagsRequest) CloudType(cloudType string) ConfigurationMultiCloudApiGetVpcTagsRequest {
	r.cloudType = &cloudType
	return r
}

// Region
func (r ConfigurationMultiCloudApiGetVpcTagsRequest) Region(region string) ConfigurationMultiCloudApiGetVpcTagsRequest {
	r.region = &region
	return r
}

// Tag name
func (r ConfigurationMultiCloudApiGetVpcTagsRequest) TagName(tagName string) ConfigurationMultiCloudApiGetVpcTagsRequest {
	r.tagName = &tagName
	return r
}

func (r ConfigurationMultiCloudApiGetVpcTagsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetVpcTagsExecute(r)
}

/*
GetVpcTags Method for GetVpcTags

Get vpc tags

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationMultiCloudApiGetVpcTagsRequest
*/
func (a *ConfigurationMultiCloudApiService) GetVpcTags(ctx context.Context) ConfigurationMultiCloudApiGetVpcTagsRequest {
	return ConfigurationMultiCloudApiGetVpcTagsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetVpcTagsExecute(r ConfigurationMultiCloudApiGetVpcTagsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetVpcTags")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/hostvpc/tags"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.cloudType == nil {
		return localVarReturnValue, nil, reportError("cloudType is required and must be specified")
	}

	localVarQueryParams.Add("cloudType", parameterToString(*r.cloudType, ""))
	if r.region != nil {
		localVarQueryParams.Add("region", parameterToString(*r.region, ""))
	}
	if r.tagName != nil {
		localVarQueryParams.Add("tagName", parameterToString(*r.tagName, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiGetWanDevicesRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
}

func (r ConfigurationMultiCloudApiGetWanDevicesRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetWanDevicesExecute(r)
}

/*
GetWanDevices Method for GetWanDevices

Get available WAN edge devices

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationMultiCloudApiGetWanDevicesRequest
*/
func (a *ConfigurationMultiCloudApiService) GetWanDevices(ctx context.Context) ConfigurationMultiCloudApiGetWanDevicesRequest {
	return ConfigurationMultiCloudApiGetWanDevicesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetWanDevicesExecute(r ConfigurationMultiCloudApiGetWanDevicesRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetWanDevices")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/device"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiGetWanInterfaceColorsRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
}

func (r ConfigurationMultiCloudApiGetWanInterfaceColorsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetWanInterfaceColorsExecute(r)
}

/*
GetWanInterfaceColors Method for GetWanInterfaceColors

Get WAN interface colors

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationMultiCloudApiGetWanInterfaceColorsRequest
*/
func (a *ConfigurationMultiCloudApiService) GetWanInterfaceColors(ctx context.Context) ConfigurationMultiCloudApiGetWanInterfaceColorsRequest {
	return ConfigurationMultiCloudApiGetWanInterfaceColorsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetWanInterfaceColorsExecute(r ConfigurationMultiCloudApiGetWanInterfaceColorsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetWanInterfaceColors")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/interfacecolor"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiHostvpcTaggingRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	body *map[string]interface{}
}

// VPC tag
func (r ConfigurationMultiCloudApiHostvpcTaggingRequest) Body(body map[string]interface{}) ConfigurationMultiCloudApiHostvpcTaggingRequest {
	r.body = &body
	return r
}

func (r ConfigurationMultiCloudApiHostvpcTaggingRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.HostvpcTaggingExecute(r)
}

/*
HostvpcTagging Method for HostvpcTagging

Tag a VPC

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationMultiCloudApiHostvpcTaggingRequest
*/
func (a *ConfigurationMultiCloudApiService) HostvpcTagging(ctx context.Context) ConfigurationMultiCloudApiHostvpcTaggingRequest {
	return ConfigurationMultiCloudApiHostvpcTaggingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) HostvpcTaggingExecute(r ConfigurationMultiCloudApiHostvpcTaggingRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.HostvpcTagging")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/hostvpc/tags"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiProcessMappingRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	body *map[string]interface{}
}

// VPC mapping
func (r ConfigurationMultiCloudApiProcessMappingRequest) Body(body map[string]interface{}) ConfigurationMultiCloudApiProcessMappingRequest {
	r.body = &body
	return r
}

func (r ConfigurationMultiCloudApiProcessMappingRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ProcessMappingExecute(r)
}

/*
ProcessMapping Method for ProcessMapping

Process intent of connecting VPNs with VPCs through cloud gateway

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationMultiCloudApiProcessMappingRequest
*/
func (a *ConfigurationMultiCloudApiService) ProcessMapping(ctx context.Context) ConfigurationMultiCloudApiProcessMappingRequest {
	return ConfigurationMultiCloudApiProcessMappingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) ProcessMappingExecute(r ConfigurationMultiCloudApiProcessMappingRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.ProcessMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/map"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiTelemetryRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	body *map[string]interface{}
}

// telemetry
func (r ConfigurationMultiCloudApiTelemetryRequest) Body(body map[string]interface{}) ConfigurationMultiCloudApiTelemetryRequest {
	r.body = &body
	return r
}

func (r ConfigurationMultiCloudApiTelemetryRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.TelemetryExecute(r)
}

/*
Telemetry Method for Telemetry

reports telemetry data

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationMultiCloudApiTelemetryRequest
*/
func (a *ConfigurationMultiCloudApiService) Telemetry(ctx context.Context) ConfigurationMultiCloudApiTelemetryRequest {
	return ConfigurationMultiCloudApiTelemetryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) TelemetryExecute(r ConfigurationMultiCloudApiTelemetryRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.Telemetry")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/telemetry"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiTunnelScalingRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	cloudGatewayName string
	body *map[string]interface{}
}

// Site information
func (r ConfigurationMultiCloudApiTunnelScalingRequest) Body(body map[string]interface{}) ConfigurationMultiCloudApiTunnelScalingRequest {
	r.body = &body
	return r
}

func (r ConfigurationMultiCloudApiTunnelScalingRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.TunnelScalingExecute(r)
}

/*
TunnelScaling Method for TunnelScaling

Update tunnel scaling and accelerated vpn parameter for a branch endpoint

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cloudGatewayName Cloud gateway name
 @return ConfigurationMultiCloudApiTunnelScalingRequest
*/
func (a *ConfigurationMultiCloudApiService) TunnelScaling(ctx context.Context, cloudGatewayName string) ConfigurationMultiCloudApiTunnelScalingRequest {
	return ConfigurationMultiCloudApiTunnelScalingRequest{
		ApiService: a,
		ctx: ctx,
		cloudGatewayName: cloudGatewayName,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) TunnelScalingExecute(r ConfigurationMultiCloudApiTunnelScalingRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.TunnelScaling")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/cloudgateway/{cloudGatewayName}/site"
	localVarPath = strings.Replace(localVarPath, "{"+"cloudGatewayName"+"}", url.PathEscape(parameterToString(r.cloudGatewayName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiUnTagRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	tagName string
}

func (r ConfigurationMultiCloudApiUnTagRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.UnTagExecute(r)
}

/*
UnTag Method for UnTag

Delete a tag

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tagName Tag name
 @return ConfigurationMultiCloudApiUnTagRequest
*/
func (a *ConfigurationMultiCloudApiService) UnTag(ctx context.Context, tagName string) ConfigurationMultiCloudApiUnTagRequest {
	return ConfigurationMultiCloudApiUnTagRequest{
		ApiService: a,
		ctx: ctx,
		tagName: tagName,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) UnTagExecute(r ConfigurationMultiCloudApiUnTagRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.UnTag")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/hostvpc/tags/{tagName}"
	localVarPath = strings.Replace(localVarPath, "{"+"tagName"+"}", url.PathEscape(parameterToString(r.tagName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiUpdateAccountRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	accountId string
	body *map[string]interface{}
}

// Multicloud account info
func (r ConfigurationMultiCloudApiUpdateAccountRequest) Body(body map[string]interface{}) ConfigurationMultiCloudApiUpdateAccountRequest {
	r.body = &body
	return r
}

func (r ConfigurationMultiCloudApiUpdateAccountRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateAccountExecute(r)
}

/*
UpdateAccount Method for UpdateAccount

Update multicloud account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId Account Id
 @return ConfigurationMultiCloudApiUpdateAccountRequest
*/
func (a *ConfigurationMultiCloudApiService) UpdateAccount(ctx context.Context, accountId string) ConfigurationMultiCloudApiUpdateAccountRequest {
	return ConfigurationMultiCloudApiUpdateAccountRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
	}
}

// Execute executes the request
func (a *ConfigurationMultiCloudApiService) UpdateAccountExecute(r ConfigurationMultiCloudApiUpdateAccountRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.UpdateAccount")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/accounts/{accountId}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterToString(r.accountId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiUpdateCgwRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	cloudGatewayName string
	body *map[string]interface{}
}

// Cloud gateway
func (r ConfigurationMultiCloudApiUpdateCgwRequest) Body(body map[string]interface{}) ConfigurationMultiCloudApiUpdateCgwRequest {
	r.body = &body
	return r
}

func (r ConfigurationMultiCloudApiUpdateCgwRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.UpdateCgwExecute(r)
}

/*
UpdateCgw Method for UpdateCgw

Update cloud gateway

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cloudGatewayName
 @return ConfigurationMultiCloudApiUpdateCgwRequest
*/
func (a *ConfigurationMultiCloudApiService) UpdateCgw(ctx context.Context, cloudGatewayName string) ConfigurationMultiCloudApiUpdateCgwRequest {
	return ConfigurationMultiCloudApiUpdateCgwRequest{
		ApiService: a,
		ctx: ctx,
		cloudGatewayName: cloudGatewayName,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) UpdateCgwExecute(r ConfigurationMultiCloudApiUpdateCgwRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.UpdateCgw")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/cloudgateway/{cloudGatewayName}"
	localVarPath = strings.Replace(localVarPath, "{"+"cloudGatewayName"+"}", url.PathEscape(parameterToString(r.cloudGatewayName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiUpdateDeviceLinkRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	body *map[string]interface{}
}

// Device Link
func (r ConfigurationMultiCloudApiUpdateDeviceLinkRequest) Body(body map[string]interface{}) ConfigurationMultiCloudApiUpdateDeviceLinkRequest {
	r.body = &body
	return r
}

func (r ConfigurationMultiCloudApiUpdateDeviceLinkRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.UpdateDeviceLinkExecute(r)
}

/*
UpdateDeviceLink Method for UpdateDeviceLink

Update Device Link

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationMultiCloudApiUpdateDeviceLinkRequest
*/
func (a *ConfigurationMultiCloudApiService) UpdateDeviceLink(ctx context.Context) ConfigurationMultiCloudApiUpdateDeviceLinkRequest {
	return ConfigurationMultiCloudApiUpdateDeviceLinkRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) UpdateDeviceLinkExecute(r ConfigurationMultiCloudApiUpdateDeviceLinkRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.UpdateDeviceLink")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/devicelink/edge"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiUpdateEdgeAccountRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	accountId string
	body *map[string]interface{}
}

// Multicloud edge account info
func (r ConfigurationMultiCloudApiUpdateEdgeAccountRequest) Body(body map[string]interface{}) ConfigurationMultiCloudApiUpdateEdgeAccountRequest {
	r.body = &body
	return r
}

func (r ConfigurationMultiCloudApiUpdateEdgeAccountRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateEdgeAccountExecute(r)
}

/*
UpdateEdgeAccount Method for UpdateEdgeAccount

Update Multicloud edge account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId Multicloud Edge Account Id
 @return ConfigurationMultiCloudApiUpdateEdgeAccountRequest
*/
func (a *ConfigurationMultiCloudApiService) UpdateEdgeAccount(ctx context.Context, accountId string) ConfigurationMultiCloudApiUpdateEdgeAccountRequest {
	return ConfigurationMultiCloudApiUpdateEdgeAccountRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
	}
}

// Execute executes the request
func (a *ConfigurationMultiCloudApiService) UpdateEdgeAccountExecute(r ConfigurationMultiCloudApiUpdateEdgeAccountRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.UpdateEdgeAccount")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/accounts/edge/{accountId}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterToString(r.accountId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiUpdateEdgeConnectivityRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	body *map[string]interface{}
}

// Edge connectivity
func (r ConfigurationMultiCloudApiUpdateEdgeConnectivityRequest) Body(body map[string]interface{}) ConfigurationMultiCloudApiUpdateEdgeConnectivityRequest {
	r.body = &body
	return r
}

func (r ConfigurationMultiCloudApiUpdateEdgeConnectivityRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.UpdateEdgeConnectivityExecute(r)
}

/*
UpdateEdgeConnectivity Method for UpdateEdgeConnectivity

Update Interconnect connectivity

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationMultiCloudApiUpdateEdgeConnectivityRequest
*/
func (a *ConfigurationMultiCloudApiService) UpdateEdgeConnectivity(ctx context.Context) ConfigurationMultiCloudApiUpdateEdgeConnectivityRequest {
	return ConfigurationMultiCloudApiUpdateEdgeConnectivityRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) UpdateEdgeConnectivityExecute(r ConfigurationMultiCloudApiUpdateEdgeConnectivityRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.UpdateEdgeConnectivity")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/connectivity/edge"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiUpdateEdgeGlobalSettingsRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	body *map[string]interface{}
}

// Global setting
func (r ConfigurationMultiCloudApiUpdateEdgeGlobalSettingsRequest) Body(body map[string]interface{}) ConfigurationMultiCloudApiUpdateEdgeGlobalSettingsRequest {
	r.body = &body
	return r
}

func (r ConfigurationMultiCloudApiUpdateEdgeGlobalSettingsRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateEdgeGlobalSettingsExecute(r)
}

/*
UpdateEdgeGlobalSettings Method for UpdateEdgeGlobalSettings

Update edge global settings for Edge provider

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationMultiCloudApiUpdateEdgeGlobalSettingsRequest
*/
func (a *ConfigurationMultiCloudApiService) UpdateEdgeGlobalSettings(ctx context.Context) ConfigurationMultiCloudApiUpdateEdgeGlobalSettingsRequest {
	return ConfigurationMultiCloudApiUpdateEdgeGlobalSettingsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ConfigurationMultiCloudApiService) UpdateEdgeGlobalSettingsExecute(r ConfigurationMultiCloudApiUpdateEdgeGlobalSettingsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.UpdateEdgeGlobalSettings")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/settings/edge/global"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiUpdateEdgeLocationsInfoRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	edgeType string
	accountId string
}

func (r ConfigurationMultiCloudApiUpdateEdgeLocationsInfoRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.UpdateEdgeLocationsInfoExecute(r)
}

/*
UpdateEdgeLocationsInfo Method for UpdateEdgeLocationsInfo

Update Edge Locations

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param edgeType Edge Type
 @param accountId Edge Account Id
 @return ConfigurationMultiCloudApiUpdateEdgeLocationsInfoRequest
*/
func (a *ConfigurationMultiCloudApiService) UpdateEdgeLocationsInfo(ctx context.Context, edgeType string, accountId string) ConfigurationMultiCloudApiUpdateEdgeLocationsInfoRequest {
	return ConfigurationMultiCloudApiUpdateEdgeLocationsInfoRequest{
		ApiService: a,
		ctx: ctx,
		edgeType: edgeType,
		accountId: accountId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) UpdateEdgeLocationsInfoExecute(r ConfigurationMultiCloudApiUpdateEdgeLocationsInfoRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.UpdateEdgeLocationsInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/locations/edge/{edgeType}/accountId/{accountId}"
	localVarPath = strings.Replace(localVarPath, "{"+"edgeType"+"}", url.PathEscape(parameterToString(r.edgeType, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterToString(r.accountId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiUpdateGlobalSettingsRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	body *map[string]interface{}
}

// Global setting
func (r ConfigurationMultiCloudApiUpdateGlobalSettingsRequest) Body(body map[string]interface{}) ConfigurationMultiCloudApiUpdateGlobalSettingsRequest {
	r.body = &body
	return r
}

func (r ConfigurationMultiCloudApiUpdateGlobalSettingsRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateGlobalSettingsExecute(r)
}

/*
UpdateGlobalSettings Method for UpdateGlobalSettings

Update ip in resource pool

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationMultiCloudApiUpdateGlobalSettingsRequest
*/
func (a *ConfigurationMultiCloudApiService) UpdateGlobalSettings(ctx context.Context) ConfigurationMultiCloudApiUpdateGlobalSettingsRequest {
	return ConfigurationMultiCloudApiUpdateGlobalSettingsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ConfigurationMultiCloudApiService) UpdateGlobalSettingsExecute(r ConfigurationMultiCloudApiUpdateGlobalSettingsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.UpdateGlobalSettings")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/settings/global"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiUpdateIcgwRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	edgeGatewayName string
	requestBody *map[string]GetO365PreferredPathFromVAnalyticsRequestValue
}

func (r ConfigurationMultiCloudApiUpdateIcgwRequest) RequestBody(requestBody map[string]GetO365PreferredPathFromVAnalyticsRequestValue) ConfigurationMultiCloudApiUpdateIcgwRequest {
	r.requestBody = &requestBody
	return r
}

func (r ConfigurationMultiCloudApiUpdateIcgwRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.UpdateIcgwExecute(r)
}

/*
UpdateIcgw Method for UpdateIcgw

Update Interconnect Gateway

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param edgeGatewayName Edge gateway name
 @return ConfigurationMultiCloudApiUpdateIcgwRequest
*/
func (a *ConfigurationMultiCloudApiService) UpdateIcgw(ctx context.Context, edgeGatewayName string) ConfigurationMultiCloudApiUpdateIcgwRequest {
	return ConfigurationMultiCloudApiUpdateIcgwRequest{
		ApiService: a,
		ctx: ctx,
		edgeGatewayName: edgeGatewayName,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) UpdateIcgwExecute(r ConfigurationMultiCloudApiUpdateIcgwRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.UpdateIcgw")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/gateway/edge/{edgeGatewayName}"
	localVarPath = strings.Replace(localVarPath, "{"+"edgeGatewayName"+"}", url.PathEscape(parameterToString(r.edgeGatewayName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiUpdateNvaSecurityRulesRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	cloudGatewayName string
	body *map[string]interface{}
}

// Update NVA security Rules
func (r ConfigurationMultiCloudApiUpdateNvaSecurityRulesRequest) Body(body map[string]interface{}) ConfigurationMultiCloudApiUpdateNvaSecurityRulesRequest {
	r.body = &body
	return r
}

func (r ConfigurationMultiCloudApiUpdateNvaSecurityRulesRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.UpdateNvaSecurityRulesExecute(r)
}

/*
UpdateNvaSecurityRules Method for UpdateNvaSecurityRules

Update NVA Security Rules

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cloudGatewayName Cloud gateway name
 @return ConfigurationMultiCloudApiUpdateNvaSecurityRulesRequest
*/
func (a *ConfigurationMultiCloudApiService) UpdateNvaSecurityRules(ctx context.Context, cloudGatewayName string) ConfigurationMultiCloudApiUpdateNvaSecurityRulesRequest {
	return ConfigurationMultiCloudApiUpdateNvaSecurityRulesRequest{
		ApiService: a,
		ctx: ctx,
		cloudGatewayName: cloudGatewayName,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) UpdateNvaSecurityRulesExecute(r ConfigurationMultiCloudApiUpdateNvaSecurityRulesRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.UpdateNvaSecurityRules")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/cloudgateway/nvaSecurityRules/{cloudGatewayName}"
	localVarPath = strings.Replace(localVarPath, "{"+"cloudGatewayName"+"}", url.PathEscape(parameterToString(r.cloudGatewayName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiValidateAccountAddRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	body *map[string]interface{}
}

// Multicloud account info
func (r ConfigurationMultiCloudApiValidateAccountAddRequest) Body(body map[string]interface{}) ConfigurationMultiCloudApiValidateAccountAddRequest {
	r.body = &body
	return r
}

func (r ConfigurationMultiCloudApiValidateAccountAddRequest) Execute() (*http.Response, error) {
	return r.ApiService.ValidateAccountAddExecute(r)
}

/*
ValidateAccountAdd Method for ValidateAccountAdd

Authenticate cloud account credentials

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationMultiCloudApiValidateAccountAddRequest
*/
func (a *ConfigurationMultiCloudApiService) ValidateAccountAdd(ctx context.Context) ConfigurationMultiCloudApiValidateAccountAddRequest {
	return ConfigurationMultiCloudApiValidateAccountAddRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ConfigurationMultiCloudApiService) ValidateAccountAddExecute(r ConfigurationMultiCloudApiValidateAccountAddRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.ValidateAccountAdd")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/accounts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiValidateAccountUpdateCredentialsRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	accountId string
	body *map[string]interface{}
}

// Multicloud account info
func (r ConfigurationMultiCloudApiValidateAccountUpdateCredentialsRequest) Body(body map[string]interface{}) ConfigurationMultiCloudApiValidateAccountUpdateCredentialsRequest {
	r.body = &body
	return r
}

func (r ConfigurationMultiCloudApiValidateAccountUpdateCredentialsRequest) Execute() (*http.Response, error) {
	return r.ApiService.ValidateAccountUpdateCredentialsExecute(r)
}

/*
ValidateAccountUpdateCredentials Method for ValidateAccountUpdateCredentials

Update multicloud account credential

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId Account Id
 @return ConfigurationMultiCloudApiValidateAccountUpdateCredentialsRequest
*/
func (a *ConfigurationMultiCloudApiService) ValidateAccountUpdateCredentials(ctx context.Context, accountId string) ConfigurationMultiCloudApiValidateAccountUpdateCredentialsRequest {
	return ConfigurationMultiCloudApiValidateAccountUpdateCredentialsRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
	}
}

// Execute executes the request
func (a *ConfigurationMultiCloudApiService) ValidateAccountUpdateCredentialsExecute(r ConfigurationMultiCloudApiValidateAccountUpdateCredentialsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.ValidateAccountUpdateCredentials")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/accounts/{accountId}/credentials"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterToString(r.accountId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiValidateEdgeAccountAddRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	body *map[string]interface{}
}

// Multicloud edge account info
func (r ConfigurationMultiCloudApiValidateEdgeAccountAddRequest) Body(body map[string]interface{}) ConfigurationMultiCloudApiValidateEdgeAccountAddRequest {
	r.body = &body
	return r
}

func (r ConfigurationMultiCloudApiValidateEdgeAccountAddRequest) Execute() (*http.Response, error) {
	return r.ApiService.ValidateEdgeAccountAddExecute(r)
}

/*
ValidateEdgeAccountAdd Method for ValidateEdgeAccountAdd

Authenticate edge account credentials

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationMultiCloudApiValidateEdgeAccountAddRequest
*/
func (a *ConfigurationMultiCloudApiService) ValidateEdgeAccountAdd(ctx context.Context) ConfigurationMultiCloudApiValidateEdgeAccountAddRequest {
	return ConfigurationMultiCloudApiValidateEdgeAccountAddRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ConfigurationMultiCloudApiService) ValidateEdgeAccountAddExecute(r ConfigurationMultiCloudApiValidateEdgeAccountAddRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.ValidateEdgeAccountAdd")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/accounts/edge"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ConfigurationMultiCloudApiValidateEdgeAccountUpdateCredentialsRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	accountId string
	body *map[string]interface{}
}

// Multicloud edge account info
func (r ConfigurationMultiCloudApiValidateEdgeAccountUpdateCredentialsRequest) Body(body map[string]interface{}) ConfigurationMultiCloudApiValidateEdgeAccountUpdateCredentialsRequest {
	r.body = &body
	return r
}

func (r ConfigurationMultiCloudApiValidateEdgeAccountUpdateCredentialsRequest) Execute() (*http.Response, error) {
	return r.ApiService.ValidateEdgeAccountUpdateCredentialsExecute(r)
}

/*
ValidateEdgeAccountUpdateCredentials Method for ValidateEdgeAccountUpdateCredentials

Update Multicloud edge account credential

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId Multicloud Edge Account Id
 @return ConfigurationMultiCloudApiValidateEdgeAccountUpdateCredentialsRequest
*/
func (a *ConfigurationMultiCloudApiService) ValidateEdgeAccountUpdateCredentials(ctx context.Context, accountId string) ConfigurationMultiCloudApiValidateEdgeAccountUpdateCredentialsRequest {
	return ConfigurationMultiCloudApiValidateEdgeAccountUpdateCredentialsRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
	}
}

// Execute executes the request
func (a *ConfigurationMultiCloudApiService) ValidateEdgeAccountUpdateCredentialsExecute(r ConfigurationMultiCloudApiValidateEdgeAccountUpdateCredentialsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.ValidateEdgeAccountUpdateCredentials")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/accounts/edge/{accountId}/credentials"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterToString(r.accountId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
