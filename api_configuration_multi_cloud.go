/*
Cisco SD-WAN vManage API

The vManage API exposes the functionality of operations maintaining devices and the overlay network

API version: 2.0.0
Contact: vmanage@cisco.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// ConfigurationMultiCloudApiService ConfigurationMultiCloudApi service
type ConfigurationMultiCloudApiService service

type ApiAddEdgeGlobalSettingsRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	body *map[string]interface{}
}

// Global setting
func (r ApiAddEdgeGlobalSettingsRequest) Body(body map[string]interface{}) ApiAddEdgeGlobalSettingsRequest {
	r.body = &body
	return r
}

func (r ApiAddEdgeGlobalSettingsRequest) Execute() (*http.Response, error) {
	return r.ApiService.AddEdgeGlobalSettingsExecute(r)
}

/*
AddEdgeGlobalSettings Method for AddEdgeGlobalSettings

Add global settings for Edge provider

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAddEdgeGlobalSettingsRequest
*/
func (a *ConfigurationMultiCloudApiService) AddEdgeGlobalSettings(ctx context.Context) ApiAddEdgeGlobalSettingsRequest {
	return ApiAddEdgeGlobalSettingsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ConfigurationMultiCloudApiService) AddEdgeGlobalSettingsExecute(r ApiAddEdgeGlobalSettingsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.AddEdgeGlobalSettings")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/settings/edge/global"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAddGlobalSettingsRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	body *map[string]interface{}
}

// Global setting
func (r ApiAddGlobalSettingsRequest) Body(body map[string]interface{}) ApiAddGlobalSettingsRequest {
	r.body = &body
	return r
}

func (r ApiAddGlobalSettingsRequest) Execute() (*http.Response, error) {
	return r.ApiService.AddGlobalSettingsExecute(r)
}

/*
AddGlobalSettings Method for AddGlobalSettings

Acquire ip from resource pool

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAddGlobalSettingsRequest
*/
func (a *ConfigurationMultiCloudApiService) AddGlobalSettings(ctx context.Context) ApiAddGlobalSettingsRequest {
	return ApiAddGlobalSettingsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ConfigurationMultiCloudApiService) AddGlobalSettingsExecute(r ApiAddGlobalSettingsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.AddGlobalSettings")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/settings/global"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAttachSitesRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	cloudGatewayName string
	body *map[string]interface{}
}

// Site information
func (r ApiAttachSitesRequest) Body(body map[string]interface{}) ApiAttachSitesRequest {
	r.body = &body
	return r
}

func (r ApiAttachSitesRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.AttachSitesExecute(r)
}

/*
AttachSites Method for AttachSites

Attach sites to cloud gateway

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cloudGatewayName Cloud gateway name
 @return ApiAttachSitesRequest
*/
func (a *ConfigurationMultiCloudApiService) AttachSites(ctx context.Context, cloudGatewayName string) ApiAttachSitesRequest {
	return ApiAttachSitesRequest{
		ApiService: a,
		ctx: ctx,
		cloudGatewayName: cloudGatewayName,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) AttachSitesExecute(r ApiAttachSitesRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.AttachSites")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/cloudgateway/{cloudGatewayName}/site"
	localVarPath = strings.Replace(localVarPath, "{"+"cloudGatewayName"+"}", url.PathEscape(parameterToString(r.cloudGatewayName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAuditRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	body *map[string]interface{}
}

// Audit
func (r ApiAuditRequest) Body(body map[string]interface{}) ApiAuditRequest {
	r.body = &body
	return r
}

func (r ApiAuditRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.AuditExecute(r)
}

/*
Audit Method for Audit

Call an audit

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAuditRequest
*/
func (a *ConfigurationMultiCloudApiService) Audit(ctx context.Context) ApiAuditRequest {
	return ApiAuditRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) AuditExecute(r ApiAuditRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.Audit")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/audit"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAuditDryRunRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	cloudType *string
	cloudRegion *string
}

// Cloud type
func (r ApiAuditDryRunRequest) CloudType(cloudType string) ApiAuditDryRunRequest {
	r.cloudType = &cloudType
	return r
}

// Region
func (r ApiAuditDryRunRequest) CloudRegion(cloudRegion string) ApiAuditDryRunRequest {
	r.cloudRegion = &cloudRegion
	return r
}

func (r ApiAuditDryRunRequest) Execute() (*http.Response, error) {
	return r.ApiService.AuditDryRunExecute(r)
}

/*
AuditDryRun Method for AuditDryRun

Call an audit with dry run

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAuditDryRunRequest
*/
func (a *ConfigurationMultiCloudApiService) AuditDryRun(ctx context.Context) ApiAuditDryRunRequest {
	return ApiAuditDryRunRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ConfigurationMultiCloudApiService) AuditDryRunExecute(r ApiAuditDryRunRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.AuditDryRun")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/audit"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.cloudType != nil {
		localVarQueryParams.Add("cloudType", parameterToString(*r.cloudType, ""))
	}
	if r.cloudRegion != nil {
		localVarQueryParams.Add("cloudRegion", parameterToString(*r.cloudRegion, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCleanUpAllConnectivityGatewaysInLocalDBRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	deletionType *string
}

// Deletion Type
func (r ApiCleanUpAllConnectivityGatewaysInLocalDBRequest) DeletionType(deletionType string) ApiCleanUpAllConnectivityGatewaysInLocalDBRequest {
	r.deletionType = &deletionType
	return r
}

func (r ApiCleanUpAllConnectivityGatewaysInLocalDBRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.CleanUpAllConnectivityGatewaysInLocalDBExecute(r)
}

/*
CleanUpAllConnectivityGatewaysInLocalDB Method for CleanUpAllConnectivityGatewaysInLocalDB

Delete all Connectivity Gateways in local DB

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCleanUpAllConnectivityGatewaysInLocalDBRequest
*/
func (a *ConfigurationMultiCloudApiService) CleanUpAllConnectivityGatewaysInLocalDB(ctx context.Context) ApiCleanUpAllConnectivityGatewaysInLocalDBRequest {
	return ApiCleanUpAllConnectivityGatewaysInLocalDBRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) CleanUpAllConnectivityGatewaysInLocalDBExecute(r ApiCleanUpAllConnectivityGatewaysInLocalDBRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.CleanUpAllConnectivityGatewaysInLocalDB")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/connectivitygateway"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.deletionType != nil {
		localVarQueryParams.Add("deletionType", parameterToString(*r.deletionType, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateCgwRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	body *map[string]interface{}
}

// Cloud gateway
func (r ApiCreateCgwRequest) Body(body map[string]interface{}) ApiCreateCgwRequest {
	r.body = &body
	return r
}

func (r ApiCreateCgwRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.CreateCgwExecute(r)
}

/*
CreateCgw Method for CreateCgw

Create cloud gateway

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateCgwRequest
*/
func (a *ConfigurationMultiCloudApiService) CreateCgw(ctx context.Context) ApiCreateCgwRequest {
	return ApiCreateCgwRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) CreateCgwExecute(r ApiCreateCgwRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.CreateCgw")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/cloudgateway"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateConnectivityGatewayRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	body *map[string]interface{}
}

// Connectivity gateway
func (r ApiCreateConnectivityGatewayRequest) Body(body map[string]interface{}) ApiCreateConnectivityGatewayRequest {
	r.body = &body
	return r
}

func (r ApiCreateConnectivityGatewayRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.CreateConnectivityGatewayExecute(r)
}

/*
CreateConnectivityGateway Method for CreateConnectivityGateway

Create Connectivity gateway

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateConnectivityGatewayRequest
*/
func (a *ConfigurationMultiCloudApiService) CreateConnectivityGateway(ctx context.Context) ApiCreateConnectivityGatewayRequest {
	return ApiCreateConnectivityGatewayRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) CreateConnectivityGatewayExecute(r ApiCreateConnectivityGatewayRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.CreateConnectivityGateway")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/connectivitygateway"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateDeviceLinkRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	body *map[string]interface{}
}

// Device Link
func (r ApiCreateDeviceLinkRequest) Body(body map[string]interface{}) ApiCreateDeviceLinkRequest {
	r.body = &body
	return r
}

func (r ApiCreateDeviceLinkRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.CreateDeviceLinkExecute(r)
}

/*
CreateDeviceLink Method for CreateDeviceLink

Create Device Link

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateDeviceLinkRequest
*/
func (a *ConfigurationMultiCloudApiService) CreateDeviceLink(ctx context.Context) ApiCreateDeviceLinkRequest {
	return ApiCreateDeviceLinkRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) CreateDeviceLinkExecute(r ApiCreateDeviceLinkRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.CreateDeviceLink")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/devicelink/edge"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateEdgeConnectivityRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	body *map[string]interface{}
}

// Edge connectivity
func (r ApiCreateEdgeConnectivityRequest) Body(body map[string]interface{}) ApiCreateEdgeConnectivityRequest {
	r.body = &body
	return r
}

func (r ApiCreateEdgeConnectivityRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.CreateEdgeConnectivityExecute(r)
}

/*
CreateEdgeConnectivity Method for CreateEdgeConnectivity

Create Interconnect connectivity

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateEdgeConnectivityRequest
*/
func (a *ConfigurationMultiCloudApiService) CreateEdgeConnectivity(ctx context.Context) ApiCreateEdgeConnectivityRequest {
	return ApiCreateEdgeConnectivityRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) CreateEdgeConnectivityExecute(r ApiCreateEdgeConnectivityRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.CreateEdgeConnectivity")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/connectivity/edge"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateIcgwRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	body *map[string]interface{}
}

// Interconnect Gateway
func (r ApiCreateIcgwRequest) Body(body map[string]interface{}) ApiCreateIcgwRequest {
	r.body = &body
	return r
}

func (r ApiCreateIcgwRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.CreateIcgwExecute(r)
}

/*
CreateIcgw Method for CreateIcgw

Create Interconnect Gateway

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateIcgwRequest
*/
func (a *ConfigurationMultiCloudApiService) CreateIcgw(ctx context.Context) ApiCreateIcgwRequest {
	return ApiCreateIcgwRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) CreateIcgwExecute(r ApiCreateIcgwRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.CreateIcgw")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/gateway/edge"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateVirtualWanRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	body *map[string]interface{}
}

// Virtual WAN
func (r ApiCreateVirtualWanRequest) Body(body map[string]interface{}) ApiCreateVirtualWanRequest {
	r.body = &body
	return r
}

func (r ApiCreateVirtualWanRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.CreateVirtualWanExecute(r)
}

/*
CreateVirtualWan Method for CreateVirtualWan

Create Virtual WAN

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateVirtualWanRequest
*/
func (a *ConfigurationMultiCloudApiService) CreateVirtualWan(ctx context.Context) ApiCreateVirtualWanRequest {
	return ApiCreateVirtualWanRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) CreateVirtualWanExecute(r ApiCreateVirtualWanRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.CreateVirtualWan")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/vwan"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteAccountRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	accountId string
}

func (r ApiDeleteAccountRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteAccountExecute(r)
}

/*
DeleteAccount Method for DeleteAccount

Delete cloud account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId Account Id
 @return ApiDeleteAccountRequest
*/
func (a *ConfigurationMultiCloudApiService) DeleteAccount(ctx context.Context, accountId string) ApiDeleteAccountRequest {
	return ApiDeleteAccountRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
	}
}

// Execute executes the request
func (a *ConfigurationMultiCloudApiService) DeleteAccountExecute(r ApiDeleteAccountRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.DeleteAccount")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/accounts/{accountId}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterToString(r.accountId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteCgwRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	cloudGatewayName string
	deleteAllResources *bool
}

// Optional Flag for deletion of Azure Resource Group, Default: True
func (r ApiDeleteCgwRequest) DeleteAllResources(deleteAllResources bool) ApiDeleteCgwRequest {
	r.deleteAllResources = &deleteAllResources
	return r
}

func (r ApiDeleteCgwRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.DeleteCgwExecute(r)
}

/*
DeleteCgw Method for DeleteCgw

Delete cloud gateway

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cloudGatewayName Cloud gateway name
 @return ApiDeleteCgwRequest
*/
func (a *ConfigurationMultiCloudApiService) DeleteCgw(ctx context.Context, cloudGatewayName string) ApiDeleteCgwRequest {
	return ApiDeleteCgwRequest{
		ApiService: a,
		ctx: ctx,
		cloudGatewayName: cloudGatewayName,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) DeleteCgwExecute(r ApiDeleteCgwRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.DeleteCgw")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/cloudgateway/{cloudGatewayName}"
	localVarPath = strings.Replace(localVarPath, "{"+"cloudGatewayName"+"}", url.PathEscape(parameterToString(r.cloudGatewayName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.deleteAllResources != nil {
		localVarQueryParams.Add("deleteAllResources", parameterToString(*r.deleteAllResources, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteConnectivityGatewayRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	cloudProvider string
	connectivityGatewayName string
	connectivityType *string
}

// Cloud Connectivity Type
func (r ApiDeleteConnectivityGatewayRequest) ConnectivityType(connectivityType string) ApiDeleteConnectivityGatewayRequest {
	r.connectivityType = &connectivityType
	return r
}

func (r ApiDeleteConnectivityGatewayRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.DeleteConnectivityGatewayExecute(r)
}

/*
DeleteConnectivityGateway Method for DeleteConnectivityGateway

Delete Connectivity Gateway

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cloudProvider Cloud Provider
 @param connectivityGatewayName Connectivity gateway name
 @return ApiDeleteConnectivityGatewayRequest
*/
func (a *ConfigurationMultiCloudApiService) DeleteConnectivityGateway(ctx context.Context, cloudProvider string, connectivityGatewayName string) ApiDeleteConnectivityGatewayRequest {
	return ApiDeleteConnectivityGatewayRequest{
		ApiService: a,
		ctx: ctx,
		cloudProvider: cloudProvider,
		connectivityGatewayName: connectivityGatewayName,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) DeleteConnectivityGatewayExecute(r ApiDeleteConnectivityGatewayRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.DeleteConnectivityGateway")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/connectivitygateway/{cloudProvider}/{connectivityGatewayName}"
	localVarPath = strings.Replace(localVarPath, "{"+"cloudProvider"+"}", url.PathEscape(parameterToString(r.cloudProvider, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"connectivityGatewayName"+"}", url.PathEscape(parameterToString(r.connectivityGatewayName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.connectivityType != nil {
		localVarQueryParams.Add("connectivityType", parameterToString(*r.connectivityType, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteDeviceLinkRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	deviceLinkName string
}

func (r ApiDeleteDeviceLinkRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.DeleteDeviceLinkExecute(r)
}

/*
DeleteDeviceLink Method for DeleteDeviceLink

Delete Device Link

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceLinkName Device Link Name
 @return ApiDeleteDeviceLinkRequest
*/
func (a *ConfigurationMultiCloudApiService) DeleteDeviceLink(ctx context.Context, deviceLinkName string) ApiDeleteDeviceLinkRequest {
	return ApiDeleteDeviceLinkRequest{
		ApiService: a,
		ctx: ctx,
		deviceLinkName: deviceLinkName,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) DeleteDeviceLinkExecute(r ApiDeleteDeviceLinkRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.DeleteDeviceLink")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/devicelink/edge/{deviceLinkName}"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceLinkName"+"}", url.PathEscape(parameterToString(r.deviceLinkName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteEdgeAccountRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	accountId string
}

func (r ApiDeleteEdgeAccountRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteEdgeAccountExecute(r)
}

/*
DeleteEdgeAccount Method for DeleteEdgeAccount

Delete edge account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId Edge Account Id
 @return ApiDeleteEdgeAccountRequest
*/
func (a *ConfigurationMultiCloudApiService) DeleteEdgeAccount(ctx context.Context, accountId string) ApiDeleteEdgeAccountRequest {
	return ApiDeleteEdgeAccountRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
	}
}

// Execute executes the request
func (a *ConfigurationMultiCloudApiService) DeleteEdgeAccountExecute(r ApiDeleteEdgeAccountRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.DeleteEdgeAccount")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/accounts/edge/{accountId}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterToString(r.accountId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteEdgeAccount1Request struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	edgeType string
}

func (r ApiDeleteEdgeAccount1Request) Execute() (*http.Response, error) {
	return r.ApiService.DeleteEdgeAccount1Execute(r)
}

/*
DeleteEdgeAccount1 Method for DeleteEdgeAccount1

Delete edge account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param edgeType Edge Type
 @return ApiDeleteEdgeAccount1Request
*/
func (a *ConfigurationMultiCloudApiService) DeleteEdgeAccount1(ctx context.Context, edgeType string) ApiDeleteEdgeAccount1Request {
	return ApiDeleteEdgeAccount1Request{
		ApiService: a,
		ctx: ctx,
		edgeType: edgeType,
	}
}

// Execute executes the request
func (a *ConfigurationMultiCloudApiService) DeleteEdgeAccount1Execute(r ApiDeleteEdgeAccount1Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.DeleteEdgeAccount1")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/locations/edge/{edgeType}"
	localVarPath = strings.Replace(localVarPath, "{"+"edgeType"+"}", url.PathEscape(parameterToString(r.edgeType, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteEdgeConnectivityRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	connectionName string
}

func (r ApiDeleteEdgeConnectivityRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.DeleteEdgeConnectivityExecute(r)
}

/*
DeleteEdgeConnectivity Method for DeleteEdgeConnectivity

Delete Interconnect connectivity

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param connectionName Edge connectivity name
 @return ApiDeleteEdgeConnectivityRequest
*/
func (a *ConfigurationMultiCloudApiService) DeleteEdgeConnectivity(ctx context.Context, connectionName string) ApiDeleteEdgeConnectivityRequest {
	return ApiDeleteEdgeConnectivityRequest{
		ApiService: a,
		ctx: ctx,
		connectionName: connectionName,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) DeleteEdgeConnectivityExecute(r ApiDeleteEdgeConnectivityRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.DeleteEdgeConnectivity")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/connectivity/edge/{connectionName}"
	localVarPath = strings.Replace(localVarPath, "{"+"connectionName"+"}", url.PathEscape(parameterToString(r.connectionName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteIcgwRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	edgeGatewayName string
}

func (r ApiDeleteIcgwRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.DeleteIcgwExecute(r)
}

/*
DeleteIcgw Method for DeleteIcgw

Delete Interconnect Gateway

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param edgeGatewayName Edge gateway name
 @return ApiDeleteIcgwRequest
*/
func (a *ConfigurationMultiCloudApiService) DeleteIcgw(ctx context.Context, edgeGatewayName string) ApiDeleteIcgwRequest {
	return ApiDeleteIcgwRequest{
		ApiService: a,
		ctx: ctx,
		edgeGatewayName: edgeGatewayName,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) DeleteIcgwExecute(r ApiDeleteIcgwRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.DeleteIcgw")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/gateway/edge/{edgeGatewayName}"
	localVarPath = strings.Replace(localVarPath, "{"+"edgeGatewayName"+"}", url.PathEscape(parameterToString(r.edgeGatewayName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteVirtualWanRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	cloudProvider string
	vWanName string
	accountId *string
	resourceGroup *string
}

// Account Id
func (r ApiDeleteVirtualWanRequest) AccountId(accountId string) ApiDeleteVirtualWanRequest {
	r.accountId = &accountId
	return r
}

// Resource Group
func (r ApiDeleteVirtualWanRequest) ResourceGroup(resourceGroup string) ApiDeleteVirtualWanRequest {
	r.resourceGroup = &resourceGroup
	return r
}

func (r ApiDeleteVirtualWanRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.DeleteVirtualWanExecute(r)
}

/*
DeleteVirtualWan Method for DeleteVirtualWan

Delete Virtual Wan

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cloudProvider Cloud Provider
 @param vWanName Virtual Wan name
 @return ApiDeleteVirtualWanRequest
*/
func (a *ConfigurationMultiCloudApiService) DeleteVirtualWan(ctx context.Context, cloudProvider string, vWanName string) ApiDeleteVirtualWanRequest {
	return ApiDeleteVirtualWanRequest{
		ApiService: a,
		ctx: ctx,
		cloudProvider: cloudProvider,
		vWanName: vWanName,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) DeleteVirtualWanExecute(r ApiDeleteVirtualWanRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.DeleteVirtualWan")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/vwan/{cloudProvider}/{vWanName}"
	localVarPath = strings.Replace(localVarPath, "{"+"cloudProvider"+"}", url.PathEscape(parameterToString(r.cloudProvider, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vWanName"+"}", url.PathEscape(parameterToString(r.vWanName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.accountId != nil {
		localVarQueryParams.Add("accountId", parameterToString(*r.accountId, ""))
	}
	if r.resourceGroup != nil {
		localVarQueryParams.Add("resourceGroup", parameterToString(*r.resourceGroup, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDetachSites1Request struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	cloudGatewayName string
	body *map[string]interface{}
}

// Site information
func (r ApiDetachSites1Request) Body(body map[string]interface{}) ApiDetachSites1Request {
	r.body = &body
	return r
}

func (r ApiDetachSites1Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.DetachSites1Execute(r)
}

/*
DetachSites1 Method for DetachSites1

Detach sites from cloud gateway

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cloudGatewayName Cloud gateway name
 @return ApiDetachSites1Request
*/
func (a *ConfigurationMultiCloudApiService) DetachSites1(ctx context.Context, cloudGatewayName string) ApiDetachSites1Request {
	return ApiDetachSites1Request{
		ApiService: a,
		ctx: ctx,
		cloudGatewayName: cloudGatewayName,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) DetachSites1Execute(r ApiDetachSites1Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.DetachSites1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/cloudgateway/{cloudGatewayName}/site"
	localVarPath = strings.Replace(localVarPath, "{"+"cloudGatewayName"+"}", url.PathEscape(parameterToString(r.cloudGatewayName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEdgeAuditRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	edgeType *string
	cloudType *string
}

// Edge type
func (r ApiEdgeAuditRequest) EdgeType(edgeType string) ApiEdgeAuditRequest {
	r.edgeType = &edgeType
	return r
}

// Cloud type
func (r ApiEdgeAuditRequest) CloudType(cloudType string) ApiEdgeAuditRequest {
	r.cloudType = &cloudType
	return r
}

func (r ApiEdgeAuditRequest) Execute() (*http.Response, error) {
	return r.ApiService.EdgeAuditExecute(r)
}

/*
EdgeAudit Method for EdgeAudit

Call an edge audit

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEdgeAuditRequest
*/
func (a *ConfigurationMultiCloudApiService) EdgeAudit(ctx context.Context) ApiEdgeAuditRequest {
	return ApiEdgeAuditRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ConfigurationMultiCloudApiService) EdgeAuditExecute(r ApiEdgeAuditRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.EdgeAudit")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/audit/edge"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.edgeType != nil {
		localVarQueryParams.Add("edgeType", parameterToString(*r.edgeType, ""))
	}
	if r.cloudType != nil {
		localVarQueryParams.Add("cloudType", parameterToString(*r.cloudType, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEdgeAuditDryRunRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	edgeType *string
	cloudType *string
}

// Edge type
func (r ApiEdgeAuditDryRunRequest) EdgeType(edgeType string) ApiEdgeAuditDryRunRequest {
	r.edgeType = &edgeType
	return r
}

// Cloud type
func (r ApiEdgeAuditDryRunRequest) CloudType(cloudType string) ApiEdgeAuditDryRunRequest {
	r.cloudType = &cloudType
	return r
}

func (r ApiEdgeAuditDryRunRequest) Execute() (*http.Response, error) {
	return r.ApiService.EdgeAuditDryRunExecute(r)
}

/*
EdgeAuditDryRun Method for EdgeAuditDryRun

Call an edge audit with dry run

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEdgeAuditDryRunRequest
*/
func (a *ConfigurationMultiCloudApiService) EdgeAuditDryRun(ctx context.Context) ApiEdgeAuditDryRunRequest {
	return ApiEdgeAuditDryRunRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ConfigurationMultiCloudApiService) EdgeAuditDryRunExecute(r ApiEdgeAuditDryRunRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.EdgeAuditDryRun")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/audit/edge"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.edgeType != nil {
		localVarQueryParams.Add("edgeType", parameterToString(*r.edgeType, ""))
	}
	if r.cloudType != nil {
		localVarQueryParams.Add("cloudType", parameterToString(*r.cloudType, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEditTagRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	body *map[string]interface{}
}

// VPC tag
func (r ApiEditTagRequest) Body(body map[string]interface{}) ApiEditTagRequest {
	r.body = &body
	return r
}

func (r ApiEditTagRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.EditTagExecute(r)
}

/*
EditTag Method for EditTag

Edit VPCs for a tag

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEditTagRequest
*/
func (a *ConfigurationMultiCloudApiService) EditTag(ctx context.Context) ApiEditTagRequest {
	return ApiEditTagRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) EditTagExecute(r ApiEditTagRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.EditTag")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/hostvpc/tags"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAllCloudAccountsRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	cloudType *string
	cloudGatewayEnabled *bool
}

// Cloud type
func (r ApiGetAllCloudAccountsRequest) CloudType(cloudType string) ApiGetAllCloudAccountsRequest {
	r.cloudType = &cloudType
	return r
}

// Cloud gateway enabled flag
func (r ApiGetAllCloudAccountsRequest) CloudGatewayEnabled(cloudGatewayEnabled bool) ApiGetAllCloudAccountsRequest {
	r.cloudGatewayEnabled = &cloudGatewayEnabled
	return r
}

func (r ApiGetAllCloudAccountsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetAllCloudAccountsExecute(r)
}

/*
GetAllCloudAccounts Method for GetAllCloudAccounts

Get All cloud accounts

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAllCloudAccountsRequest
*/
func (a *ConfigurationMultiCloudApiService) GetAllCloudAccounts(ctx context.Context) ApiGetAllCloudAccountsRequest {
	return ApiGetAllCloudAccountsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetAllCloudAccountsExecute(r ApiGetAllCloudAccountsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetAllCloudAccounts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/accounts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.cloudType != nil {
		localVarQueryParams.Add("cloudType", parameterToString(*r.cloudType, ""))
	}
	if r.cloudGatewayEnabled != nil {
		localVarQueryParams.Add("cloudGatewayEnabled", parameterToString(*r.cloudGatewayEnabled, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAzureNetworkVirtualAppliancesRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	cloudType *string
	accoundId *string
	region *string
	resourceGroupName *string
	resourceGroupSource *string
	vhubName *string
	vhubSource *string
}

// Cloud type
func (r ApiGetAzureNetworkVirtualAppliancesRequest) CloudType(cloudType string) ApiGetAzureNetworkVirtualAppliancesRequest {
	r.cloudType = &cloudType
	return r
}

// Account ID
func (r ApiGetAzureNetworkVirtualAppliancesRequest) AccoundId(accoundId string) ApiGetAzureNetworkVirtualAppliancesRequest {
	r.accoundId = &accoundId
	return r
}

// Region
func (r ApiGetAzureNetworkVirtualAppliancesRequest) Region(region string) ApiGetAzureNetworkVirtualAppliancesRequest {
	r.region = &region
	return r
}

// Resource Group Name
func (r ApiGetAzureNetworkVirtualAppliancesRequest) ResourceGroupName(resourceGroupName string) ApiGetAzureNetworkVirtualAppliancesRequest {
	r.resourceGroupName = &resourceGroupName
	return r
}

// Resource Group Source
func (r ApiGetAzureNetworkVirtualAppliancesRequest) ResourceGroupSource(resourceGroupSource string) ApiGetAzureNetworkVirtualAppliancesRequest {
	r.resourceGroupSource = &resourceGroupSource
	return r
}

// VHUB name
func (r ApiGetAzureNetworkVirtualAppliancesRequest) VhubName(vhubName string) ApiGetAzureNetworkVirtualAppliancesRequest {
	r.vhubName = &vhubName
	return r
}

// VHUB source
func (r ApiGetAzureNetworkVirtualAppliancesRequest) VhubSource(vhubSource string) ApiGetAzureNetworkVirtualAppliancesRequest {
	r.vhubSource = &vhubSource
	return r
}

func (r ApiGetAzureNetworkVirtualAppliancesRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetAzureNetworkVirtualAppliancesExecute(r)
}

/*
GetAzureNetworkVirtualAppliances Method for GetAzureNetworkVirtualAppliances

Discover Azure Virtual NVAs

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAzureNetworkVirtualAppliancesRequest
*/
func (a *ConfigurationMultiCloudApiService) GetAzureNetworkVirtualAppliances(ctx context.Context) ApiGetAzureNetworkVirtualAppliancesRequest {
	return ApiGetAzureNetworkVirtualAppliancesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetAzureNetworkVirtualAppliancesExecute(r ApiGetAzureNetworkVirtualAppliancesRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetAzureNetworkVirtualAppliances")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/cloudgateway/nvas"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.cloudType == nil {
		return localVarReturnValue, nil, reportError("cloudType is required and must be specified")
	}
	if r.accoundId == nil {
		return localVarReturnValue, nil, reportError("accoundId is required and must be specified")
	}
	if r.region == nil {
		return localVarReturnValue, nil, reportError("region is required and must be specified")
	}
	if r.resourceGroupName == nil {
		return localVarReturnValue, nil, reportError("resourceGroupName is required and must be specified")
	}
	if r.resourceGroupSource == nil {
		return localVarReturnValue, nil, reportError("resourceGroupSource is required and must be specified")
	}
	if r.vhubName == nil {
		return localVarReturnValue, nil, reportError("vhubName is required and must be specified")
	}
	if r.vhubSource == nil {
		return localVarReturnValue, nil, reportError("vhubSource is required and must be specified")
	}

	localVarQueryParams.Add("cloudType", parameterToString(*r.cloudType, ""))
	localVarQueryParams.Add("accoundId", parameterToString(*r.accoundId, ""))
	localVarQueryParams.Add("region", parameterToString(*r.region, ""))
	localVarQueryParams.Add("resourceGroupName", parameterToString(*r.resourceGroupName, ""))
	localVarQueryParams.Add("resourceGroupSource", parameterToString(*r.resourceGroupSource, ""))
	localVarQueryParams.Add("vhubName", parameterToString(*r.vhubName, ""))
	localVarQueryParams.Add("vhubSource", parameterToString(*r.vhubSource, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAzureNvaSkuListRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
}

func (r ApiGetAzureNvaSkuListRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetAzureNvaSkuListExecute(r)
}

/*
GetAzureNvaSkuList Method for GetAzureNvaSkuList

Get Azure NVA SKUs

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAzureNvaSkuListRequest
*/
func (a *ConfigurationMultiCloudApiService) GetAzureNvaSkuList(ctx context.Context) ApiGetAzureNvaSkuListRequest {
	return ApiGetAzureNvaSkuListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetAzureNvaSkuListExecute(r ApiGetAzureNvaSkuListRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetAzureNvaSkuList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/cloudgateway/nvasku"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAzureResourceGroupsRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	cloudType *string
	accountId *string
}

// Cloud type
func (r ApiGetAzureResourceGroupsRequest) CloudType(cloudType string) ApiGetAzureResourceGroupsRequest {
	r.cloudType = &cloudType
	return r
}

// Account ID
func (r ApiGetAzureResourceGroupsRequest) AccountId(accountId string) ApiGetAzureResourceGroupsRequest {
	r.accountId = &accountId
	return r
}

func (r ApiGetAzureResourceGroupsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetAzureResourceGroupsExecute(r)
}

/*
GetAzureResourceGroups Method for GetAzureResourceGroups

Discover Azure Resource Groups

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAzureResourceGroupsRequest
*/
func (a *ConfigurationMultiCloudApiService) GetAzureResourceGroups(ctx context.Context) ApiGetAzureResourceGroupsRequest {
	return ApiGetAzureResourceGroupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetAzureResourceGroupsExecute(r ApiGetAzureResourceGroupsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetAzureResourceGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/cloudgateway/resourceGroups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.cloudType == nil {
		return localVarReturnValue, nil, reportError("cloudType is required and must be specified")
	}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}

	localVarQueryParams.Add("cloudType", parameterToString(*r.cloudType, ""))
	localVarQueryParams.Add("accountId", parameterToString(*r.accountId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAzureVirtualHubsRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	cloudType *string
	accoundId *string
	region *string
	resourceGroupName *string
	resourceGroupSource *string
	vwanName *string
	vwanSource *string
}

// Cloud type
func (r ApiGetAzureVirtualHubsRequest) CloudType(cloudType string) ApiGetAzureVirtualHubsRequest {
	r.cloudType = &cloudType
	return r
}

// Account ID
func (r ApiGetAzureVirtualHubsRequest) AccoundId(accoundId string) ApiGetAzureVirtualHubsRequest {
	r.accoundId = &accoundId
	return r
}

// Region
func (r ApiGetAzureVirtualHubsRequest) Region(region string) ApiGetAzureVirtualHubsRequest {
	r.region = &region
	return r
}

// Resource Group Name
func (r ApiGetAzureVirtualHubsRequest) ResourceGroupName(resourceGroupName string) ApiGetAzureVirtualHubsRequest {
	r.resourceGroupName = &resourceGroupName
	return r
}

// Resource Group Source
func (r ApiGetAzureVirtualHubsRequest) ResourceGroupSource(resourceGroupSource string) ApiGetAzureVirtualHubsRequest {
	r.resourceGroupSource = &resourceGroupSource
	return r
}

// VWAN name
func (r ApiGetAzureVirtualHubsRequest) VwanName(vwanName string) ApiGetAzureVirtualHubsRequest {
	r.vwanName = &vwanName
	return r
}

// VWAN source
func (r ApiGetAzureVirtualHubsRequest) VwanSource(vwanSource string) ApiGetAzureVirtualHubsRequest {
	r.vwanSource = &vwanSource
	return r
}

func (r ApiGetAzureVirtualHubsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetAzureVirtualHubsExecute(r)
}

/*
GetAzureVirtualHubs Method for GetAzureVirtualHubs

Discover Azure Virtual HUBs

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAzureVirtualHubsRequest
*/
func (a *ConfigurationMultiCloudApiService) GetAzureVirtualHubs(ctx context.Context) ApiGetAzureVirtualHubsRequest {
	return ApiGetAzureVirtualHubsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetAzureVirtualHubsExecute(r ApiGetAzureVirtualHubsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetAzureVirtualHubs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/cloudgateway/vhubs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.cloudType == nil {
		return localVarReturnValue, nil, reportError("cloudType is required and must be specified")
	}
	if r.accoundId == nil {
		return localVarReturnValue, nil, reportError("accoundId is required and must be specified")
	}
	if r.region == nil {
		return localVarReturnValue, nil, reportError("region is required and must be specified")
	}
	if r.resourceGroupName == nil {
		return localVarReturnValue, nil, reportError("resourceGroupName is required and must be specified")
	}
	if r.resourceGroupSource == nil {
		return localVarReturnValue, nil, reportError("resourceGroupSource is required and must be specified")
	}
	if r.vwanName == nil {
		return localVarReturnValue, nil, reportError("vwanName is required and must be specified")
	}
	if r.vwanSource == nil {
		return localVarReturnValue, nil, reportError("vwanSource is required and must be specified")
	}

	localVarQueryParams.Add("cloudType", parameterToString(*r.cloudType, ""))
	localVarQueryParams.Add("accoundId", parameterToString(*r.accoundId, ""))
	localVarQueryParams.Add("region", parameterToString(*r.region, ""))
	localVarQueryParams.Add("resourceGroupName", parameterToString(*r.resourceGroupName, ""))
	localVarQueryParams.Add("resourceGroupSource", parameterToString(*r.resourceGroupSource, ""))
	localVarQueryParams.Add("vwanName", parameterToString(*r.vwanName, ""))
	localVarQueryParams.Add("vwanSource", parameterToString(*r.vwanSource, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAzureVirtualWansRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	cloudType *string
	accoundId *string
	resourceGroupName *string
	resourceGroupSource *string
}

// Cloud type
func (r ApiGetAzureVirtualWansRequest) CloudType(cloudType string) ApiGetAzureVirtualWansRequest {
	r.cloudType = &cloudType
	return r
}

// Account ID
func (r ApiGetAzureVirtualWansRequest) AccoundId(accoundId string) ApiGetAzureVirtualWansRequest {
	r.accoundId = &accoundId
	return r
}

// Resource Group Name
func (r ApiGetAzureVirtualWansRequest) ResourceGroupName(resourceGroupName string) ApiGetAzureVirtualWansRequest {
	r.resourceGroupName = &resourceGroupName
	return r
}

// Resource Group Source
func (r ApiGetAzureVirtualWansRequest) ResourceGroupSource(resourceGroupSource string) ApiGetAzureVirtualWansRequest {
	r.resourceGroupSource = &resourceGroupSource
	return r
}

func (r ApiGetAzureVirtualWansRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetAzureVirtualWansExecute(r)
}

/*
GetAzureVirtualWans Method for GetAzureVirtualWans

Discover Azure Virtual WANs

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAzureVirtualWansRequest
*/
func (a *ConfigurationMultiCloudApiService) GetAzureVirtualWans(ctx context.Context) ApiGetAzureVirtualWansRequest {
	return ApiGetAzureVirtualWansRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetAzureVirtualWansExecute(r ApiGetAzureVirtualWansRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetAzureVirtualWans")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/cloudgateway/vwans"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.cloudType == nil {
		return localVarReturnValue, nil, reportError("cloudType is required and must be specified")
	}
	if r.accoundId == nil {
		return localVarReturnValue, nil, reportError("accoundId is required and must be specified")
	}
	if r.resourceGroupName == nil {
		return localVarReturnValue, nil, reportError("resourceGroupName is required and must be specified")
	}
	if r.resourceGroupSource == nil {
		return localVarReturnValue, nil, reportError("resourceGroupSource is required and must be specified")
	}

	localVarQueryParams.Add("cloudType", parameterToString(*r.cloudType, ""))
	localVarQueryParams.Add("accoundId", parameterToString(*r.accoundId, ""))
	localVarQueryParams.Add("resourceGroupName", parameterToString(*r.resourceGroupName, ""))
	localVarQueryParams.Add("resourceGroupSource", parameterToString(*r.resourceGroupSource, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCgwAssociatedMappingsRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	cloudType string
	cloudGatewayName *string
	siteUuid *string
}

// Cloud Gateway Name
func (r ApiGetCgwAssociatedMappingsRequest) CloudGatewayName(cloudGatewayName string) ApiGetCgwAssociatedMappingsRequest {
	r.cloudGatewayName = &cloudGatewayName
	return r
}

// Site Device UUID
func (r ApiGetCgwAssociatedMappingsRequest) SiteUuid(siteUuid string) ApiGetCgwAssociatedMappingsRequest {
	r.siteUuid = &siteUuid
	return r
}

func (r ApiGetCgwAssociatedMappingsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetCgwAssociatedMappingsExecute(r)
}

/*
GetCgwAssociatedMappings Method for GetCgwAssociatedMappings

Get associated mappings to the CGW

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cloudType Cloud type
 @return ApiGetCgwAssociatedMappingsRequest
*/
func (a *ConfigurationMultiCloudApiService) GetCgwAssociatedMappings(ctx context.Context, cloudType string) ApiGetCgwAssociatedMappingsRequest {
	return ApiGetCgwAssociatedMappingsRequest{
		ApiService: a,
		ctx: ctx,
		cloudType: cloudType,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetCgwAssociatedMappingsExecute(r ApiGetCgwAssociatedMappingsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetCgwAssociatedMappings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/mapping/{cloudType}"
	localVarPath = strings.Replace(localVarPath, "{"+"cloudType"+"}", url.PathEscape(parameterToString(r.cloudType, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.cloudGatewayName == nil {
		return localVarReturnValue, nil, reportError("cloudGatewayName is required and must be specified")
	}

	localVarQueryParams.Add("cloudGatewayName", parameterToString(*r.cloudGatewayName, ""))
	if r.siteUuid != nil {
		localVarQueryParams.Add("siteUuid", parameterToString(*r.siteUuid, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCgwCustomSettingDetailsRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	cloudGatewayName string
}

func (r ApiGetCgwCustomSettingDetailsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetCgwCustomSettingDetailsExecute(r)
}

/*
GetCgwCustomSettingDetails Method for GetCgwCustomSettingDetails

Get cloud gateway custom setting by cloud gateway name

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cloudGatewayName Cloud gateway name
 @return ApiGetCgwCustomSettingDetailsRequest
*/
func (a *ConfigurationMultiCloudApiService) GetCgwCustomSettingDetails(ctx context.Context, cloudGatewayName string) ApiGetCgwCustomSettingDetailsRequest {
	return ApiGetCgwCustomSettingDetailsRequest{
		ApiService: a,
		ctx: ctx,
		cloudGatewayName: cloudGatewayName,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetCgwCustomSettingDetailsExecute(r ApiGetCgwCustomSettingDetailsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetCgwCustomSettingDetails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/cloudgatewaysetting/{cloudGatewayName}"
	localVarPath = strings.Replace(localVarPath, "{"+"cloudGatewayName"+"}", url.PathEscape(parameterToString(r.cloudGatewayName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCgwDetailsRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	cloudGatewayName string
}

func (r ApiGetCgwDetailsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetCgwDetailsExecute(r)
}

/*
GetCgwDetails Method for GetCgwDetails

Get cloud gateway by name

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cloudGatewayName Cloud gateway name
 @return ApiGetCgwDetailsRequest
*/
func (a *ConfigurationMultiCloudApiService) GetCgwDetails(ctx context.Context, cloudGatewayName string) ApiGetCgwDetailsRequest {
	return ApiGetCgwDetailsRequest{
		ApiService: a,
		ctx: ctx,
		cloudGatewayName: cloudGatewayName,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetCgwDetailsExecute(r ApiGetCgwDetailsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetCgwDetails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/cloudgateway/{cloudGatewayName}"
	localVarPath = strings.Replace(localVarPath, "{"+"cloudGatewayName"+"}", url.PathEscape(parameterToString(r.cloudGatewayName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCgwOrgResourcesRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	cloudGatewayName *string
}

// Cloud gateway name
func (r ApiGetCgwOrgResourcesRequest) CloudGatewayName(cloudGatewayName string) ApiGetCgwOrgResourcesRequest {
	r.cloudGatewayName = &cloudGatewayName
	return r
}

func (r ApiGetCgwOrgResourcesRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetCgwOrgResourcesExecute(r)
}

/*
GetCgwOrgResources Method for GetCgwOrgResources

Get cloud gateways

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCgwOrgResourcesRequest
*/
func (a *ConfigurationMultiCloudApiService) GetCgwOrgResources(ctx context.Context) ApiGetCgwOrgResourcesRequest {
	return ApiGetCgwOrgResourcesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetCgwOrgResourcesExecute(r ApiGetCgwOrgResourcesRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetCgwOrgResources")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/cloudgateway/resource"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.cloudGatewayName == nil {
		return localVarReturnValue, nil, reportError("cloudGatewayName is required and must be specified")
	}

	localVarQueryParams.Add("cloudGatewayName", parameterToString(*r.cloudGatewayName, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCgwTypesRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	cloudType *string
}

// Cloud type
func (r ApiGetCgwTypesRequest) CloudType(cloudType string) ApiGetCgwTypesRequest {
	r.cloudType = &cloudType
	return r
}

func (r ApiGetCgwTypesRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetCgwTypesExecute(r)
}

/*
GetCgwTypes Method for GetCgwTypes

Get cloud gateway types for specified cloudType

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCgwTypesRequest
*/
func (a *ConfigurationMultiCloudApiService) GetCgwTypes(ctx context.Context) ApiGetCgwTypesRequest {
	return ApiGetCgwTypesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetCgwTypesExecute(r ApiGetCgwTypesRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetCgwTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/cloudgatewaytype"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.cloudType != nil {
		localVarQueryParams.Add("cloudType", parameterToString(*r.cloudType, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCgwsRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	cloudType *string
	accountId *string
	region *string
	cloudGatewayName *string
	connectivityState *string
}

// Cloud type
func (r ApiGetCgwsRequest) CloudType(cloudType string) ApiGetCgwsRequest {
	r.cloudType = &cloudType
	return r
}

// Account Id
func (r ApiGetCgwsRequest) AccountId(accountId string) ApiGetCgwsRequest {
	r.accountId = &accountId
	return r
}

// Region
func (r ApiGetCgwsRequest) Region(region string) ApiGetCgwsRequest {
	r.region = &region
	return r
}

// Cloud gateway name
func (r ApiGetCgwsRequest) CloudGatewayName(cloudGatewayName string) ApiGetCgwsRequest {
	r.cloudGatewayName = &cloudGatewayName
	return r
}

// Connectivity State
func (r ApiGetCgwsRequest) ConnectivityState(connectivityState string) ApiGetCgwsRequest {
	r.connectivityState = &connectivityState
	return r
}

func (r ApiGetCgwsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetCgwsExecute(r)
}

/*
GetCgws Method for GetCgws

Get cloud gateways

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCgwsRequest
*/
func (a *ConfigurationMultiCloudApiService) GetCgws(ctx context.Context) ApiGetCgwsRequest {
	return ApiGetCgwsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetCgwsExecute(r ApiGetCgwsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetCgws")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/cloudgateway"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.cloudType != nil {
		localVarQueryParams.Add("cloudType", parameterToString(*r.cloudType, ""))
	}
	if r.accountId != nil {
		localVarQueryParams.Add("accountId", parameterToString(*r.accountId, ""))
	}
	if r.region != nil {
		localVarQueryParams.Add("region", parameterToString(*r.region, ""))
	}
	if r.cloudGatewayName != nil {
		localVarQueryParams.Add("cloudGatewayName", parameterToString(*r.cloudGatewayName, ""))
	}
	if r.connectivityState != nil {
		localVarQueryParams.Add("connectivityState", parameterToString(*r.connectivityState, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCloudAccountDetailsRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	accountId string
}

func (r ApiGetCloudAccountDetailsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetCloudAccountDetailsExecute(r)
}

/*
GetCloudAccountDetails Method for GetCloudAccountDetails

Get cloud account by account Id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId Account Id
 @return ApiGetCloudAccountDetailsRequest
*/
func (a *ConfigurationMultiCloudApiService) GetCloudAccountDetails(ctx context.Context, accountId string) ApiGetCloudAccountDetailsRequest {
	return ApiGetCloudAccountDetailsRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetCloudAccountDetailsExecute(r ApiGetCloudAccountDetailsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetCloudAccountDetails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/accounts/{accountId}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterToString(r.accountId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCloudConnectedSitesRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	cloudType string
	cloudGatewayName *string
}

// Cloud Gateway Name
func (r ApiGetCloudConnectedSitesRequest) CloudGatewayName(cloudGatewayName string) ApiGetCloudConnectedSitesRequest {
	r.cloudGatewayName = &cloudGatewayName
	return r
}

func (r ApiGetCloudConnectedSitesRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetCloudConnectedSitesExecute(r)
}

/*
GetCloudConnectedSites Method for GetCloudConnectedSites

Get sites with connectivity to the cloud by cloud type

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cloudType Cloud type
 @return ApiGetCloudConnectedSitesRequest
*/
func (a *ConfigurationMultiCloudApiService) GetCloudConnectedSites(ctx context.Context, cloudType string) ApiGetCloudConnectedSitesRequest {
	return ApiGetCloudConnectedSitesRequest{
		ApiService: a,
		ctx: ctx,
		cloudType: cloudType,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetCloudConnectedSitesExecute(r ApiGetCloudConnectedSitesRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetCloudConnectedSites")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/connected-sites/{cloudType}"
	localVarPath = strings.Replace(localVarPath, "{"+"cloudType"+"}", url.PathEscape(parameterToString(r.cloudType, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.cloudGatewayName != nil {
		localVarQueryParams.Add("cloudGatewayName", parameterToString(*r.cloudGatewayName, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCloudConnectedSites1Request struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	edgeType string
	edgeGatewayName *string
}

// Interconnect Gateway Name
func (r ApiGetCloudConnectedSites1Request) EdgeGatewayName(edgeGatewayName string) ApiGetCloudConnectedSites1Request {
	r.edgeGatewayName = &edgeGatewayName
	return r
}

func (r ApiGetCloudConnectedSites1Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetCloudConnectedSites1Execute(r)
}

/*
GetCloudConnectedSites1 Method for GetCloudConnectedSites1

Get sites with connectivity to the interconnect gateways by edge type

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param edgeType Edge type
 @return ApiGetCloudConnectedSites1Request
*/
func (a *ConfigurationMultiCloudApiService) GetCloudConnectedSites1(ctx context.Context, edgeType string) ApiGetCloudConnectedSites1Request {
	return ApiGetCloudConnectedSites1Request{
		ApiService: a,
		ctx: ctx,
		edgeType: edgeType,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetCloudConnectedSites1Execute(r ApiGetCloudConnectedSites1Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetCloudConnectedSites1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/connected-sites/edge/{edgeType}"
	localVarPath = strings.Replace(localVarPath, "{"+"edgeType"+"}", url.PathEscape(parameterToString(r.edgeType, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.edgeGatewayName != nil {
		localVarQueryParams.Add("edgeGatewayName", parameterToString(*r.edgeGatewayName, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCloudDevicesRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	cloudType string
	cloudGatewayName *string
}

// Cloud Gateway Name
func (r ApiGetCloudDevicesRequest) CloudGatewayName(cloudGatewayName string) ApiGetCloudDevicesRequest {
	r.cloudGatewayName = &cloudGatewayName
	return r
}

func (r ApiGetCloudDevicesRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetCloudDevicesExecute(r)
}

/*
GetCloudDevices Method for GetCloudDevices

Get cloud devices by cloud type

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cloudType Cloud type
 @return ApiGetCloudDevicesRequest
*/
func (a *ConfigurationMultiCloudApiService) GetCloudDevices(ctx context.Context, cloudType string) ApiGetCloudDevicesRequest {
	return ApiGetCloudDevicesRequest{
		ApiService: a,
		ctx: ctx,
		cloudType: cloudType,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetCloudDevicesExecute(r ApiGetCloudDevicesRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetCloudDevices")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/devices/{cloudType}"
	localVarPath = strings.Replace(localVarPath, "{"+"cloudType"+"}", url.PathEscape(parameterToString(r.cloudType, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.cloudGatewayName != nil {
		localVarQueryParams.Add("cloudGatewayName", parameterToString(*r.cloudGatewayName, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCloudDevices1Request struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	edgeType string
	edgeGatewayName *string
}

// Edge Gateway Name
func (r ApiGetCloudDevices1Request) EdgeGatewayName(edgeGatewayName string) ApiGetCloudDevices1Request {
	r.edgeGatewayName = &edgeGatewayName
	return r
}

func (r ApiGetCloudDevices1Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetCloudDevices1Execute(r)
}

/*
GetCloudDevices1 Method for GetCloudDevices1

Get cloud devices by cloud type

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param edgeType Edge type
 @return ApiGetCloudDevices1Request
*/
func (a *ConfigurationMultiCloudApiService) GetCloudDevices1(ctx context.Context, edgeType string) ApiGetCloudDevices1Request {
	return ApiGetCloudDevices1Request{
		ApiService: a,
		ctx: ctx,
		edgeType: edgeType,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetCloudDevices1Execute(r ApiGetCloudDevices1Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetCloudDevices1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/devices/edge/{edgeType}"
	localVarPath = strings.Replace(localVarPath, "{"+"edgeType"+"}", url.PathEscape(parameterToString(r.edgeType, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.edgeGatewayName != nil {
		localVarQueryParams.Add("edgeGatewayName", parameterToString(*r.edgeGatewayName, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCloudGatewaysRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	cloudType string
}

func (r ApiGetCloudGatewaysRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetCloudGatewaysExecute(r)
}

/*
GetCloudGateways Method for GetCloudGateways

Get sites with connectivity to the cloud by cloud type

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cloudType Cloud type
 @return ApiGetCloudGatewaysRequest
*/
func (a *ConfigurationMultiCloudApiService) GetCloudGateways(ctx context.Context, cloudType string) ApiGetCloudGatewaysRequest {
	return ApiGetCloudGatewaysRequest{
		ApiService: a,
		ctx: ctx,
		cloudType: cloudType,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetCloudGatewaysExecute(r ApiGetCloudGatewaysRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetCloudGateways")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/cloudgateways/{cloudType}"
	localVarPath = strings.Replace(localVarPath, "{"+"cloudType"+"}", url.PathEscape(parameterToString(r.cloudType, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCloudRegionsRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	cloudType *string
}

// Cloud type
func (r ApiGetCloudRegionsRequest) CloudType(cloudType string) ApiGetCloudRegionsRequest {
	r.cloudType = &cloudType
	return r
}

func (r ApiGetCloudRegionsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetCloudRegionsExecute(r)
}

/*
GetCloudRegions Method for GetCloudRegions

Get cloud regions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCloudRegionsRequest
*/
func (a *ConfigurationMultiCloudApiService) GetCloudRegions(ctx context.Context) ApiGetCloudRegionsRequest {
	return ApiGetCloudRegionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetCloudRegionsExecute(r ApiGetCloudRegionsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetCloudRegions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/regions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.cloudType != nil {
		localVarQueryParams.Add("cloudType", parameterToString(*r.cloudType, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCloudTypesRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
}

func (r ApiGetCloudTypesRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetCloudTypesExecute(r)
}

/*
GetCloudTypes Method for GetCloudTypes

Get cloud types

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCloudTypesRequest
*/
func (a *ConfigurationMultiCloudApiService) GetCloudTypes(ctx context.Context) ApiGetCloudTypesRequest {
	return ApiGetCloudTypesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetCloudTypesExecute(r ApiGetCloudTypesRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetCloudTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/types"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCloudWidgetRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	cloudType string
}

func (r ApiGetCloudWidgetRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetCloudWidgetExecute(r)
}

/*
GetCloudWidget Method for GetCloudWidget

Get cloud widget by cloud type

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cloudType Cloud type
 @return ApiGetCloudWidgetRequest
*/
func (a *ConfigurationMultiCloudApiService) GetCloudWidget(ctx context.Context, cloudType string) ApiGetCloudWidgetRequest {
	return ApiGetCloudWidgetRequest{
		ApiService: a,
		ctx: ctx,
		cloudType: cloudType,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetCloudWidgetExecute(r ApiGetCloudWidgetRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetCloudWidget")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/widget/{cloudType}"
	localVarPath = strings.Replace(localVarPath, "{"+"cloudType"+"}", url.PathEscape(parameterToString(r.cloudType, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetConnectivityGatewayCreationOptionsRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	accountId *string
	cloudType *string
	connectivityType *string
	refresh *string
}

// Account Id
func (r ApiGetConnectivityGatewayCreationOptionsRequest) AccountId(accountId string) ApiGetConnectivityGatewayCreationOptionsRequest {
	r.accountId = &accountId
	return r
}

// Cloud Type
func (r ApiGetConnectivityGatewayCreationOptionsRequest) CloudType(cloudType string) ApiGetConnectivityGatewayCreationOptionsRequest {
	r.cloudType = &cloudType
	return r
}

// Cloud Connectivity Type
func (r ApiGetConnectivityGatewayCreationOptionsRequest) ConnectivityType(connectivityType string) ApiGetConnectivityGatewayCreationOptionsRequest {
	r.connectivityType = &connectivityType
	return r
}

// Refresh
func (r ApiGetConnectivityGatewayCreationOptionsRequest) Refresh(refresh string) ApiGetConnectivityGatewayCreationOptionsRequest {
	r.refresh = &refresh
	return r
}

func (r ApiGetConnectivityGatewayCreationOptionsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetConnectivityGatewayCreationOptionsExecute(r)
}

/*
GetConnectivityGatewayCreationOptions Method for GetConnectivityGatewayCreationOptions

Get connectivity gateway creation options

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetConnectivityGatewayCreationOptionsRequest
*/
func (a *ConfigurationMultiCloudApiService) GetConnectivityGatewayCreationOptions(ctx context.Context) ApiGetConnectivityGatewayCreationOptionsRequest {
	return ApiGetConnectivityGatewayCreationOptionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetConnectivityGatewayCreationOptionsExecute(r ApiGetConnectivityGatewayCreationOptionsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetConnectivityGatewayCreationOptions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/connectivitygatewaycreationoptions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.accountId != nil {
		localVarQueryParams.Add("accountId", parameterToString(*r.accountId, ""))
	}
	if r.cloudType != nil {
		localVarQueryParams.Add("cloudType", parameterToString(*r.cloudType, ""))
	}
	if r.connectivityType != nil {
		localVarQueryParams.Add("connectivityType", parameterToString(*r.connectivityType, ""))
	}
	if r.refresh != nil {
		localVarQueryParams.Add("refresh", parameterToString(*r.refresh, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetConnectivityGatewaysRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	accountId *string
	cloudType *string
	connectivityType *string
	connectivityGatewayName *string
	region *string
	network *string
	state *string
	refresh *string
	edgeType *string
}

// Account Id
func (r ApiGetConnectivityGatewaysRequest) AccountId(accountId string) ApiGetConnectivityGatewaysRequest {
	r.accountId = &accountId
	return r
}

// Cloud Type
func (r ApiGetConnectivityGatewaysRequest) CloudType(cloudType string) ApiGetConnectivityGatewaysRequest {
	r.cloudType = &cloudType
	return r
}

// Cloud Connectivity Type
func (r ApiGetConnectivityGatewaysRequest) ConnectivityType(connectivityType string) ApiGetConnectivityGatewaysRequest {
	r.connectivityType = &connectivityType
	return r
}

// Connectivity Gateway Name
func (r ApiGetConnectivityGatewaysRequest) ConnectivityGatewayName(connectivityGatewayName string) ApiGetConnectivityGatewaysRequest {
	r.connectivityGatewayName = &connectivityGatewayName
	return r
}

// Region
func (r ApiGetConnectivityGatewaysRequest) Region(region string) ApiGetConnectivityGatewaysRequest {
	r.region = &region
	return r
}

// Network
func (r ApiGetConnectivityGatewaysRequest) Network(network string) ApiGetConnectivityGatewaysRequest {
	r.network = &network
	return r
}

// State
func (r ApiGetConnectivityGatewaysRequest) State(state string) ApiGetConnectivityGatewaysRequest {
	r.state = &state
	return r
}

// Refresh
func (r ApiGetConnectivityGatewaysRequest) Refresh(refresh string) ApiGetConnectivityGatewaysRequest {
	r.refresh = &refresh
	return r
}

// Edge type
func (r ApiGetConnectivityGatewaysRequest) EdgeType(edgeType string) ApiGetConnectivityGatewaysRequest {
	r.edgeType = &edgeType
	return r
}

func (r ApiGetConnectivityGatewaysRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetConnectivityGatewaysExecute(r)
}

/*
GetConnectivityGateways Method for GetConnectivityGateways

Get all Connectivity Gateways

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetConnectivityGatewaysRequest
*/
func (a *ConfigurationMultiCloudApiService) GetConnectivityGateways(ctx context.Context) ApiGetConnectivityGatewaysRequest {
	return ApiGetConnectivityGatewaysRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetConnectivityGatewaysExecute(r ApiGetConnectivityGatewaysRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetConnectivityGateways")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/connectivitygateway"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.accountId != nil {
		localVarQueryParams.Add("accountId", parameterToString(*r.accountId, ""))
	}
	if r.cloudType != nil {
		localVarQueryParams.Add("cloudType", parameterToString(*r.cloudType, ""))
	}
	if r.connectivityType != nil {
		localVarQueryParams.Add("connectivityType", parameterToString(*r.connectivityType, ""))
	}
	if r.connectivityGatewayName != nil {
		localVarQueryParams.Add("connectivityGatewayName", parameterToString(*r.connectivityGatewayName, ""))
	}
	if r.region != nil {
		localVarQueryParams.Add("region", parameterToString(*r.region, ""))
	}
	if r.network != nil {
		localVarQueryParams.Add("network", parameterToString(*r.network, ""))
	}
	if r.state != nil {
		localVarQueryParams.Add("state", parameterToString(*r.state, ""))
	}
	if r.refresh != nil {
		localVarQueryParams.Add("refresh", parameterToString(*r.refresh, ""))
	}
	if r.edgeType != nil {
		localVarQueryParams.Add("edgeType", parameterToString(*r.edgeType, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDashboardEdgeInfoRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
}

func (r ApiGetDashboardEdgeInfoRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetDashboardEdgeInfoExecute(r)
}

/*
GetDashboardEdgeInfo Method for GetDashboardEdgeInfo

Get interconnect edge gateway dashboard info

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetDashboardEdgeInfoRequest
*/
func (a *ConfigurationMultiCloudApiService) GetDashboardEdgeInfo(ctx context.Context) ApiGetDashboardEdgeInfoRequest {
	return ApiGetDashboardEdgeInfoRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetDashboardEdgeInfoExecute(r ApiGetDashboardEdgeInfoRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetDashboardEdgeInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/dashboard/edge"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDefaultMappingValuesRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	cloudType *string
}

// Cloud type
func (r ApiGetDefaultMappingValuesRequest) CloudType(cloudType string) ApiGetDefaultMappingValuesRequest {
	r.cloudType = &cloudType
	return r
}

func (r ApiGetDefaultMappingValuesRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetDefaultMappingValuesExecute(r)
}

/*
GetDefaultMappingValues Method for GetDefaultMappingValues

Get default mapping values

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetDefaultMappingValuesRequest
*/
func (a *ConfigurationMultiCloudApiService) GetDefaultMappingValues(ctx context.Context) ApiGetDefaultMappingValuesRequest {
	return ApiGetDefaultMappingValuesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetDefaultMappingValuesExecute(r ApiGetDefaultMappingValuesRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetDefaultMappingValues")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/map/defaults"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.cloudType == nil {
		return localVarReturnValue, nil, reportError("cloudType is required and must be specified")
	}

	localVarQueryParams.Add("cloudType", parameterToString(*r.cloudType, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDeviceLinksRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	edgeType *string
	deviceLinkName *string
}

// Edge type
func (r ApiGetDeviceLinksRequest) EdgeType(edgeType string) ApiGetDeviceLinksRequest {
	r.edgeType = &edgeType
	return r
}

// Device Link Name
func (r ApiGetDeviceLinksRequest) DeviceLinkName(deviceLinkName string) ApiGetDeviceLinksRequest {
	r.deviceLinkName = &deviceLinkName
	return r
}

func (r ApiGetDeviceLinksRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetDeviceLinksExecute(r)
}

/*
GetDeviceLinks Method for GetDeviceLinks

Get Device Links

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetDeviceLinksRequest
*/
func (a *ConfigurationMultiCloudApiService) GetDeviceLinks(ctx context.Context) ApiGetDeviceLinksRequest {
	return ApiGetDeviceLinksRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetDeviceLinksExecute(r ApiGetDeviceLinksRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetDeviceLinks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/devicelink/edge"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.edgeType != nil {
		localVarQueryParams.Add("edgeType", parameterToString(*r.edgeType, ""))
	}
	if r.deviceLinkName != nil {
		localVarQueryParams.Add("deviceLinkName", parameterToString(*r.deviceLinkName, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDlPortSpeedRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	edgeType string
}

func (r ApiGetDlPortSpeedRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetDlPortSpeedExecute(r)
}

/*
GetDlPortSpeed Method for GetDlPortSpeed

Get supported port speed for Device Link

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param edgeType Interconnect Provider
 @return ApiGetDlPortSpeedRequest
*/
func (a *ConfigurationMultiCloudApiService) GetDlPortSpeed(ctx context.Context, edgeType string) ApiGetDlPortSpeedRequest {
	return ApiGetDlPortSpeedRequest{
		ApiService: a,
		ctx: ctx,
		edgeType: edgeType,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetDlPortSpeedExecute(r ApiGetDlPortSpeedRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetDlPortSpeed")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/devicelink/edge/portspeed/{edgeType}"
	localVarPath = strings.Replace(localVarPath, "{"+"edgeType"+"}", url.PathEscape(parameterToString(r.edgeType, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEdgeAccountDetailsRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	accountId string
}

func (r ApiGetEdgeAccountDetailsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetEdgeAccountDetailsExecute(r)
}

/*
GetEdgeAccountDetails Method for GetEdgeAccountDetails

Get edge account by account Id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId Edge Account Id
 @return ApiGetEdgeAccountDetailsRequest
*/
func (a *ConfigurationMultiCloudApiService) GetEdgeAccountDetails(ctx context.Context, accountId string) ApiGetEdgeAccountDetailsRequest {
	return ApiGetEdgeAccountDetailsRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetEdgeAccountDetailsExecute(r ApiGetEdgeAccountDetailsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetEdgeAccountDetails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/accounts/edge/{accountId}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterToString(r.accountId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEdgeAccountsRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	edgeType *string
}

// Edge type
func (r ApiGetEdgeAccountsRequest) EdgeType(edgeType string) ApiGetEdgeAccountsRequest {
	r.edgeType = &edgeType
	return r
}

func (r ApiGetEdgeAccountsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetEdgeAccountsExecute(r)
}

/*
GetEdgeAccounts Method for GetEdgeAccounts

Get all Multicloud edge accounts

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetEdgeAccountsRequest
*/
func (a *ConfigurationMultiCloudApiService) GetEdgeAccounts(ctx context.Context) ApiGetEdgeAccountsRequest {
	return ApiGetEdgeAccountsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetEdgeAccountsExecute(r ApiGetEdgeAccountsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetEdgeAccounts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/accounts/edge"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.edgeType != nil {
		localVarQueryParams.Add("edgeType", parameterToString(*r.edgeType, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEdgeBillingAccountsRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	edgeType string
	edgeAccountId string
	region *string
}

// Region
func (r ApiGetEdgeBillingAccountsRequest) Region(region string) ApiGetEdgeBillingAccountsRequest {
	r.region = &region
	return r
}

func (r ApiGetEdgeBillingAccountsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetEdgeBillingAccountsExecute(r)
}

/*
GetEdgeBillingAccounts Method for GetEdgeBillingAccounts

Get Edge Billing Accounts

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param edgeType Interconnect Provider
 @param edgeAccountId Interconnect Provider Account ID
 @return ApiGetEdgeBillingAccountsRequest
*/
func (a *ConfigurationMultiCloudApiService) GetEdgeBillingAccounts(ctx context.Context, edgeType string, edgeAccountId string) ApiGetEdgeBillingAccountsRequest {
	return ApiGetEdgeBillingAccountsRequest{
		ApiService: a,
		ctx: ctx,
		edgeType: edgeType,
		edgeAccountId: edgeAccountId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetEdgeBillingAccountsExecute(r ApiGetEdgeBillingAccountsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetEdgeBillingAccounts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/billingaccounts/edge/{edgeType}/{edgeAccountId}"
	localVarPath = strings.Replace(localVarPath, "{"+"edgeType"+"}", url.PathEscape(parameterToString(r.edgeType, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"edgeAccountId"+"}", url.PathEscape(parameterToString(r.edgeAccountId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.region != nil {
		localVarQueryParams.Add("region", parameterToString(*r.region, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEdgeConnectivityDetailByNameRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	connectivityName string
}

func (r ApiGetEdgeConnectivityDetailByNameRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetEdgeConnectivityDetailByNameExecute(r)
}

/*
GetEdgeConnectivityDetailByName Method for GetEdgeConnectivityDetailByName

Get Interconnect Connectivity by name

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param connectivityName IC-GW connectivity name
 @return ApiGetEdgeConnectivityDetailByNameRequest
*/
func (a *ConfigurationMultiCloudApiService) GetEdgeConnectivityDetailByName(ctx context.Context, connectivityName string) ApiGetEdgeConnectivityDetailByNameRequest {
	return ApiGetEdgeConnectivityDetailByNameRequest{
		ApiService: a,
		ctx: ctx,
		connectivityName: connectivityName,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetEdgeConnectivityDetailByNameExecute(r ApiGetEdgeConnectivityDetailByNameRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetEdgeConnectivityDetailByName")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/connectivity/edge/{connectivityName}"
	localVarPath = strings.Replace(localVarPath, "{"+"connectivityName"+"}", url.PathEscape(parameterToString(r.connectivityName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEdgeConnectivityDetailsRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	edgeType *string
	connectivityName *string
	connectivityType *string
	edgeGatewayName *string
}

// Edge type
func (r ApiGetEdgeConnectivityDetailsRequest) EdgeType(edgeType string) ApiGetEdgeConnectivityDetailsRequest {
	r.edgeType = &edgeType
	return r
}

// Connectivity Name
func (r ApiGetEdgeConnectivityDetailsRequest) ConnectivityName(connectivityName string) ApiGetEdgeConnectivityDetailsRequest {
	r.connectivityName = &connectivityName
	return r
}

// Connectivity Type
func (r ApiGetEdgeConnectivityDetailsRequest) ConnectivityType(connectivityType string) ApiGetEdgeConnectivityDetailsRequest {
	r.connectivityType = &connectivityType
	return r
}

// Interconnect Gateway name
func (r ApiGetEdgeConnectivityDetailsRequest) EdgeGatewayName(edgeGatewayName string) ApiGetEdgeConnectivityDetailsRequest {
	r.edgeGatewayName = &edgeGatewayName
	return r
}

func (r ApiGetEdgeConnectivityDetailsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetEdgeConnectivityDetailsExecute(r)
}

/*
GetEdgeConnectivityDetails Method for GetEdgeConnectivityDetails

Get Interconnect Connectivity details

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetEdgeConnectivityDetailsRequest
*/
func (a *ConfigurationMultiCloudApiService) GetEdgeConnectivityDetails(ctx context.Context) ApiGetEdgeConnectivityDetailsRequest {
	return ApiGetEdgeConnectivityDetailsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetEdgeConnectivityDetailsExecute(r ApiGetEdgeConnectivityDetailsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetEdgeConnectivityDetails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/connectivity/edge"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.edgeType != nil {
		localVarQueryParams.Add("edgeType", parameterToString(*r.edgeType, ""))
	}
	if r.connectivityName != nil {
		localVarQueryParams.Add("connectivityName", parameterToString(*r.connectivityName, ""))
	}
	if r.connectivityType != nil {
		localVarQueryParams.Add("connectivityType", parameterToString(*r.connectivityType, ""))
	}
	if r.edgeGatewayName != nil {
		localVarQueryParams.Add("edgeGatewayName", parameterToString(*r.edgeGatewayName, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEdgeGatewaysRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	edgeType string
}

func (r ApiGetEdgeGatewaysRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetEdgeGatewaysExecute(r)
}

/*
GetEdgeGateways Method for GetEdgeGateways

Get sites with connectivity to the interconnect gateways by edge type

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param edgeType Edge type
 @return ApiGetEdgeGatewaysRequest
*/
func (a *ConfigurationMultiCloudApiService) GetEdgeGateways(ctx context.Context, edgeType string) ApiGetEdgeGatewaysRequest {
	return ApiGetEdgeGatewaysRequest{
		ApiService: a,
		ctx: ctx,
		edgeType: edgeType,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetEdgeGatewaysExecute(r ApiGetEdgeGatewaysRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetEdgeGateways")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/gateways/edge/{edgeType}"
	localVarPath = strings.Replace(localVarPath, "{"+"edgeType"+"}", url.PathEscape(parameterToString(r.edgeType, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEdgeGlobalSettingsRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	edgeType *string
}

// Edge type
func (r ApiGetEdgeGlobalSettingsRequest) EdgeType(edgeType string) ApiGetEdgeGlobalSettingsRequest {
	r.edgeType = &edgeType
	return r
}

func (r ApiGetEdgeGlobalSettingsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetEdgeGlobalSettingsExecute(r)
}

/*
GetEdgeGlobalSettings Method for GetEdgeGlobalSettings

Get edge global settings

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetEdgeGlobalSettingsRequest
*/
func (a *ConfigurationMultiCloudApiService) GetEdgeGlobalSettings(ctx context.Context) ApiGetEdgeGlobalSettingsRequest {
	return ApiGetEdgeGlobalSettingsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetEdgeGlobalSettingsExecute(r ApiGetEdgeGlobalSettingsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetEdgeGlobalSettings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/settings/edge/global"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.edgeType == nil {
		return localVarReturnValue, nil, reportError("edgeType is required and must be specified")
	}

	localVarQueryParams.Add("edgeType", parameterToString(*r.edgeType, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEdgeLocationsInfoRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	edgeType string
	accountId *string
	region *string
}

// Edge Account Id
func (r ApiGetEdgeLocationsInfoRequest) AccountId(accountId string) ApiGetEdgeLocationsInfoRequest {
	r.accountId = &accountId
	return r
}

// Region
func (r ApiGetEdgeLocationsInfoRequest) Region(region string) ApiGetEdgeLocationsInfoRequest {
	r.region = &region
	return r
}

func (r ApiGetEdgeLocationsInfoRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetEdgeLocationsInfoExecute(r)
}

/*
GetEdgeLocationsInfo Method for GetEdgeLocationsInfo

Get Edge Locations

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param edgeType Edge Type
 @return ApiGetEdgeLocationsInfoRequest
*/
func (a *ConfigurationMultiCloudApiService) GetEdgeLocationsInfo(ctx context.Context, edgeType string) ApiGetEdgeLocationsInfoRequest {
	return ApiGetEdgeLocationsInfoRequest{
		ApiService: a,
		ctx: ctx,
		edgeType: edgeType,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetEdgeLocationsInfoExecute(r ApiGetEdgeLocationsInfoRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetEdgeLocationsInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/locations/edge/{edgeType}"
	localVarPath = strings.Replace(localVarPath, "{"+"edgeType"+"}", url.PathEscape(parameterToString(r.edgeType, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.accountId != nil {
		localVarQueryParams.Add("accountId", parameterToString(*r.accountId, ""))
	}
	if r.region != nil {
		localVarQueryParams.Add("region", parameterToString(*r.region, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEdgeMappingTagsRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	cloudType *string
	accountId *string
	resourceGroup *string
}

// Cloud type
func (r ApiGetEdgeMappingTagsRequest) CloudType(cloudType string) ApiGetEdgeMappingTagsRequest {
	r.cloudType = &cloudType
	return r
}

// Cloud Account Id
func (r ApiGetEdgeMappingTagsRequest) AccountId(accountId string) ApiGetEdgeMappingTagsRequest {
	r.accountId = &accountId
	return r
}

// Resource Group
func (r ApiGetEdgeMappingTagsRequest) ResourceGroup(resourceGroup string) ApiGetEdgeMappingTagsRequest {
	r.resourceGroup = &resourceGroup
	return r
}

func (r ApiGetEdgeMappingTagsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetEdgeMappingTagsExecute(r)
}

/*
GetEdgeMappingTags Method for GetEdgeMappingTags

Get default Interconnect mapping tag values

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetEdgeMappingTagsRequest
*/
func (a *ConfigurationMultiCloudApiService) GetEdgeMappingTags(ctx context.Context) ApiGetEdgeMappingTagsRequest {
	return ApiGetEdgeMappingTagsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetEdgeMappingTagsExecute(r ApiGetEdgeMappingTagsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetEdgeMappingTags")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/map/tags/edge"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.cloudType == nil {
		return localVarReturnValue, nil, reportError("cloudType is required and must be specified")
	}

	localVarQueryParams.Add("cloudType", parameterToString(*r.cloudType, ""))
	if r.accountId != nil {
		localVarQueryParams.Add("accountId", parameterToString(*r.accountId, ""))
	}
	if r.resourceGroup != nil {
		localVarQueryParams.Add("resourceGroup", parameterToString(*r.resourceGroup, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEdgeTypesRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
}

func (r ApiGetEdgeTypesRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetEdgeTypesExecute(r)
}

/*
GetEdgeTypes Method for GetEdgeTypes

Get edge types

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetEdgeTypesRequest
*/
func (a *ConfigurationMultiCloudApiService) GetEdgeTypes(ctx context.Context) ApiGetEdgeTypesRequest {
	return ApiGetEdgeTypesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetEdgeTypesExecute(r ApiGetEdgeTypesRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetEdgeTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/types/edge"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEdgeWanDevicesRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	edgeType string
}

func (r ApiGetEdgeWanDevicesRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetEdgeWanDevicesExecute(r)
}

/*
GetEdgeWanDevices Method for GetEdgeWanDevices

Get available WAN edge devices

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param edgeType Edge Type
 @return ApiGetEdgeWanDevicesRequest
*/
func (a *ConfigurationMultiCloudApiService) GetEdgeWanDevices(ctx context.Context, edgeType string) ApiGetEdgeWanDevicesRequest {
	return ApiGetEdgeWanDevicesRequest{
		ApiService: a,
		ctx: ctx,
		edgeType: edgeType,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetEdgeWanDevicesExecute(r ApiGetEdgeWanDevicesRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetEdgeWanDevices")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/edge/{edgeType}/device"
	localVarPath = strings.Replace(localVarPath, "{"+"edgeType"+"}", url.PathEscape(parameterToString(r.edgeType, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEdgeWidgetRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	edgeType string
}

func (r ApiGetEdgeWidgetRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetEdgeWidgetExecute(r)
}

/*
GetEdgeWidget Method for GetEdgeWidget

Get Interconnect Edge widget by edge type

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param edgeType Edge type
 @return ApiGetEdgeWidgetRequest
*/
func (a *ConfigurationMultiCloudApiService) GetEdgeWidget(ctx context.Context, edgeType string) ApiGetEdgeWidgetRequest {
	return ApiGetEdgeWidgetRequest{
		ApiService: a,
		ctx: ctx,
		edgeType: edgeType,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetEdgeWidgetExecute(r ApiGetEdgeWidgetRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetEdgeWidget")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/widget/edge/{edgeType}"
	localVarPath = strings.Replace(localVarPath, "{"+"edgeType"+"}", url.PathEscape(parameterToString(r.edgeType, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetGlobalSettingsRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	cloudType *string
}

// Cloud type
func (r ApiGetGlobalSettingsRequest) CloudType(cloudType string) ApiGetGlobalSettingsRequest {
	r.cloudType = &cloudType
	return r
}

func (r ApiGetGlobalSettingsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetGlobalSettingsExecute(r)
}

/*
GetGlobalSettings Method for GetGlobalSettings

Get global settings

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetGlobalSettingsRequest
*/
func (a *ConfigurationMultiCloudApiService) GetGlobalSettings(ctx context.Context) ApiGetGlobalSettingsRequest {
	return ApiGetGlobalSettingsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetGlobalSettingsExecute(r ApiGetGlobalSettingsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetGlobalSettings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/settings/global"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.cloudType == nil {
		return localVarReturnValue, nil, reportError("cloudType is required and must be specified")
	}

	localVarQueryParams.Add("cloudType", parameterToString(*r.cloudType, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetHostVpcsRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	cloudType *string
	accountIds *string
	region *string
	untagged *string
}

// Cloud type
func (r ApiGetHostVpcsRequest) CloudType(cloudType string) ApiGetHostVpcsRequest {
	r.cloudType = &cloudType
	return r
}

// Account Id
func (r ApiGetHostVpcsRequest) AccountIds(accountIds string) ApiGetHostVpcsRequest {
	r.accountIds = &accountIds
	return r
}

// Region
func (r ApiGetHostVpcsRequest) Region(region string) ApiGetHostVpcsRequest {
	r.region = &region
	return r
}

// Untagged flag
func (r ApiGetHostVpcsRequest) Untagged(untagged string) ApiGetHostVpcsRequest {
	r.untagged = &untagged
	return r
}

func (r ApiGetHostVpcsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetHostVpcsExecute(r)
}

/*
GetHostVpcs Method for GetHostVpcs

Get tagged, untagged, or all Host VPCs

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetHostVpcsRequest
*/
func (a *ConfigurationMultiCloudApiService) GetHostVpcs(ctx context.Context) ApiGetHostVpcsRequest {
	return ApiGetHostVpcsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetHostVpcsExecute(r ApiGetHostVpcsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetHostVpcs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/hostvpc"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.cloudType == nil {
		return localVarReturnValue, nil, reportError("cloudType is required and must be specified")
	}

	localVarQueryParams.Add("cloudType", parameterToString(*r.cloudType, ""))
	if r.accountIds != nil {
		localVarQueryParams.Add("accountIds", parameterToString(*r.accountIds, ""))
	}
	if r.region != nil {
		localVarQueryParams.Add("region", parameterToString(*r.region, ""))
	}
	if r.untagged != nil {
		localVarQueryParams.Add("untagged", parameterToString(*r.untagged, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetIcgwCustomSettingDetailsRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	edgeGatewayName string
}

func (r ApiGetIcgwCustomSettingDetailsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetIcgwCustomSettingDetailsExecute(r)
}

/*
GetIcgwCustomSettingDetails Method for GetIcgwCustomSettingDetails

Get Interconnect Gateway custom setting by Interconnect Gateway name

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param edgeGatewayName Edge gateway name
 @return ApiGetIcgwCustomSettingDetailsRequest
*/
func (a *ConfigurationMultiCloudApiService) GetIcgwCustomSettingDetails(ctx context.Context, edgeGatewayName string) ApiGetIcgwCustomSettingDetailsRequest {
	return ApiGetIcgwCustomSettingDetailsRequest{
		ApiService: a,
		ctx: ctx,
		edgeGatewayName: edgeGatewayName,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetIcgwCustomSettingDetailsExecute(r ApiGetIcgwCustomSettingDetailsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetIcgwCustomSettingDetails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/gateway/edge/setting/{edgeGatewayName}"
	localVarPath = strings.Replace(localVarPath, "{"+"edgeGatewayName"+"}", url.PathEscape(parameterToString(r.edgeGatewayName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetIcgwDetailsRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	edgeGatewayName string
}

func (r ApiGetIcgwDetailsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetIcgwDetailsExecute(r)
}

/*
GetIcgwDetails Method for GetIcgwDetails

Get Interconnect Gateway by name

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param edgeGatewayName Edge gateway name
 @return ApiGetIcgwDetailsRequest
*/
func (a *ConfigurationMultiCloudApiService) GetIcgwDetails(ctx context.Context, edgeGatewayName string) ApiGetIcgwDetailsRequest {
	return ApiGetIcgwDetailsRequest{
		ApiService: a,
		ctx: ctx,
		edgeGatewayName: edgeGatewayName,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetIcgwDetailsExecute(r ApiGetIcgwDetailsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetIcgwDetails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/gateway/edge/{edgeGatewayName}"
	localVarPath = strings.Replace(localVarPath, "{"+"edgeGatewayName"+"}", url.PathEscape(parameterToString(r.edgeGatewayName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetIcgwTypesRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	edgeType *string
}

// Edge type
func (r ApiGetIcgwTypesRequest) EdgeType(edgeType string) ApiGetIcgwTypesRequest {
	r.edgeType = &edgeType
	return r
}

func (r ApiGetIcgwTypesRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetIcgwTypesExecute(r)
}

/*
GetIcgwTypes Method for GetIcgwTypes

Get Interconnect Gateway type for specified Edge Provider

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetIcgwTypesRequest
*/
func (a *ConfigurationMultiCloudApiService) GetIcgwTypes(ctx context.Context) ApiGetIcgwTypesRequest {
	return ApiGetIcgwTypesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetIcgwTypesExecute(r ApiGetIcgwTypesRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetIcgwTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/gateway/edge/types"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.edgeType != nil {
		localVarQueryParams.Add("edgeType", parameterToString(*r.edgeType, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetIcgwsRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	edgeType *string
	accountId *string
	region *string
	regionId *string
	resourceState *string
	edgeGatewayName *string
	billingAccountId *string
}

// Edge type
func (r ApiGetIcgwsRequest) EdgeType(edgeType string) ApiGetIcgwsRequest {
	r.edgeType = &edgeType
	return r
}

// Account Id
func (r ApiGetIcgwsRequest) AccountId(accountId string) ApiGetIcgwsRequest {
	r.accountId = &accountId
	return r
}

// Region
func (r ApiGetIcgwsRequest) Region(region string) ApiGetIcgwsRequest {
	r.region = &region
	return r
}

// Region Id
func (r ApiGetIcgwsRequest) RegionId(regionId string) ApiGetIcgwsRequest {
	r.regionId = &regionId
	return r
}

// Resource State
func (r ApiGetIcgwsRequest) ResourceState(resourceState string) ApiGetIcgwsRequest {
	r.resourceState = &resourceState
	return r
}

// Edge gateway name
func (r ApiGetIcgwsRequest) EdgeGatewayName(edgeGatewayName string) ApiGetIcgwsRequest {
	r.edgeGatewayName = &edgeGatewayName
	return r
}

// billing Account Id
func (r ApiGetIcgwsRequest) BillingAccountId(billingAccountId string) ApiGetIcgwsRequest {
	r.billingAccountId = &billingAccountId
	return r
}

func (r ApiGetIcgwsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetIcgwsExecute(r)
}

/*
GetIcgws Method for GetIcgws

Get Interconnect Gateways

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetIcgwsRequest
*/
func (a *ConfigurationMultiCloudApiService) GetIcgws(ctx context.Context) ApiGetIcgwsRequest {
	return ApiGetIcgwsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetIcgwsExecute(r ApiGetIcgwsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetIcgws")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/gateway/edge"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.edgeType != nil {
		localVarQueryParams.Add("edgeType", parameterToString(*r.edgeType, ""))
	}
	if r.accountId != nil {
		localVarQueryParams.Add("accountId", parameterToString(*r.accountId, ""))
	}
	if r.region != nil {
		localVarQueryParams.Add("region", parameterToString(*r.region, ""))
	}
	if r.regionId != nil {
		localVarQueryParams.Add("regionId", parameterToString(*r.regionId, ""))
	}
	if r.resourceState != nil {
		localVarQueryParams.Add("resourceState", parameterToString(*r.resourceState, ""))
	}
	if r.edgeGatewayName != nil {
		localVarQueryParams.Add("edgeGatewayName", parameterToString(*r.edgeGatewayName, ""))
	}
	if r.billingAccountId != nil {
		localVarQueryParams.Add("billingAccountId", parameterToString(*r.billingAccountId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMappingMatrixRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	cloudType *string
}

// Cloud type
func (r ApiGetMappingMatrixRequest) CloudType(cloudType string) ApiGetMappingMatrixRequest {
	r.cloudType = &cloudType
	return r
}

func (r ApiGetMappingMatrixRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetMappingMatrixExecute(r)
}

/*
GetMappingMatrix Method for GetMappingMatrix

Get default mapping values

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetMappingMatrixRequest
*/
func (a *ConfigurationMultiCloudApiService) GetMappingMatrix(ctx context.Context) ApiGetMappingMatrixRequest {
	return ApiGetMappingMatrixRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetMappingMatrixExecute(r ApiGetMappingMatrixRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetMappingMatrix")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/map"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.cloudType == nil {
		return localVarReturnValue, nil, reportError("cloudType is required and must be specified")
	}

	localVarQueryParams.Add("cloudType", parameterToString(*r.cloudType, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMappingStatusRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	cloudType *string
	region *string
}

// Cloud type
func (r ApiGetMappingStatusRequest) CloudType(cloudType string) ApiGetMappingStatusRequest {
	r.cloudType = &cloudType
	return r
}

// Region
func (r ApiGetMappingStatusRequest) Region(region string) ApiGetMappingStatusRequest {
	r.region = &region
	return r
}

func (r ApiGetMappingStatusRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetMappingStatusExecute(r)
}

/*
GetMappingStatus Method for GetMappingStatus

Get mapping status

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetMappingStatusRequest
*/
func (a *ConfigurationMultiCloudApiService) GetMappingStatus(ctx context.Context) ApiGetMappingStatusRequest {
	return ApiGetMappingStatusRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetMappingStatusExecute(r ApiGetMappingStatusRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetMappingStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/map/status"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.cloudType != nil {
		localVarQueryParams.Add("cloudType", parameterToString(*r.cloudType, ""))
	}
	if r.region != nil {
		localVarQueryParams.Add("region", parameterToString(*r.region, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMappingSummaryRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	vpnTunnelStatus *bool
	cloudType *string
}

// VPN tunnel status
func (r ApiGetMappingSummaryRequest) VpnTunnelStatus(vpnTunnelStatus bool) ApiGetMappingSummaryRequest {
	r.vpnTunnelStatus = &vpnTunnelStatus
	return r
}

// Cloud type
func (r ApiGetMappingSummaryRequest) CloudType(cloudType string) ApiGetMappingSummaryRequest {
	r.cloudType = &cloudType
	return r
}

func (r ApiGetMappingSummaryRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetMappingSummaryExecute(r)
}

/*
GetMappingSummary Method for GetMappingSummary

Get mapping summary

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetMappingSummaryRequest
*/
func (a *ConfigurationMultiCloudApiService) GetMappingSummary(ctx context.Context) ApiGetMappingSummaryRequest {
	return ApiGetMappingSummaryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetMappingSummaryExecute(r ApiGetMappingSummaryRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetMappingSummary")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/map/summary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.vpnTunnelStatus != nil {
		localVarQueryParams.Add("vpnTunnelStatus", parameterToString(*r.vpnTunnelStatus, ""))
	}
	if r.cloudType != nil {
		localVarQueryParams.Add("cloudType", parameterToString(*r.cloudType, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMappingTagsRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	cloudType *string
}

// Cloud type
func (r ApiGetMappingTagsRequest) CloudType(cloudType string) ApiGetMappingTagsRequest {
	r.cloudType = &cloudType
	return r
}

func (r ApiGetMappingTagsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetMappingTagsExecute(r)
}

/*
GetMappingTags Method for GetMappingTags

Get default mapping values

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetMappingTagsRequest
*/
func (a *ConfigurationMultiCloudApiService) GetMappingTags(ctx context.Context) ApiGetMappingTagsRequest {
	return ApiGetMappingTagsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetMappingTagsExecute(r ApiGetMappingTagsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetMappingTags")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/map/tags"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.cloudType == nil {
		return localVarReturnValue, nil, reportError("cloudType is required and must be specified")
	}

	localVarQueryParams.Add("cloudType", parameterToString(*r.cloudType, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMappingVpnsRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
}

func (r ApiGetMappingVpnsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetMappingVpnsExecute(r)
}

/*
GetMappingVpns Method for GetMappingVpns

Get default mapping values

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetMappingVpnsRequest
*/
func (a *ConfigurationMultiCloudApiService) GetMappingVpns(ctx context.Context) ApiGetMappingVpnsRequest {
	return ApiGetMappingVpnsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetMappingVpnsExecute(r ApiGetMappingVpnsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetMappingVpns")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/map/vpns"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNvaSecurityRulesRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	cloudGatewayName string
	body *map[string]interface{}
}

// Get NVA security Rules
func (r ApiGetNvaSecurityRulesRequest) Body(body map[string]interface{}) ApiGetNvaSecurityRulesRequest {
	r.body = &body
	return r
}

func (r ApiGetNvaSecurityRulesRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetNvaSecurityRulesExecute(r)
}

/*
GetNvaSecurityRules Method for GetNvaSecurityRules

Get NVA Security Rules

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cloudGatewayName Cloud gateway name
 @return ApiGetNvaSecurityRulesRequest
*/
func (a *ConfigurationMultiCloudApiService) GetNvaSecurityRules(ctx context.Context, cloudGatewayName string) ApiGetNvaSecurityRulesRequest {
	return ApiGetNvaSecurityRulesRequest{
		ApiService: a,
		ctx: ctx,
		cloudGatewayName: cloudGatewayName,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetNvaSecurityRulesExecute(r ApiGetNvaSecurityRulesRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetNvaSecurityRules")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/cloudgateway/nvaSecurityRules/{cloudGatewayName}"
	localVarPath = strings.Replace(localVarPath, "{"+"cloudGatewayName"+"}", url.PathEscape(parameterToString(r.cloudGatewayName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPartnerPortsRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	edgeType *string
	accountId *string
	cloudType *string
	connectType *string
	vxcPermitted *string
	authorizationKey *string
	refresh *string
}

// Edge type
func (r ApiGetPartnerPortsRequest) EdgeType(edgeType string) ApiGetPartnerPortsRequest {
	r.edgeType = &edgeType
	return r
}

// Edge Account Id
func (r ApiGetPartnerPortsRequest) AccountId(accountId string) ApiGetPartnerPortsRequest {
	r.accountId = &accountId
	return r
}

// Cloud Type
func (r ApiGetPartnerPortsRequest) CloudType(cloudType string) ApiGetPartnerPortsRequest {
	r.cloudType = &cloudType
	return r
}

// Connect Type filter
func (r ApiGetPartnerPortsRequest) ConnectType(connectType string) ApiGetPartnerPortsRequest {
	r.connectType = &connectType
	return r
}

// VXC Permitted on the port
func (r ApiGetPartnerPortsRequest) VxcPermitted(vxcPermitted string) ApiGetPartnerPortsRequest {
	r.vxcPermitted = &vxcPermitted
	return r
}

// authorization Key
func (r ApiGetPartnerPortsRequest) AuthorizationKey(authorizationKey string) ApiGetPartnerPortsRequest {
	r.authorizationKey = &authorizationKey
	return r
}

// Refresh
func (r ApiGetPartnerPortsRequest) Refresh(refresh string) ApiGetPartnerPortsRequest {
	r.refresh = &refresh
	return r
}

func (r ApiGetPartnerPortsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetPartnerPortsExecute(r)
}

/*
GetPartnerPorts Method for GetPartnerPorts

Get partner ports

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetPartnerPortsRequest
*/
func (a *ConfigurationMultiCloudApiService) GetPartnerPorts(ctx context.Context) ApiGetPartnerPortsRequest {
	return ApiGetPartnerPortsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetPartnerPortsExecute(r ApiGetPartnerPortsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetPartnerPorts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/partnerports/edge"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.edgeType != nil {
		localVarQueryParams.Add("edgeType", parameterToString(*r.edgeType, ""))
	}
	if r.accountId != nil {
		localVarQueryParams.Add("accountId", parameterToString(*r.accountId, ""))
	}
	if r.cloudType != nil {
		localVarQueryParams.Add("cloudType", parameterToString(*r.cloudType, ""))
	}
	if r.connectType != nil {
		localVarQueryParams.Add("connectType", parameterToString(*r.connectType, ""))
	}
	if r.vxcPermitted != nil {
		localVarQueryParams.Add("vxcPermitted", parameterToString(*r.vxcPermitted, ""))
	}
	if r.authorizationKey != nil {
		localVarQueryParams.Add("authorizationKey", parameterToString(*r.authorizationKey, ""))
	}
	if r.refresh != nil {
		localVarQueryParams.Add("refresh", parameterToString(*r.refresh, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPortSpeedRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	edgeType string
	edgeAccountId string
	connectivityType string
	cloudType *string
	cloudAccountId *string
	connectType *string
	connectSubType *string
	connectivityGateway *string
	partnerPort *string
}

// Cloud Service Provider
func (r ApiGetPortSpeedRequest) CloudType(cloudType string) ApiGetPortSpeedRequest {
	r.cloudType = &cloudType
	return r
}

// Cloud Service Provider Account ID
func (r ApiGetPortSpeedRequest) CloudAccountId(cloudAccountId string) ApiGetPortSpeedRequest {
	r.cloudAccountId = &cloudAccountId
	return r
}

// Connection Type filter
func (r ApiGetPortSpeedRequest) ConnectType(connectType string) ApiGetPortSpeedRequest {
	r.connectType = &connectType
	return r
}

// Connection Sub-Type filter
func (r ApiGetPortSpeedRequest) ConnectSubType(connectSubType string) ApiGetPortSpeedRequest {
	r.connectSubType = &connectSubType
	return r
}

// Connectivity Gateway
func (r ApiGetPortSpeedRequest) ConnectivityGateway(connectivityGateway string) ApiGetPortSpeedRequest {
	r.connectivityGateway = &connectivityGateway
	return r
}

// partnerPort
func (r ApiGetPortSpeedRequest) PartnerPort(partnerPort string) ApiGetPortSpeedRequest {
	r.partnerPort = &partnerPort
	return r
}

func (r ApiGetPortSpeedRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetPortSpeedExecute(r)
}

/*
GetPortSpeed Method for GetPortSpeed

Get supported port speed

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param edgeType Interconnect Provider
 @param edgeAccountId Interconnect Provider Account ID
 @param connectivityType Interconnect Connectivity Type
 @return ApiGetPortSpeedRequest
*/
func (a *ConfigurationMultiCloudApiService) GetPortSpeed(ctx context.Context, edgeType string, edgeAccountId string, connectivityType string) ApiGetPortSpeedRequest {
	return ApiGetPortSpeedRequest{
		ApiService: a,
		ctx: ctx,
		edgeType: edgeType,
		edgeAccountId: edgeAccountId,
		connectivityType: connectivityType,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetPortSpeedExecute(r ApiGetPortSpeedRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetPortSpeed")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/portSpeed/edge/{edgeType}/{edgeAccountId}/{connectivityType}"
	localVarPath = strings.Replace(localVarPath, "{"+"edgeType"+"}", url.PathEscape(parameterToString(r.edgeType, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"edgeAccountId"+"}", url.PathEscape(parameterToString(r.edgeAccountId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"connectivityType"+"}", url.PathEscape(parameterToString(r.connectivityType, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.cloudType != nil {
		localVarQueryParams.Add("cloudType", parameterToString(*r.cloudType, ""))
	}
	if r.cloudAccountId != nil {
		localVarQueryParams.Add("cloudAccountId", parameterToString(*r.cloudAccountId, ""))
	}
	if r.connectType != nil {
		localVarQueryParams.Add("connectType", parameterToString(*r.connectType, ""))
	}
	if r.connectSubType != nil {
		localVarQueryParams.Add("connectSubType", parameterToString(*r.connectSubType, ""))
	}
	if r.connectivityGateway != nil {
		localVarQueryParams.Add("connectivityGateway", parameterToString(*r.connectivityGateway, ""))
	}
	if r.partnerPort != nil {
		localVarQueryParams.Add("partnerPort", parameterToString(*r.partnerPort, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPostAggregationDataByQuery25Request struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	body *map[string]interface{}
}

// Stats query string
func (r ApiGetPostAggregationDataByQuery25Request) Body(body map[string]interface{}) ApiGetPostAggregationDataByQuery25Request {
	r.body = &body
	return r
}

func (r ApiGetPostAggregationDataByQuery25Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetPostAggregationDataByQuery25Execute(r)
}

/*
GetPostAggregationDataByQuery25 Method for GetPostAggregationDataByQuery25

Get aggregated data based on input query and filters. The data can be filtered on time and other unique parameters based upon necessity and intended usage

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetPostAggregationDataByQuery25Request
*/
func (a *ConfigurationMultiCloudApiService) GetPostAggregationDataByQuery25(ctx context.Context) ApiGetPostAggregationDataByQuery25Request {
	return ApiGetPostAggregationDataByQuery25Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetPostAggregationDataByQuery25Execute(r ApiGetPostAggregationDataByQuery25Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetPostAggregationDataByQuery25")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/statistics/interface/aggregation"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSitesRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	color *string
	attached *bool
}

// Color
func (r ApiGetSitesRequest) Color(color string) ApiGetSitesRequest {
	r.color = &color
	return r
}

// Is endpoint attached
func (r ApiGetSitesRequest) Attached(attached bool) ApiGetSitesRequest {
	r.attached = &attached
	return r
}

func (r ApiGetSitesRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetSitesExecute(r)
}

/*
GetSites Method for GetSites

Get available sites

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSitesRequest
*/
func (a *ConfigurationMultiCloudApiService) GetSites(ctx context.Context) ApiGetSitesRequest {
	return ApiGetSitesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetSitesExecute(r ApiGetSitesRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetSites")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/site"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.color != nil {
		localVarQueryParams.Add("color", parameterToString(*r.color, ""))
	}
	if r.attached != nil {
		localVarQueryParams.Add("attached", parameterToString(*r.attached, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSites1Request struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	cloudGatewayName string
	systemIp *string
	siteId *string
	color *string
	vpnTunnelStatus *bool
}

// System IP
func (r ApiGetSites1Request) SystemIp(systemIp string) ApiGetSites1Request {
	r.systemIp = &systemIp
	return r
}

// Site Id
func (r ApiGetSites1Request) SiteId(siteId string) ApiGetSites1Request {
	r.siteId = &siteId
	return r
}

// Color
func (r ApiGetSites1Request) Color(color string) ApiGetSites1Request {
	r.color = &color
	return r
}

// Fetch vpnTunnelStatus
func (r ApiGetSites1Request) VpnTunnelStatus(vpnTunnelStatus bool) ApiGetSites1Request {
	r.vpnTunnelStatus = &vpnTunnelStatus
	return r
}

func (r ApiGetSites1Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetSites1Execute(r)
}

/*
GetSites1 Method for GetSites1

Get sites attached to CGW

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cloudGatewayName Cloud gateway name
 @return ApiGetSites1Request
*/
func (a *ConfigurationMultiCloudApiService) GetSites1(ctx context.Context, cloudGatewayName string) ApiGetSites1Request {
	return ApiGetSites1Request{
		ApiService: a,
		ctx: ctx,
		cloudGatewayName: cloudGatewayName,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetSites1Execute(r ApiGetSites1Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetSites1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/cloudgateway/{cloudGatewayName}/site"
	localVarPath = strings.Replace(localVarPath, "{"+"cloudGatewayName"+"}", url.PathEscape(parameterToString(r.cloudGatewayName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.systemIp != nil {
		localVarQueryParams.Add("systemIp", parameterToString(*r.systemIp, ""))
	}
	if r.siteId != nil {
		localVarQueryParams.Add("siteId", parameterToString(*r.siteId, ""))
	}
	if r.color != nil {
		localVarQueryParams.Add("color", parameterToString(*r.color, ""))
	}
	if r.vpnTunnelStatus != nil {
		localVarQueryParams.Add("vpnTunnelStatus", parameterToString(*r.vpnTunnelStatus, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSshKeyListRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	cloudType *string
	accountId *string
	cloudRegion *string
}

// Cloud type
func (r ApiGetSshKeyListRequest) CloudType(cloudType string) ApiGetSshKeyListRequest {
	r.cloudType = &cloudType
	return r
}

// Account Id
func (r ApiGetSshKeyListRequest) AccountId(accountId string) ApiGetSshKeyListRequest {
	r.accountId = &accountId
	return r
}

// Region
func (r ApiGetSshKeyListRequest) CloudRegion(cloudRegion string) ApiGetSshKeyListRequest {
	r.cloudRegion = &cloudRegion
	return r
}

func (r ApiGetSshKeyListRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetSshKeyListExecute(r)
}

/*
GetSshKeyList Method for GetSshKeyList

Get SSH keys

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSshKeyListRequest
*/
func (a *ConfigurationMultiCloudApiService) GetSshKeyList(ctx context.Context) ApiGetSshKeyListRequest {
	return ApiGetSshKeyListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetSshKeyListExecute(r ApiGetSshKeyListRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetSshKeyList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/sshkeys"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.cloudType == nil {
		return localVarReturnValue, nil, reportError("cloudType is required and must be specified")
	}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.cloudRegion == nil {
		return localVarReturnValue, nil, reportError("cloudRegion is required and must be specified")
	}

	localVarQueryParams.Add("cloudType", parameterToString(*r.cloudType, ""))
	localVarQueryParams.Add("accountId", parameterToString(*r.accountId, ""))
	localVarQueryParams.Add("cloudRegion", parameterToString(*r.cloudRegion, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSupportedEdgeImageNamesRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	edgeType *string
}

// Edge type
func (r ApiGetSupportedEdgeImageNamesRequest) EdgeType(edgeType string) ApiGetSupportedEdgeImageNamesRequest {
	r.edgeType = &edgeType
	return r
}

func (r ApiGetSupportedEdgeImageNamesRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetSupportedEdgeImageNamesExecute(r)
}

/*
GetSupportedEdgeImageNames Method for GetSupportedEdgeImageNames

Get Edge provider supported images

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSupportedEdgeImageNamesRequest
*/
func (a *ConfigurationMultiCloudApiService) GetSupportedEdgeImageNames(ctx context.Context) ApiGetSupportedEdgeImageNamesRequest {
	return ApiGetSupportedEdgeImageNamesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetSupportedEdgeImageNamesExecute(r ApiGetSupportedEdgeImageNamesRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetSupportedEdgeImageNames")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/imagename/edge"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.edgeType != nil {
		localVarQueryParams.Add("edgeType", parameterToString(*r.edgeType, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSupportedEdgeInstanceSizeRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	edgeType *string
}

// Edge type
func (r ApiGetSupportedEdgeInstanceSizeRequest) EdgeType(edgeType string) ApiGetSupportedEdgeInstanceSizeRequest {
	r.edgeType = &edgeType
	return r
}

func (r ApiGetSupportedEdgeInstanceSizeRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetSupportedEdgeInstanceSizeExecute(r)
}

/*
GetSupportedEdgeInstanceSize Method for GetSupportedEdgeInstanceSize

Get Edge provider supported size

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSupportedEdgeInstanceSizeRequest
*/
func (a *ConfigurationMultiCloudApiService) GetSupportedEdgeInstanceSize(ctx context.Context) ApiGetSupportedEdgeInstanceSizeRequest {
	return ApiGetSupportedEdgeInstanceSizeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetSupportedEdgeInstanceSizeExecute(r ApiGetSupportedEdgeInstanceSizeRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetSupportedEdgeInstanceSize")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/instancesize/edge"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.edgeType != nil {
		localVarQueryParams.Add("edgeType", parameterToString(*r.edgeType, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSupportedInstanceSizeRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	cloudType *string
	accountId *string
	cloudRegion *string
}

func (r ApiGetSupportedInstanceSizeRequest) CloudType(cloudType string) ApiGetSupportedInstanceSizeRequest {
	r.cloudType = &cloudType
	return r
}

func (r ApiGetSupportedInstanceSizeRequest) AccountId(accountId string) ApiGetSupportedInstanceSizeRequest {
	r.accountId = &accountId
	return r
}

func (r ApiGetSupportedInstanceSizeRequest) CloudRegion(cloudRegion string) ApiGetSupportedInstanceSizeRequest {
	r.cloudRegion = &cloudRegion
	return r
}

func (r ApiGetSupportedInstanceSizeRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetSupportedInstanceSizeExecute(r)
}

/*
GetSupportedInstanceSize Method for GetSupportedInstanceSize

Get Transit VPC supported size

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSupportedInstanceSizeRequest
*/
func (a *ConfigurationMultiCloudApiService) GetSupportedInstanceSize(ctx context.Context) ApiGetSupportedInstanceSizeRequest {
	return ApiGetSupportedInstanceSizeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetSupportedInstanceSizeExecute(r ApiGetSupportedInstanceSizeRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetSupportedInstanceSize")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/instancesize"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.cloudType == nil {
		return localVarReturnValue, nil, reportError("cloudType is required and must be specified")
	}

	localVarQueryParams.Add("cloudType", parameterToString(*r.cloudType, ""))
	if r.accountId != nil {
		localVarQueryParams.Add("accountId", parameterToString(*r.accountId, ""))
	}
	if r.cloudRegion != nil {
		localVarQueryParams.Add("cloudRegion", parameterToString(*r.cloudRegion, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSupportedLoopbackCgwColorsRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
}

func (r ApiGetSupportedLoopbackCgwColorsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetSupportedLoopbackCgwColorsExecute(r)
}

/*
GetSupportedLoopbackCgwColors Method for GetSupportedLoopbackCgwColors

Get Edge Loopback CGW supported colors

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSupportedLoopbackCgwColorsRequest
*/
func (a *ConfigurationMultiCloudApiService) GetSupportedLoopbackCgwColors(ctx context.Context) ApiGetSupportedLoopbackCgwColorsRequest {
	return ApiGetSupportedLoopbackCgwColorsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetSupportedLoopbackCgwColorsExecute(r ApiGetSupportedLoopbackCgwColorsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetSupportedLoopbackCgwColors")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/loopbackCGWColor/edge"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSupportedSoftwareImageListRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	cloudType *string
	accountId *string
	cloudRegion *string
}

// Cloud type
func (r ApiGetSupportedSoftwareImageListRequest) CloudType(cloudType string) ApiGetSupportedSoftwareImageListRequest {
	r.cloudType = &cloudType
	return r
}

// Account Id
func (r ApiGetSupportedSoftwareImageListRequest) AccountId(accountId string) ApiGetSupportedSoftwareImageListRequest {
	r.accountId = &accountId
	return r
}

// Region
func (r ApiGetSupportedSoftwareImageListRequest) CloudRegion(cloudRegion string) ApiGetSupportedSoftwareImageListRequest {
	r.cloudRegion = &cloudRegion
	return r
}

func (r ApiGetSupportedSoftwareImageListRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetSupportedSoftwareImageListExecute(r)
}

/*
GetSupportedSoftwareImageList Method for GetSupportedSoftwareImageList

Get software image list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSupportedSoftwareImageListRequest
*/
func (a *ConfigurationMultiCloudApiService) GetSupportedSoftwareImageList(ctx context.Context) ApiGetSupportedSoftwareImageListRequest {
	return ApiGetSupportedSoftwareImageListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetSupportedSoftwareImageListExecute(r ApiGetSupportedSoftwareImageListRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetSupportedSoftwareImageList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/swimages"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.cloudType == nil {
		return localVarReturnValue, nil, reportError("cloudType is required and must be specified")
	}

	localVarQueryParams.Add("cloudType", parameterToString(*r.cloudType, ""))
	if r.accountId != nil {
		localVarQueryParams.Add("accountId", parameterToString(*r.accountId, ""))
	}
	if r.cloudRegion != nil {
		localVarQueryParams.Add("cloudRegion", parameterToString(*r.cloudRegion, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTunnelNamesRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	cloudType string
	cloudGatewayName *string
}

// Cloud gateway name
func (r ApiGetTunnelNamesRequest) CloudGatewayName(cloudGatewayName string) ApiGetTunnelNamesRequest {
	r.cloudGatewayName = &cloudGatewayName
	return r
}

func (r ApiGetTunnelNamesRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetTunnelNamesExecute(r)
}

/*
GetTunnelNames Method for GetTunnelNames

Get tunnel names

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cloudType Cloud type
 @return ApiGetTunnelNamesRequest
*/
func (a *ConfigurationMultiCloudApiService) GetTunnelNames(ctx context.Context, cloudType string) ApiGetTunnelNamesRequest {
	return ApiGetTunnelNamesRequest{
		ApiService: a,
		ctx: ctx,
		cloudType: cloudType,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetTunnelNamesExecute(r ApiGetTunnelNamesRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetTunnelNames")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/tunnels/{cloudType}"
	localVarPath = strings.Replace(localVarPath, "{"+"cloudType"+"}", url.PathEscape(parameterToString(r.cloudType, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.cloudGatewayName != nil {
		localVarQueryParams.Add("cloudGatewayName", parameterToString(*r.cloudGatewayName, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetVHubsRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	cloudType *string
	accountId *string
	resourceGroup *string
	vWanName *string
	vNetTags *string
}

// Cloud Type
func (r ApiGetVHubsRequest) CloudType(cloudType string) ApiGetVHubsRequest {
	r.cloudType = &cloudType
	return r
}

// Account Id
func (r ApiGetVHubsRequest) AccountId(accountId string) ApiGetVHubsRequest {
	r.accountId = &accountId
	return r
}

// Resource Group
func (r ApiGetVHubsRequest) ResourceGroup(resourceGroup string) ApiGetVHubsRequest {
	r.resourceGroup = &resourceGroup
	return r
}

// VWan Name
func (r ApiGetVHubsRequest) VWanName(vWanName string) ApiGetVHubsRequest {
	r.vWanName = &vWanName
	return r
}

// VNet Tags
func (r ApiGetVHubsRequest) VNetTags(vNetTags string) ApiGetVHubsRequest {
	r.vNetTags = &vNetTags
	return r
}

func (r ApiGetVHubsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetVHubsExecute(r)
}

/*
GetVHubs Method for GetVHubs

Get Virtual Hubs

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetVHubsRequest
*/
func (a *ConfigurationMultiCloudApiService) GetVHubs(ctx context.Context) ApiGetVHubsRequest {
	return ApiGetVHubsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetVHubsExecute(r ApiGetVHubsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetVHubs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/vhubs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.cloudType != nil {
		localVarQueryParams.Add("cloudType", parameterToString(*r.cloudType, ""))
	}
	if r.accountId != nil {
		localVarQueryParams.Add("accountId", parameterToString(*r.accountId, ""))
	}
	if r.resourceGroup != nil {
		localVarQueryParams.Add("resourceGroup", parameterToString(*r.resourceGroup, ""))
	}
	if r.vWanName != nil {
		localVarQueryParams.Add("vWanName", parameterToString(*r.vWanName, ""))
	}
	if r.vNetTags != nil {
		localVarQueryParams.Add("vNetTags", parameterToString(*r.vNetTags, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetVWansRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	accountId *string
	cloudType *string
	resourceGroup *string
	refresh *string
}

// Account Id
func (r ApiGetVWansRequest) AccountId(accountId string) ApiGetVWansRequest {
	r.accountId = &accountId
	return r
}

// Cloud Type
func (r ApiGetVWansRequest) CloudType(cloudType string) ApiGetVWansRequest {
	r.cloudType = &cloudType
	return r
}

// Resource Group
func (r ApiGetVWansRequest) ResourceGroup(resourceGroup string) ApiGetVWansRequest {
	r.resourceGroup = &resourceGroup
	return r
}

// Refresh
func (r ApiGetVWansRequest) Refresh(refresh string) ApiGetVWansRequest {
	r.refresh = &refresh
	return r
}

func (r ApiGetVWansRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetVWansExecute(r)
}

/*
GetVWans Method for GetVWans

Get Virtual Wans

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetVWansRequest
*/
func (a *ConfigurationMultiCloudApiService) GetVWans(ctx context.Context) ApiGetVWansRequest {
	return ApiGetVWansRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetVWansExecute(r ApiGetVWansRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetVWans")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/vwans"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.accountId != nil {
		localVarQueryParams.Add("accountId", parameterToString(*r.accountId, ""))
	}
	if r.cloudType != nil {
		localVarQueryParams.Add("cloudType", parameterToString(*r.cloudType, ""))
	}
	if r.resourceGroup != nil {
		localVarQueryParams.Add("resourceGroup", parameterToString(*r.resourceGroup, ""))
	}
	if r.refresh != nil {
		localVarQueryParams.Add("refresh", parameterToString(*r.refresh, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetVpcTagsRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	cloudType *string
	region *string
	tagName *string
}

// Cloud type
func (r ApiGetVpcTagsRequest) CloudType(cloudType string) ApiGetVpcTagsRequest {
	r.cloudType = &cloudType
	return r
}

// Region
func (r ApiGetVpcTagsRequest) Region(region string) ApiGetVpcTagsRequest {
	r.region = &region
	return r
}

// Tag name
func (r ApiGetVpcTagsRequest) TagName(tagName string) ApiGetVpcTagsRequest {
	r.tagName = &tagName
	return r
}

func (r ApiGetVpcTagsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetVpcTagsExecute(r)
}

/*
GetVpcTags Method for GetVpcTags

Get vpc tags

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetVpcTagsRequest
*/
func (a *ConfigurationMultiCloudApiService) GetVpcTags(ctx context.Context) ApiGetVpcTagsRequest {
	return ApiGetVpcTagsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetVpcTagsExecute(r ApiGetVpcTagsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetVpcTags")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/hostvpc/tags"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.cloudType == nil {
		return localVarReturnValue, nil, reportError("cloudType is required and must be specified")
	}

	localVarQueryParams.Add("cloudType", parameterToString(*r.cloudType, ""))
	if r.region != nil {
		localVarQueryParams.Add("region", parameterToString(*r.region, ""))
	}
	if r.tagName != nil {
		localVarQueryParams.Add("tagName", parameterToString(*r.tagName, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetWanDevicesRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
}

func (r ApiGetWanDevicesRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetWanDevicesExecute(r)
}

/*
GetWanDevices Method for GetWanDevices

Get available WAN edge devices

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetWanDevicesRequest
*/
func (a *ConfigurationMultiCloudApiService) GetWanDevices(ctx context.Context) ApiGetWanDevicesRequest {
	return ApiGetWanDevicesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetWanDevicesExecute(r ApiGetWanDevicesRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetWanDevices")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/device"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetWanInterfaceColorsRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
}

func (r ApiGetWanInterfaceColorsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetWanInterfaceColorsExecute(r)
}

/*
GetWanInterfaceColors Method for GetWanInterfaceColors

Get WAN interface colors

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetWanInterfaceColorsRequest
*/
func (a *ConfigurationMultiCloudApiService) GetWanInterfaceColors(ctx context.Context) ApiGetWanInterfaceColorsRequest {
	return ApiGetWanInterfaceColorsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) GetWanInterfaceColorsExecute(r ApiGetWanInterfaceColorsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.GetWanInterfaceColors")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/interfacecolor"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiHostvpcTaggingRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	body *map[string]interface{}
}

// VPC tag
func (r ApiHostvpcTaggingRequest) Body(body map[string]interface{}) ApiHostvpcTaggingRequest {
	r.body = &body
	return r
}

func (r ApiHostvpcTaggingRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.HostvpcTaggingExecute(r)
}

/*
HostvpcTagging Method for HostvpcTagging

Tag a VPC

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiHostvpcTaggingRequest
*/
func (a *ConfigurationMultiCloudApiService) HostvpcTagging(ctx context.Context) ApiHostvpcTaggingRequest {
	return ApiHostvpcTaggingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) HostvpcTaggingExecute(r ApiHostvpcTaggingRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.HostvpcTagging")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/hostvpc/tags"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProcessMappingRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	body *map[string]interface{}
}

// VPC mapping
func (r ApiProcessMappingRequest) Body(body map[string]interface{}) ApiProcessMappingRequest {
	r.body = &body
	return r
}

func (r ApiProcessMappingRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ProcessMappingExecute(r)
}

/*
ProcessMapping Method for ProcessMapping

Process intent of connecting VPNs with VPCs through cloud gateway

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiProcessMappingRequest
*/
func (a *ConfigurationMultiCloudApiService) ProcessMapping(ctx context.Context) ApiProcessMappingRequest {
	return ApiProcessMappingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) ProcessMappingExecute(r ApiProcessMappingRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.ProcessMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/map"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTelemetryRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	body *map[string]interface{}
}

// telemetry
func (r ApiTelemetryRequest) Body(body map[string]interface{}) ApiTelemetryRequest {
	r.body = &body
	return r
}

func (r ApiTelemetryRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.TelemetryExecute(r)
}

/*
Telemetry Method for Telemetry

reports telemetry data

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTelemetryRequest
*/
func (a *ConfigurationMultiCloudApiService) Telemetry(ctx context.Context) ApiTelemetryRequest {
	return ApiTelemetryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) TelemetryExecute(r ApiTelemetryRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.Telemetry")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/telemetry"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTunnelScalingRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	cloudGatewayName string
	body *map[string]interface{}
}

// Site information
func (r ApiTunnelScalingRequest) Body(body map[string]interface{}) ApiTunnelScalingRequest {
	r.body = &body
	return r
}

func (r ApiTunnelScalingRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.TunnelScalingExecute(r)
}

/*
TunnelScaling Method for TunnelScaling

Update tunnel scaling and accelerated vpn parameter for a branch endpoint

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cloudGatewayName Cloud gateway name
 @return ApiTunnelScalingRequest
*/
func (a *ConfigurationMultiCloudApiService) TunnelScaling(ctx context.Context, cloudGatewayName string) ApiTunnelScalingRequest {
	return ApiTunnelScalingRequest{
		ApiService: a,
		ctx: ctx,
		cloudGatewayName: cloudGatewayName,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) TunnelScalingExecute(r ApiTunnelScalingRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.TunnelScaling")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/cloudgateway/{cloudGatewayName}/site"
	localVarPath = strings.Replace(localVarPath, "{"+"cloudGatewayName"+"}", url.PathEscape(parameterToString(r.cloudGatewayName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUnTagRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	tagName string
}

func (r ApiUnTagRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.UnTagExecute(r)
}

/*
UnTag Method for UnTag

Delete a tag

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tagName Tag name
 @return ApiUnTagRequest
*/
func (a *ConfigurationMultiCloudApiService) UnTag(ctx context.Context, tagName string) ApiUnTagRequest {
	return ApiUnTagRequest{
		ApiService: a,
		ctx: ctx,
		tagName: tagName,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) UnTagExecute(r ApiUnTagRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.UnTag")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/hostvpc/tags/{tagName}"
	localVarPath = strings.Replace(localVarPath, "{"+"tagName"+"}", url.PathEscape(parameterToString(r.tagName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateAccountRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	accountId string
	body *map[string]interface{}
}

// Multicloud account info
func (r ApiUpdateAccountRequest) Body(body map[string]interface{}) ApiUpdateAccountRequest {
	r.body = &body
	return r
}

func (r ApiUpdateAccountRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateAccountExecute(r)
}

/*
UpdateAccount Method for UpdateAccount

Update multicloud account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId Account Id
 @return ApiUpdateAccountRequest
*/
func (a *ConfigurationMultiCloudApiService) UpdateAccount(ctx context.Context, accountId string) ApiUpdateAccountRequest {
	return ApiUpdateAccountRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
	}
}

// Execute executes the request
func (a *ConfigurationMultiCloudApiService) UpdateAccountExecute(r ApiUpdateAccountRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.UpdateAccount")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/accounts/{accountId}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterToString(r.accountId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateCgwRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	cloudGatewayName string
	body *map[string]interface{}
}

// Cloud gateway
func (r ApiUpdateCgwRequest) Body(body map[string]interface{}) ApiUpdateCgwRequest {
	r.body = &body
	return r
}

func (r ApiUpdateCgwRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.UpdateCgwExecute(r)
}

/*
UpdateCgw Method for UpdateCgw

Update cloud gateway

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cloudGatewayName
 @return ApiUpdateCgwRequest
*/
func (a *ConfigurationMultiCloudApiService) UpdateCgw(ctx context.Context, cloudGatewayName string) ApiUpdateCgwRequest {
	return ApiUpdateCgwRequest{
		ApiService: a,
		ctx: ctx,
		cloudGatewayName: cloudGatewayName,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) UpdateCgwExecute(r ApiUpdateCgwRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.UpdateCgw")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/cloudgateway/{cloudGatewayName}"
	localVarPath = strings.Replace(localVarPath, "{"+"cloudGatewayName"+"}", url.PathEscape(parameterToString(r.cloudGatewayName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateDeviceLinkRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	body *map[string]interface{}
}

// Device Link
func (r ApiUpdateDeviceLinkRequest) Body(body map[string]interface{}) ApiUpdateDeviceLinkRequest {
	r.body = &body
	return r
}

func (r ApiUpdateDeviceLinkRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.UpdateDeviceLinkExecute(r)
}

/*
UpdateDeviceLink Method for UpdateDeviceLink

Update Device Link

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateDeviceLinkRequest
*/
func (a *ConfigurationMultiCloudApiService) UpdateDeviceLink(ctx context.Context) ApiUpdateDeviceLinkRequest {
	return ApiUpdateDeviceLinkRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) UpdateDeviceLinkExecute(r ApiUpdateDeviceLinkRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.UpdateDeviceLink")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/devicelink/edge"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateEdgeAccountRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	accountId string
	body *map[string]interface{}
}

// Multicloud edge account info
func (r ApiUpdateEdgeAccountRequest) Body(body map[string]interface{}) ApiUpdateEdgeAccountRequest {
	r.body = &body
	return r
}

func (r ApiUpdateEdgeAccountRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateEdgeAccountExecute(r)
}

/*
UpdateEdgeAccount Method for UpdateEdgeAccount

Update Multicloud edge account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId Multicloud Edge Account Id
 @return ApiUpdateEdgeAccountRequest
*/
func (a *ConfigurationMultiCloudApiService) UpdateEdgeAccount(ctx context.Context, accountId string) ApiUpdateEdgeAccountRequest {
	return ApiUpdateEdgeAccountRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
	}
}

// Execute executes the request
func (a *ConfigurationMultiCloudApiService) UpdateEdgeAccountExecute(r ApiUpdateEdgeAccountRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.UpdateEdgeAccount")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/accounts/edge/{accountId}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterToString(r.accountId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateEdgeConnectivityRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	body *map[string]interface{}
}

// Edge connectivity
func (r ApiUpdateEdgeConnectivityRequest) Body(body map[string]interface{}) ApiUpdateEdgeConnectivityRequest {
	r.body = &body
	return r
}

func (r ApiUpdateEdgeConnectivityRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.UpdateEdgeConnectivityExecute(r)
}

/*
UpdateEdgeConnectivity Method for UpdateEdgeConnectivity

Update Interconnect connectivity

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateEdgeConnectivityRequest
*/
func (a *ConfigurationMultiCloudApiService) UpdateEdgeConnectivity(ctx context.Context) ApiUpdateEdgeConnectivityRequest {
	return ApiUpdateEdgeConnectivityRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) UpdateEdgeConnectivityExecute(r ApiUpdateEdgeConnectivityRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.UpdateEdgeConnectivity")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/connectivity/edge"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateEdgeGlobalSettingsRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	body *map[string]interface{}
}

// Global setting
func (r ApiUpdateEdgeGlobalSettingsRequest) Body(body map[string]interface{}) ApiUpdateEdgeGlobalSettingsRequest {
	r.body = &body
	return r
}

func (r ApiUpdateEdgeGlobalSettingsRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateEdgeGlobalSettingsExecute(r)
}

/*
UpdateEdgeGlobalSettings Method for UpdateEdgeGlobalSettings

Update edge global settings for Edge provider

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateEdgeGlobalSettingsRequest
*/
func (a *ConfigurationMultiCloudApiService) UpdateEdgeGlobalSettings(ctx context.Context) ApiUpdateEdgeGlobalSettingsRequest {
	return ApiUpdateEdgeGlobalSettingsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ConfigurationMultiCloudApiService) UpdateEdgeGlobalSettingsExecute(r ApiUpdateEdgeGlobalSettingsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.UpdateEdgeGlobalSettings")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/settings/edge/global"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateEdgeLocationsInfoRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	edgeType string
	accountId string
}

func (r ApiUpdateEdgeLocationsInfoRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.UpdateEdgeLocationsInfoExecute(r)
}

/*
UpdateEdgeLocationsInfo Method for UpdateEdgeLocationsInfo

Update Edge Locations

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param edgeType Edge Type
 @param accountId Edge Account Id
 @return ApiUpdateEdgeLocationsInfoRequest
*/
func (a *ConfigurationMultiCloudApiService) UpdateEdgeLocationsInfo(ctx context.Context, edgeType string, accountId string) ApiUpdateEdgeLocationsInfoRequest {
	return ApiUpdateEdgeLocationsInfoRequest{
		ApiService: a,
		ctx: ctx,
		edgeType: edgeType,
		accountId: accountId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) UpdateEdgeLocationsInfoExecute(r ApiUpdateEdgeLocationsInfoRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.UpdateEdgeLocationsInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/locations/edge/{edgeType}/accountId/{accountId}"
	localVarPath = strings.Replace(localVarPath, "{"+"edgeType"+"}", url.PathEscape(parameterToString(r.edgeType, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterToString(r.accountId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateGlobalSettingsRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	body *map[string]interface{}
}

// Global setting
func (r ApiUpdateGlobalSettingsRequest) Body(body map[string]interface{}) ApiUpdateGlobalSettingsRequest {
	r.body = &body
	return r
}

func (r ApiUpdateGlobalSettingsRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateGlobalSettingsExecute(r)
}

/*
UpdateGlobalSettings Method for UpdateGlobalSettings

Update ip in resource pool

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateGlobalSettingsRequest
*/
func (a *ConfigurationMultiCloudApiService) UpdateGlobalSettings(ctx context.Context) ApiUpdateGlobalSettingsRequest {
	return ApiUpdateGlobalSettingsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ConfigurationMultiCloudApiService) UpdateGlobalSettingsExecute(r ApiUpdateGlobalSettingsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.UpdateGlobalSettings")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/settings/global"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateIcgwRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	edgeGatewayName string
	requestBody *map[string]GetO365PreferredPathFromVAnalyticsRequestValue
}

func (r ApiUpdateIcgwRequest) RequestBody(requestBody map[string]GetO365PreferredPathFromVAnalyticsRequestValue) ApiUpdateIcgwRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiUpdateIcgwRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.UpdateIcgwExecute(r)
}

/*
UpdateIcgw Method for UpdateIcgw

Update Interconnect Gateway

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param edgeGatewayName Edge gateway name
 @return ApiUpdateIcgwRequest
*/
func (a *ConfigurationMultiCloudApiService) UpdateIcgw(ctx context.Context, edgeGatewayName string) ApiUpdateIcgwRequest {
	return ApiUpdateIcgwRequest{
		ApiService: a,
		ctx: ctx,
		edgeGatewayName: edgeGatewayName,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) UpdateIcgwExecute(r ApiUpdateIcgwRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.UpdateIcgw")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/gateway/edge/{edgeGatewayName}"
	localVarPath = strings.Replace(localVarPath, "{"+"edgeGatewayName"+"}", url.PathEscape(parameterToString(r.edgeGatewayName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateNvaSecurityRulesRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	cloudGatewayName string
	body *map[string]interface{}
}

// Update NVA security Rules
func (r ApiUpdateNvaSecurityRulesRequest) Body(body map[string]interface{}) ApiUpdateNvaSecurityRulesRequest {
	r.body = &body
	return r
}

func (r ApiUpdateNvaSecurityRulesRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.UpdateNvaSecurityRulesExecute(r)
}

/*
UpdateNvaSecurityRules Method for UpdateNvaSecurityRules

Update NVA Security Rules

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cloudGatewayName Cloud gateway name
 @return ApiUpdateNvaSecurityRulesRequest
*/
func (a *ConfigurationMultiCloudApiService) UpdateNvaSecurityRules(ctx context.Context, cloudGatewayName string) ApiUpdateNvaSecurityRulesRequest {
	return ApiUpdateNvaSecurityRulesRequest{
		ApiService: a,
		ctx: ctx,
		cloudGatewayName: cloudGatewayName,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationMultiCloudApiService) UpdateNvaSecurityRulesExecute(r ApiUpdateNvaSecurityRulesRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.UpdateNvaSecurityRules")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/cloudgateway/nvaSecurityRules/{cloudGatewayName}"
	localVarPath = strings.Replace(localVarPath, "{"+"cloudGatewayName"+"}", url.PathEscape(parameterToString(r.cloudGatewayName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidateAccountAddRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	body *map[string]interface{}
}

// Multicloud account info
func (r ApiValidateAccountAddRequest) Body(body map[string]interface{}) ApiValidateAccountAddRequest {
	r.body = &body
	return r
}

func (r ApiValidateAccountAddRequest) Execute() (*http.Response, error) {
	return r.ApiService.ValidateAccountAddExecute(r)
}

/*
ValidateAccountAdd Method for ValidateAccountAdd

Authenticate cloud account credentials

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiValidateAccountAddRequest
*/
func (a *ConfigurationMultiCloudApiService) ValidateAccountAdd(ctx context.Context) ApiValidateAccountAddRequest {
	return ApiValidateAccountAddRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ConfigurationMultiCloudApiService) ValidateAccountAddExecute(r ApiValidateAccountAddRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.ValidateAccountAdd")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/accounts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiValidateAccountUpdateCredentialsRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	accountId string
	body *map[string]interface{}
}

// Multicloud account info
func (r ApiValidateAccountUpdateCredentialsRequest) Body(body map[string]interface{}) ApiValidateAccountUpdateCredentialsRequest {
	r.body = &body
	return r
}

func (r ApiValidateAccountUpdateCredentialsRequest) Execute() (*http.Response, error) {
	return r.ApiService.ValidateAccountUpdateCredentialsExecute(r)
}

/*
ValidateAccountUpdateCredentials Method for ValidateAccountUpdateCredentials

Update multicloud account credential

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId Account Id
 @return ApiValidateAccountUpdateCredentialsRequest
*/
func (a *ConfigurationMultiCloudApiService) ValidateAccountUpdateCredentials(ctx context.Context, accountId string) ApiValidateAccountUpdateCredentialsRequest {
	return ApiValidateAccountUpdateCredentialsRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
	}
}

// Execute executes the request
func (a *ConfigurationMultiCloudApiService) ValidateAccountUpdateCredentialsExecute(r ApiValidateAccountUpdateCredentialsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.ValidateAccountUpdateCredentials")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/accounts/{accountId}/credentials"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterToString(r.accountId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiValidateEdgeAccountAddRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	body *map[string]interface{}
}

// Multicloud edge account info
func (r ApiValidateEdgeAccountAddRequest) Body(body map[string]interface{}) ApiValidateEdgeAccountAddRequest {
	r.body = &body
	return r
}

func (r ApiValidateEdgeAccountAddRequest) Execute() (*http.Response, error) {
	return r.ApiService.ValidateEdgeAccountAddExecute(r)
}

/*
ValidateEdgeAccountAdd Method for ValidateEdgeAccountAdd

Authenticate edge account credentials

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiValidateEdgeAccountAddRequest
*/
func (a *ConfigurationMultiCloudApiService) ValidateEdgeAccountAdd(ctx context.Context) ApiValidateEdgeAccountAddRequest {
	return ApiValidateEdgeAccountAddRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ConfigurationMultiCloudApiService) ValidateEdgeAccountAddExecute(r ApiValidateEdgeAccountAddRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.ValidateEdgeAccountAdd")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/accounts/edge"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiValidateEdgeAccountUpdateCredentialsRequest struct {
	ctx context.Context
	ApiService *ConfigurationMultiCloudApiService
	accountId string
	body *map[string]interface{}
}

// Multicloud edge account info
func (r ApiValidateEdgeAccountUpdateCredentialsRequest) Body(body map[string]interface{}) ApiValidateEdgeAccountUpdateCredentialsRequest {
	r.body = &body
	return r
}

func (r ApiValidateEdgeAccountUpdateCredentialsRequest) Execute() (*http.Response, error) {
	return r.ApiService.ValidateEdgeAccountUpdateCredentialsExecute(r)
}

/*
ValidateEdgeAccountUpdateCredentials Method for ValidateEdgeAccountUpdateCredentials

Update Multicloud edge account credential

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId Multicloud Edge Account Id
 @return ApiValidateEdgeAccountUpdateCredentialsRequest
*/
func (a *ConfigurationMultiCloudApiService) ValidateEdgeAccountUpdateCredentials(ctx context.Context, accountId string) ApiValidateEdgeAccountUpdateCredentialsRequest {
	return ApiValidateEdgeAccountUpdateCredentialsRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
	}
}

// Execute executes the request
func (a *ConfigurationMultiCloudApiService) ValidateEdgeAccountUpdateCredentialsExecute(r ApiValidateEdgeAccountUpdateCredentialsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationMultiCloudApiService.ValidateEdgeAccountUpdateCredentials")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/multicloud/accounts/edge/{accountId}/credentials"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterToString(r.accountId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
