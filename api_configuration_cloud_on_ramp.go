/*
Cisco SD-WAN vManage API

The vManage API exposes the functionality of operations maintaining devices and the overlay network

API version: 2.0.0
Contact: vmanage@cisco.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// ConfigurationCloudOnRampApiService ConfigurationCloudOnRampApi service
type ConfigurationCloudOnRampApiService service

type ConfigurationCloudOnRampApiAcquireResourcePoolRequest struct {
	ctx context.Context
	ApiService *ConfigurationCloudOnRampApiService
	body *map[string]interface{}
}

// Add IP from resource pool request
func (r ConfigurationCloudOnRampApiAcquireResourcePoolRequest) Body(body map[string]interface{}) ConfigurationCloudOnRampApiAcquireResourcePoolRequest {
	r.body = &body
	return r
}

func (r ConfigurationCloudOnRampApiAcquireResourcePoolRequest) Execute() (*http.Response, error) {
	return r.ApiService.AcquireResourcePoolExecute(r)
}

/*
AcquireResourcePool Method for AcquireResourcePool

Acquire IP from resource pool

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationCloudOnRampApiAcquireResourcePoolRequest
*/
func (a *ConfigurationCloudOnRampApiService) AcquireResourcePool(ctx context.Context) ConfigurationCloudOnRampApiAcquireResourcePoolRequest {
	return ConfigurationCloudOnRampApiAcquireResourcePoolRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ConfigurationCloudOnRampApiService) AcquireResourcePoolExecute(r ConfigurationCloudOnRampApiAcquireResourcePoolRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationCloudOnRampApiService.AcquireResourcePool")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/template/cor/acquireResourcePool"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ConfigurationCloudOnRampApiAddDevicePairRequest struct {
	ctx context.Context
	ApiService *ConfigurationCloudOnRampApiService
	body *map[string]interface{}
}

// Add device pair request
func (r ConfigurationCloudOnRampApiAddDevicePairRequest) Body(body map[string]interface{}) ConfigurationCloudOnRampApiAddDevicePairRequest {
	r.body = &body
	return r
}

func (r ConfigurationCloudOnRampApiAddDevicePairRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.AddDevicePairExecute(r)
}

/*
AddDevicePair Method for AddDevicePair

Add device pair

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationCloudOnRampApiAddDevicePairRequest
*/
func (a *ConfigurationCloudOnRampApiService) AddDevicePair(ctx context.Context) ConfigurationCloudOnRampApiAddDevicePairRequest {
	return ConfigurationCloudOnRampApiAddDevicePairRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationCloudOnRampApiService) AddDevicePairExecute(r ConfigurationCloudOnRampApiAddDevicePairRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationCloudOnRampApiService.AddDevicePair")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/template/cor/devicepair"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationCloudOnRampApiAddTransitVPCRequest struct {
	ctx context.Context
	ApiService *ConfigurationCloudOnRampApiService
	body *map[string]interface{}
}

// VPC
func (r ConfigurationCloudOnRampApiAddTransitVPCRequest) Body(body map[string]interface{}) ConfigurationCloudOnRampApiAddTransitVPCRequest {
	r.body = &body
	return r
}

func (r ConfigurationCloudOnRampApiAddTransitVPCRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.AddTransitVPCExecute(r)
}

/*
AddTransitVPC Method for AddTransitVPC

Create transit VPC/VNet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationCloudOnRampApiAddTransitVPCRequest
*/
func (a *ConfigurationCloudOnRampApiService) AddTransitVPC(ctx context.Context) ConfigurationCloudOnRampApiAddTransitVPCRequest {
	return ConfigurationCloudOnRampApiAddTransitVPCRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationCloudOnRampApiService) AddTransitVPCExecute(r ConfigurationCloudOnRampApiAddTransitVPCRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationCloudOnRampApiService.AddTransitVPC")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/template/cor/transitvpc"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationCloudOnRampApiAuthenticateCloudOnRampCredAndAddRequest struct {
	ctx context.Context
	ApiService *ConfigurationCloudOnRampApiService
	body *map[string]interface{}
}

// Cloud account credential
func (r ConfigurationCloudOnRampApiAuthenticateCloudOnRampCredAndAddRequest) Body(body map[string]interface{}) ConfigurationCloudOnRampApiAuthenticateCloudOnRampCredAndAddRequest {
	r.body = &body
	return r
}

func (r ConfigurationCloudOnRampApiAuthenticateCloudOnRampCredAndAddRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.AuthenticateCloudOnRampCredAndAddExecute(r)
}

/*
AuthenticateCloudOnRampCredAndAdd Method for AuthenticateCloudOnRampCredAndAdd

Authenticate cloud account credentials

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationCloudOnRampApiAuthenticateCloudOnRampCredAndAddRequest
*/
func (a *ConfigurationCloudOnRampApiService) AuthenticateCloudOnRampCredAndAdd(ctx context.Context) ConfigurationCloudOnRampApiAuthenticateCloudOnRampCredAndAddRequest {
	return ConfigurationCloudOnRampApiAuthenticateCloudOnRampCredAndAddRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationCloudOnRampApiService) AuthenticateCloudOnRampCredAndAddExecute(r ConfigurationCloudOnRampApiAuthenticateCloudOnRampCredAndAddRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationCloudOnRampApiService.AuthenticateCloudOnRampCredAndAdd")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/template/cor/cloud/authenticate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationCloudOnRampApiAuthenticateCredAndUpdateRequest struct {
	ctx context.Context
	ApiService *ConfigurationCloudOnRampApiService
	body *map[string]interface{}
}

// Cloud account credential
func (r ConfigurationCloudOnRampApiAuthenticateCredAndUpdateRequest) Body(body map[string]interface{}) ConfigurationCloudOnRampApiAuthenticateCredAndUpdateRequest {
	r.body = &body
	return r
}

func (r ConfigurationCloudOnRampApiAuthenticateCredAndUpdateRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.AuthenticateCredAndUpdateExecute(r)
}

/*
AuthenticateCredAndUpdate Method for AuthenticateCredAndUpdate

Authenticate and update cloud account credentials

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationCloudOnRampApiAuthenticateCredAndUpdateRequest
*/
func (a *ConfigurationCloudOnRampApiService) AuthenticateCredAndUpdate(ctx context.Context) ConfigurationCloudOnRampApiAuthenticateCredAndUpdateRequest {
	return ConfigurationCloudOnRampApiAuthenticateCredAndUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationCloudOnRampApiService) AuthenticateCredAndUpdateExecute(r ConfigurationCloudOnRampApiAuthenticateCredAndUpdateRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationCloudOnRampApiService.AuthenticateCredAndUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/template/cor/cloud/authenticate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationCloudOnRampApiCreateAndMapRequest struct {
	ctx context.Context
	ApiService *ConfigurationCloudOnRampApiService
	body *map[string]interface{}
}

// Map host to transit VPC request
func (r ConfigurationCloudOnRampApiCreateAndMapRequest) Body(body map[string]interface{}) ConfigurationCloudOnRampApiCreateAndMapRequest {
	r.body = &body
	return r
}

func (r ConfigurationCloudOnRampApiCreateAndMapRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.CreateAndMapExecute(r)
}

/*
CreateAndMap Method for CreateAndMap

Map Host to Transit VPC/VNet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationCloudOnRampApiCreateAndMapRequest
*/
func (a *ConfigurationCloudOnRampApiService) CreateAndMap(ctx context.Context) ConfigurationCloudOnRampApiCreateAndMapRequest {
	return ConfigurationCloudOnRampApiCreateAndMapRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationCloudOnRampApiService) CreateAndMapExecute(r ConfigurationCloudOnRampApiCreateAndMapRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationCloudOnRampApiService.CreateAndMap")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/template/cor"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationCloudOnRampApiCreateResourcePoolRequest struct {
	ctx context.Context
	ApiService *ConfigurationCloudOnRampApiService
	body *map[string]interface{}
}

// Add resource pool request
func (r ConfigurationCloudOnRampApiCreateResourcePoolRequest) Body(body map[string]interface{}) ConfigurationCloudOnRampApiCreateResourcePoolRequest {
	r.body = &body
	return r
}

func (r ConfigurationCloudOnRampApiCreateResourcePoolRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateResourcePoolExecute(r)
}

/*
CreateResourcePool Method for CreateResourcePool

Add resource pool

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationCloudOnRampApiCreateResourcePoolRequest
*/
func (a *ConfigurationCloudOnRampApiService) CreateResourcePool(ctx context.Context) ConfigurationCloudOnRampApiCreateResourcePoolRequest {
	return ConfigurationCloudOnRampApiCreateResourcePoolRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ConfigurationCloudOnRampApiService) CreateResourcePoolExecute(r ConfigurationCloudOnRampApiCreateResourcePoolRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationCloudOnRampApiService.CreateResourcePool")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/template/cor/createResourcePool"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ConfigurationCloudOnRampApiGetAmiListRequest struct {
	ctx context.Context
	ApiService *ConfigurationCloudOnRampApiService
	accountid *string
	cloudregion *string
	cloudtype *string
}

// Account Id
func (r ConfigurationCloudOnRampApiGetAmiListRequest) Accountid(accountid string) ConfigurationCloudOnRampApiGetAmiListRequest {
	r.accountid = &accountid
	return r
}

// Cloud region
func (r ConfigurationCloudOnRampApiGetAmiListRequest) Cloudregion(cloudregion string) ConfigurationCloudOnRampApiGetAmiListRequest {
	r.cloudregion = &cloudregion
	return r
}

// Cloud type
func (r ConfigurationCloudOnRampApiGetAmiListRequest) Cloudtype(cloudtype string) ConfigurationCloudOnRampApiGetAmiListRequest {
	r.cloudtype = &cloudtype
	return r
}

func (r ConfigurationCloudOnRampApiGetAmiListRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetAmiListExecute(r)
}

/*
GetAmiList Method for GetAmiList

Get AMI list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationCloudOnRampApiGetAmiListRequest
*/
func (a *ConfigurationCloudOnRampApiService) GetAmiList(ctx context.Context) ConfigurationCloudOnRampApiGetAmiListRequest {
	return ConfigurationCloudOnRampApiGetAmiListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *ConfigurationCloudOnRampApiService) GetAmiListExecute(r ConfigurationCloudOnRampApiGetAmiListRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationCloudOnRampApiService.GetAmiList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/template/cor/ami"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountid == nil {
		return localVarReturnValue, nil, reportError("accountid is required and must be specified")
	}
	if r.cloudregion == nil {
		return localVarReturnValue, nil, reportError("cloudregion is required and must be specified")
	}

	localVarQueryParams.Add("accountid", parameterToString(*r.accountid, ""))
	localVarQueryParams.Add("cloudregion", parameterToString(*r.cloudregion, ""))
	if r.cloudtype != nil {
		localVarQueryParams.Add("cloudtype", parameterToString(*r.cloudtype, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationCloudOnRampApiGetCORStatusRequest struct {
	ctx context.Context
	ApiService *ConfigurationCloudOnRampApiService
}

func (r ConfigurationCloudOnRampApiGetCORStatusRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetCORStatusExecute(r)
}

/*
GetCORStatus Method for GetCORStatus

Get Cloud On Ramp list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationCloudOnRampApiGetCORStatusRequest
*/
func (a *ConfigurationCloudOnRampApiService) GetCORStatus(ctx context.Context) ConfigurationCloudOnRampApiGetCORStatusRequest {
	return ConfigurationCloudOnRampApiGetCORStatusRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *ConfigurationCloudOnRampApiService) GetCORStatusExecute(r ConfigurationCloudOnRampApiGetCORStatusRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationCloudOnRampApiService.GetCORStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/template/cor"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationCloudOnRampApiGetCloudAccountsRequest struct {
	ctx context.Context
	ApiService *ConfigurationCloudOnRampApiService
	cloudtype *string
	cloudEnvironment *string
}

// Cloud type
func (r ConfigurationCloudOnRampApiGetCloudAccountsRequest) Cloudtype(cloudtype string) ConfigurationCloudOnRampApiGetCloudAccountsRequest {
	r.cloudtype = &cloudtype
	return r
}

// Cloud environment
func (r ConfigurationCloudOnRampApiGetCloudAccountsRequest) CloudEnvironment(cloudEnvironment string) ConfigurationCloudOnRampApiGetCloudAccountsRequest {
	r.cloudEnvironment = &cloudEnvironment
	return r
}

func (r ConfigurationCloudOnRampApiGetCloudAccountsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetCloudAccountsExecute(r)
}

/*
GetCloudAccounts Method for GetCloudAccounts

Get cloud accounts

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationCloudOnRampApiGetCloudAccountsRequest
*/
func (a *ConfigurationCloudOnRampApiService) GetCloudAccounts(ctx context.Context) ConfigurationCloudOnRampApiGetCloudAccountsRequest {
	return ConfigurationCloudOnRampApiGetCloudAccountsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationCloudOnRampApiService) GetCloudAccountsExecute(r ConfigurationCloudOnRampApiGetCloudAccountsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationCloudOnRampApiService.GetCloudAccounts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/template/cor/cloud/account"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.cloudtype == nil {
		return localVarReturnValue, nil, reportError("cloudtype is required and must be specified")
	}
	if r.cloudEnvironment == nil {
		return localVarReturnValue, nil, reportError("cloudEnvironment is required and must be specified")
	}

	localVarQueryParams.Add("cloudtype", parameterToString(*r.cloudtype, ""))
	localVarQueryParams.Add("cloudEnvironment", parameterToString(*r.cloudEnvironment, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationCloudOnRampApiGetCloudHostVPCsRequest struct {
	ctx context.Context
	ApiService *ConfigurationCloudOnRampApiService
	accountid *string
	cloudregion *string
	cloudtype *string
}

// Account Id
func (r ConfigurationCloudOnRampApiGetCloudHostVPCsRequest) Accountid(accountid string) ConfigurationCloudOnRampApiGetCloudHostVPCsRequest {
	r.accountid = &accountid
	return r
}

// Cloud region
func (r ConfigurationCloudOnRampApiGetCloudHostVPCsRequest) Cloudregion(cloudregion string) ConfigurationCloudOnRampApiGetCloudHostVPCsRequest {
	r.cloudregion = &cloudregion
	return r
}

// Cloud type
func (r ConfigurationCloudOnRampApiGetCloudHostVPCsRequest) Cloudtype(cloudtype string) ConfigurationCloudOnRampApiGetCloudHostVPCsRequest {
	r.cloudtype = &cloudtype
	return r
}

func (r ConfigurationCloudOnRampApiGetCloudHostVPCsRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetCloudHostVPCsExecute(r)
}

/*
GetCloudHostVPCs Method for GetCloudHostVPCs

Get host VPC/VNet list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationCloudOnRampApiGetCloudHostVPCsRequest
*/
func (a *ConfigurationCloudOnRampApiService) GetCloudHostVPCs(ctx context.Context) ConfigurationCloudOnRampApiGetCloudHostVPCsRequest {
	return ConfigurationCloudOnRampApiGetCloudHostVPCsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *ConfigurationCloudOnRampApiService) GetCloudHostVPCsExecute(r ConfigurationCloudOnRampApiGetCloudHostVPCsRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationCloudOnRampApiService.GetCloudHostVPCs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/template/cor/hostvpc"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountid == nil {
		return localVarReturnValue, nil, reportError("accountid is required and must be specified")
	}
	if r.cloudregion == nil {
		return localVarReturnValue, nil, reportError("cloudregion is required and must be specified")
	}

	localVarQueryParams.Add("accountid", parameterToString(*r.accountid, ""))
	localVarQueryParams.Add("cloudregion", parameterToString(*r.cloudregion, ""))
	if r.cloudtype != nil {
		localVarQueryParams.Add("cloudtype", parameterToString(*r.cloudtype, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationCloudOnRampApiGetCloudHostVpcAccountDetailsRequest struct {
	ctx context.Context
	ApiService *ConfigurationCloudOnRampApiService
}

func (r ConfigurationCloudOnRampApiGetCloudHostVpcAccountDetailsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetCloudHostVpcAccountDetailsExecute(r)
}

/*
GetCloudHostVpcAccountDetails Method for GetCloudHostVpcAccountDetails

Get cloud host VPC account details

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationCloudOnRampApiGetCloudHostVpcAccountDetailsRequest
*/
func (a *ConfigurationCloudOnRampApiService) GetCloudHostVpcAccountDetails(ctx context.Context) ConfigurationCloudOnRampApiGetCloudHostVpcAccountDetailsRequest {
	return ConfigurationCloudOnRampApiGetCloudHostVpcAccountDetailsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationCloudOnRampApiService) GetCloudHostVpcAccountDetailsExecute(r ConfigurationCloudOnRampApiGetCloudHostVpcAccountDetailsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationCloudOnRampApiService.GetCloudHostVpcAccountDetails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/template/cor/cloud/host/accountdetails"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationCloudOnRampApiGetCloudListRequest struct {
	ctx context.Context
	ApiService *ConfigurationCloudOnRampApiService
}

func (r ConfigurationCloudOnRampApiGetCloudListRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetCloudListExecute(r)
}

/*
GetCloudList Method for GetCloudList

Get cloud list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationCloudOnRampApiGetCloudListRequest
*/
func (a *ConfigurationCloudOnRampApiService) GetCloudList(ctx context.Context) ConfigurationCloudOnRampApiGetCloudListRequest {
	return ConfigurationCloudOnRampApiGetCloudListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *ConfigurationCloudOnRampApiService) GetCloudListExecute(r ConfigurationCloudOnRampApiGetCloudListRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationCloudOnRampApiService.GetCloudList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/template/cor/cloud"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationCloudOnRampApiGetCloudMappedHostAccountsRequest struct {
	ctx context.Context
	ApiService *ConfigurationCloudOnRampApiService
	accountid *string
	cloudtype *string
}

// Account Id
func (r ConfigurationCloudOnRampApiGetCloudMappedHostAccountsRequest) Accountid(accountid string) ConfigurationCloudOnRampApiGetCloudMappedHostAccountsRequest {
	r.accountid = &accountid
	return r
}

// Cloud type
func (r ConfigurationCloudOnRampApiGetCloudMappedHostAccountsRequest) Cloudtype(cloudtype string) ConfigurationCloudOnRampApiGetCloudMappedHostAccountsRequest {
	r.cloudtype = &cloudtype
	return r
}

func (r ConfigurationCloudOnRampApiGetCloudMappedHostAccountsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetCloudMappedHostAccountsExecute(r)
}

/*
GetCloudMappedHostAccounts Method for GetCloudMappedHostAccounts

Get cloud mapped accounts view

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationCloudOnRampApiGetCloudMappedHostAccountsRequest
*/
func (a *ConfigurationCloudOnRampApiService) GetCloudMappedHostAccounts(ctx context.Context) ConfigurationCloudOnRampApiGetCloudMappedHostAccountsRequest {
	return ConfigurationCloudOnRampApiGetCloudMappedHostAccountsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationCloudOnRampApiService) GetCloudMappedHostAccountsExecute(r ConfigurationCloudOnRampApiGetCloudMappedHostAccountsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationCloudOnRampApiService.GetCloudMappedHostAccounts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/template/cor/cloud/mappedhostaccounts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountid == nil {
		return localVarReturnValue, nil, reportError("accountid is required and must be specified")
	}
	if r.cloudtype == nil {
		return localVarReturnValue, nil, reportError("cloudtype is required and must be specified")
	}

	localVarQueryParams.Add("accountid", parameterToString(*r.accountid, ""))
	localVarQueryParams.Add("cloudtype", parameterToString(*r.cloudtype, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationCloudOnRampApiGetCloudOnRampDevicesRequest struct {
	ctx context.Context
	ApiService *ConfigurationCloudOnRampApiService
}

func (r ConfigurationCloudOnRampApiGetCloudOnRampDevicesRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetCloudOnRampDevicesExecute(r)
}

/*
GetCloudOnRampDevices Method for GetCloudOnRampDevices

Get available device list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationCloudOnRampApiGetCloudOnRampDevicesRequest
*/
func (a *ConfigurationCloudOnRampApiService) GetCloudOnRampDevices(ctx context.Context) ConfigurationCloudOnRampApiGetCloudOnRampDevicesRequest {
	return ConfigurationCloudOnRampApiGetCloudOnRampDevicesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *ConfigurationCloudOnRampApiService) GetCloudOnRampDevicesExecute(r ConfigurationCloudOnRampApiGetCloudOnRampDevicesRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationCloudOnRampApiService.GetCloudOnRampDevices")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/template/cor/device"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationCloudOnRampApiGetExternalIdRequest struct {
	ctx context.Context
	ApiService *ConfigurationCloudOnRampApiService
}

func (r ConfigurationCloudOnRampApiGetExternalIdRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetExternalIdExecute(r)
}

/*
GetExternalId Method for GetExternalId

Get the vManage external ID for AWS

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationCloudOnRampApiGetExternalIdRequest
*/
func (a *ConfigurationCloudOnRampApiService) GetExternalId(ctx context.Context) ConfigurationCloudOnRampApiGetExternalIdRequest {
	return ConfigurationCloudOnRampApiGetExternalIdRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *ConfigurationCloudOnRampApiService) GetExternalIdExecute(r ConfigurationCloudOnRampApiGetExternalIdRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationCloudOnRampApiService.GetExternalId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/template/cor/externalId"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationCloudOnRampApiGetHostVPCsRequest struct {
	ctx context.Context
	ApiService *ConfigurationCloudOnRampApiService
	transitVpcId *string
	devicePairId *string
}

// Transit VPC Id
func (r ConfigurationCloudOnRampApiGetHostVPCsRequest) TransitVpcId(transitVpcId string) ConfigurationCloudOnRampApiGetHostVPCsRequest {
	r.transitVpcId = &transitVpcId
	return r
}

// Device pair Id
func (r ConfigurationCloudOnRampApiGetHostVPCsRequest) DevicePairId(devicePairId string) ConfigurationCloudOnRampApiGetHostVPCsRequest {
	r.devicePairId = &devicePairId
	return r
}

func (r ConfigurationCloudOnRampApiGetHostVPCsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetHostVPCsExecute(r)
}

/*
GetHostVPCs Method for GetHostVPCs

Get host VPC details

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationCloudOnRampApiGetHostVPCsRequest
*/
func (a *ConfigurationCloudOnRampApiService) GetHostVPCs(ctx context.Context) ConfigurationCloudOnRampApiGetHostVPCsRequest {
	return ConfigurationCloudOnRampApiGetHostVPCsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationCloudOnRampApiService) GetHostVPCsExecute(r ConfigurationCloudOnRampApiGetHostVPCsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationCloudOnRampApiService.GetHostVPCs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/template/cor/devicepair/hostvpc"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.transitVpcId == nil {
		return localVarReturnValue, nil, reportError("transitVpcId is required and must be specified")
	}
	if r.devicePairId == nil {
		return localVarReturnValue, nil, reportError("devicePairId is required and must be specified")
	}

	localVarQueryParams.Add("transitVpcId", parameterToString(*r.transitVpcId, ""))
	localVarQueryParams.Add("devicePairId", parameterToString(*r.devicePairId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationCloudOnRampApiGetMappedVPCsRequest struct {
	ctx context.Context
	ApiService *ConfigurationCloudOnRampApiService
	accountid *string
	cloudregion *string
}

// Account Id
func (r ConfigurationCloudOnRampApiGetMappedVPCsRequest) Accountid(accountid string) ConfigurationCloudOnRampApiGetMappedVPCsRequest {
	r.accountid = &accountid
	return r
}

// Cloud region
func (r ConfigurationCloudOnRampApiGetMappedVPCsRequest) Cloudregion(cloudregion string) ConfigurationCloudOnRampApiGetMappedVPCsRequest {
	r.cloudregion = &cloudregion
	return r
}

func (r ConfigurationCloudOnRampApiGetMappedVPCsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetMappedVPCsExecute(r)
}

/*
GetMappedVPCs Method for GetMappedVPCs

Get mapped VPC/VNet list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationCloudOnRampApiGetMappedVPCsRequest
*/
func (a *ConfigurationCloudOnRampApiService) GetMappedVPCs(ctx context.Context) ConfigurationCloudOnRampApiGetMappedVPCsRequest {
	return ConfigurationCloudOnRampApiGetMappedVPCsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationCloudOnRampApiService) GetMappedVPCsExecute(r ConfigurationCloudOnRampApiGetMappedVPCsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationCloudOnRampApiService.GetMappedVPCs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/template/cor/map"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountid == nil {
		return localVarReturnValue, nil, reportError("accountid is required and must be specified")
	}
	if r.cloudregion == nil {
		return localVarReturnValue, nil, reportError("cloudregion is required and must be specified")
	}

	localVarQueryParams.Add("accountid", parameterToString(*r.accountid, ""))
	localVarQueryParams.Add("cloudregion", parameterToString(*r.cloudregion, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationCloudOnRampApiGetPemKeyListRequest struct {
	ctx context.Context
	ApiService *ConfigurationCloudOnRampApiService
	accountid *string
	cloudregion *string
	cloudtype *string
}

// Account Id
func (r ConfigurationCloudOnRampApiGetPemKeyListRequest) Accountid(accountid string) ConfigurationCloudOnRampApiGetPemKeyListRequest {
	r.accountid = &accountid
	return r
}

// Cloud region
func (r ConfigurationCloudOnRampApiGetPemKeyListRequest) Cloudregion(cloudregion string) ConfigurationCloudOnRampApiGetPemKeyListRequest {
	r.cloudregion = &cloudregion
	return r
}

// Cloud type
func (r ConfigurationCloudOnRampApiGetPemKeyListRequest) Cloudtype(cloudtype string) ConfigurationCloudOnRampApiGetPemKeyListRequest {
	r.cloudtype = &cloudtype
	return r
}

func (r ConfigurationCloudOnRampApiGetPemKeyListRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetPemKeyListExecute(r)
}

/*
GetPemKeyList Method for GetPemKeyList

Get transit VPC PEM key list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationCloudOnRampApiGetPemKeyListRequest
*/
func (a *ConfigurationCloudOnRampApiService) GetPemKeyList(ctx context.Context) ConfigurationCloudOnRampApiGetPemKeyListRequest {
	return ConfigurationCloudOnRampApiGetPemKeyListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *ConfigurationCloudOnRampApiService) GetPemKeyListExecute(r ConfigurationCloudOnRampApiGetPemKeyListRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationCloudOnRampApiService.GetPemKeyList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/template/cor/pem"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountid == nil {
		return localVarReturnValue, nil, reportError("accountid is required and must be specified")
	}
	if r.cloudregion == nil {
		return localVarReturnValue, nil, reportError("cloudregion is required and must be specified")
	}
	if r.cloudtype == nil {
		return localVarReturnValue, nil, reportError("cloudtype is required and must be specified")
	}

	localVarQueryParams.Add("accountid", parameterToString(*r.accountid, ""))
	localVarQueryParams.Add("cloudregion", parameterToString(*r.cloudregion, ""))
	localVarQueryParams.Add("cloudtype", parameterToString(*r.cloudtype, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationCloudOnRampApiGetTenantAndHostVpcListRequest struct {
	ctx context.Context
	ApiService *ConfigurationCloudOnRampApiService
	intent *string
}

// Intent
func (r ConfigurationCloudOnRampApiGetTenantAndHostVpcListRequest) Intent(intent string) ConfigurationCloudOnRampApiGetTenantAndHostVpcListRequest {
	r.intent = &intent
	return r
}

func (r ConfigurationCloudOnRampApiGetTenantAndHostVpcListRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetTenantAndHostVpcListExecute(r)
}

/*
GetTenantAndHostVpcList Method for GetTenantAndHostVpcList

Get tenant and host VPC list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationCloudOnRampApiGetTenantAndHostVpcListRequest
*/
func (a *ConfigurationCloudOnRampApiService) GetTenantAndHostVpcList(ctx context.Context) ConfigurationCloudOnRampApiGetTenantAndHostVpcListRequest {
	return ConfigurationCloudOnRampApiGetTenantAndHostVpcListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *ConfigurationCloudOnRampApiService) GetTenantAndHostVpcListExecute(r ConfigurationCloudOnRampApiGetTenantAndHostVpcListRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationCloudOnRampApiService.GetTenantAndHostVpcList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/template/cor/hostvpclist"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.intent != nil {
		localVarQueryParams.Add("intent", parameterToString(*r.intent, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationCloudOnRampApiGetTransitDevicePairAndHostListRequest struct {
	ctx context.Context
	ApiService *ConfigurationCloudOnRampApiService
	accountId *string
	cloudRegion *string
}

// Account Id
func (r ConfigurationCloudOnRampApiGetTransitDevicePairAndHostListRequest) AccountId(accountId string) ConfigurationCloudOnRampApiGetTransitDevicePairAndHostListRequest {
	r.accountId = &accountId
	return r
}

// Cloud region
func (r ConfigurationCloudOnRampApiGetTransitDevicePairAndHostListRequest) CloudRegion(cloudRegion string) ConfigurationCloudOnRampApiGetTransitDevicePairAndHostListRequest {
	r.cloudRegion = &cloudRegion
	return r
}

func (r ConfigurationCloudOnRampApiGetTransitDevicePairAndHostListRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetTransitDevicePairAndHostListExecute(r)
}

/*
GetTransitDevicePairAndHostList Method for GetTransitDevicePairAndHostList

Get device and host details

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationCloudOnRampApiGetTransitDevicePairAndHostListRequest
*/
func (a *ConfigurationCloudOnRampApiService) GetTransitDevicePairAndHostList(ctx context.Context) ConfigurationCloudOnRampApiGetTransitDevicePairAndHostListRequest {
	return ConfigurationCloudOnRampApiGetTransitDevicePairAndHostListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationCloudOnRampApiService) GetTransitDevicePairAndHostListExecute(r ConfigurationCloudOnRampApiGetTransitDevicePairAndHostListRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationCloudOnRampApiService.GetTransitDevicePairAndHostList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/template/cor/getTransitDevicePairAndHostList"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.cloudRegion == nil {
		return localVarReturnValue, nil, reportError("cloudRegion is required and must be specified")
	}

	localVarQueryParams.Add("accountId", parameterToString(*r.accountId, ""))
	localVarQueryParams.Add("cloudRegion", parameterToString(*r.cloudRegion, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationCloudOnRampApiGetTransitVPCSupportedSizeRequest struct {
	ctx context.Context
	ApiService *ConfigurationCloudOnRampApiService
	cloudEnvironment *string
	cloudtype *string
}

// Cloud environment
func (r ConfigurationCloudOnRampApiGetTransitVPCSupportedSizeRequest) CloudEnvironment(cloudEnvironment string) ConfigurationCloudOnRampApiGetTransitVPCSupportedSizeRequest {
	r.cloudEnvironment = &cloudEnvironment
	return r
}

// Cloud type
func (r ConfigurationCloudOnRampApiGetTransitVPCSupportedSizeRequest) Cloudtype(cloudtype string) ConfigurationCloudOnRampApiGetTransitVPCSupportedSizeRequest {
	r.cloudtype = &cloudtype
	return r
}

func (r ConfigurationCloudOnRampApiGetTransitVPCSupportedSizeRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetTransitVPCSupportedSizeExecute(r)
}

/*
GetTransitVPCSupportedSize Method for GetTransitVPCSupportedSize

Get transit VPC supported size

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationCloudOnRampApiGetTransitVPCSupportedSizeRequest
*/
func (a *ConfigurationCloudOnRampApiService) GetTransitVPCSupportedSize(ctx context.Context) ConfigurationCloudOnRampApiGetTransitVPCSupportedSizeRequest {
	return ConfigurationCloudOnRampApiGetTransitVPCSupportedSizeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *ConfigurationCloudOnRampApiService) GetTransitVPCSupportedSizeExecute(r ConfigurationCloudOnRampApiGetTransitVPCSupportedSizeRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationCloudOnRampApiService.GetTransitVPCSupportedSize")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/template/cor/transitvpc/size"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.cloudEnvironment == nil {
		return localVarReturnValue, nil, reportError("cloudEnvironment is required and must be specified")
	}

	if r.cloudtype != nil {
		localVarQueryParams.Add("cloudtype", parameterToString(*r.cloudtype, ""))
	}
	localVarQueryParams.Add("cloudEnvironment", parameterToString(*r.cloudEnvironment, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationCloudOnRampApiGetTransitVPCsRequest struct {
	ctx context.Context
	ApiService *ConfigurationCloudOnRampApiService
	accountid *string
	cloudregion *string
	cloudtype *string
}

// Account Id
func (r ConfigurationCloudOnRampApiGetTransitVPCsRequest) Accountid(accountid string) ConfigurationCloudOnRampApiGetTransitVPCsRequest {
	r.accountid = &accountid
	return r
}

// Cloud region
func (r ConfigurationCloudOnRampApiGetTransitVPCsRequest) Cloudregion(cloudregion string) ConfigurationCloudOnRampApiGetTransitVPCsRequest {
	r.cloudregion = &cloudregion
	return r
}

// Cloud type
func (r ConfigurationCloudOnRampApiGetTransitVPCsRequest) Cloudtype(cloudtype string) ConfigurationCloudOnRampApiGetTransitVPCsRequest {
	r.cloudtype = &cloudtype
	return r
}

func (r ConfigurationCloudOnRampApiGetTransitVPCsRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetTransitVPCsExecute(r)
}

/*
GetTransitVPCs Method for GetTransitVPCs

Get transit VPC/VNet list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationCloudOnRampApiGetTransitVPCsRequest
*/
func (a *ConfigurationCloudOnRampApiService) GetTransitVPCs(ctx context.Context) ConfigurationCloudOnRampApiGetTransitVPCsRequest {
	return ConfigurationCloudOnRampApiGetTransitVPCsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *ConfigurationCloudOnRampApiService) GetTransitVPCsExecute(r ConfigurationCloudOnRampApiGetTransitVPCsRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationCloudOnRampApiService.GetTransitVPCs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/template/cor/transitvpc"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountid == nil {
		return localVarReturnValue, nil, reportError("accountid is required and must be specified")
	}
	if r.cloudregion == nil {
		return localVarReturnValue, nil, reportError("cloudregion is required and must be specified")
	}

	localVarQueryParams.Add("accountid", parameterToString(*r.accountid, ""))
	localVarQueryParams.Add("cloudregion", parameterToString(*r.cloudregion, ""))
	if r.cloudtype != nil {
		localVarQueryParams.Add("cloudtype", parameterToString(*r.cloudtype, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationCloudOnRampApiGetTransitVpcVpnListRequest struct {
	ctx context.Context
	ApiService *ConfigurationCloudOnRampApiService
	accountId *string
}

// Account Id
func (r ConfigurationCloudOnRampApiGetTransitVpcVpnListRequest) AccountId(accountId string) ConfigurationCloudOnRampApiGetTransitVpcVpnListRequest {
	r.accountId = &accountId
	return r
}

func (r ConfigurationCloudOnRampApiGetTransitVpcVpnListRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetTransitVpcVpnListExecute(r)
}

/*
GetTransitVpcVpnList Method for GetTransitVpcVpnList

Get transit VPN list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationCloudOnRampApiGetTransitVpcVpnListRequest
*/
func (a *ConfigurationCloudOnRampApiService) GetTransitVpcVpnList(ctx context.Context) ConfigurationCloudOnRampApiGetTransitVpcVpnListRequest {
	return ConfigurationCloudOnRampApiGetTransitVpcVpnListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *ConfigurationCloudOnRampApiService) GetTransitVpcVpnListExecute(r ConfigurationCloudOnRampApiGetTransitVpcVpnListRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationCloudOnRampApiService.GetTransitVpcVpnList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/template/cor/getTransitVpnList"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}

	localVarQueryParams.Add("accountId", parameterToString(*r.accountId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationCloudOnRampApiMapVPCsRequest struct {
	ctx context.Context
	ApiService *ConfigurationCloudOnRampApiService
	body *map[string]interface{}
}

// Map host to VPC/VNet
func (r ConfigurationCloudOnRampApiMapVPCsRequest) Body(body map[string]interface{}) ConfigurationCloudOnRampApiMapVPCsRequest {
	r.body = &body
	return r
}

func (r ConfigurationCloudOnRampApiMapVPCsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.MapVPCsExecute(r)
}

/*
MapVPCs Method for MapVPCs

Map host to transit VPC/VNet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationCloudOnRampApiMapVPCsRequest
*/
func (a *ConfigurationCloudOnRampApiService) MapVPCs(ctx context.Context) ConfigurationCloudOnRampApiMapVPCsRequest {
	return ConfigurationCloudOnRampApiMapVPCsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationCloudOnRampApiService) MapVPCsExecute(r ConfigurationCloudOnRampApiMapVPCsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationCloudOnRampApiService.MapVPCs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/template/cor/map"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationCloudOnRampApiRaiseAlarmForAccountRequest struct {
	ctx context.Context
	ApiService *ConfigurationCloudOnRampApiService
	body *map[string]interface{}
}

// Account object
func (r ConfigurationCloudOnRampApiRaiseAlarmForAccountRequest) Body(body map[string]interface{}) ConfigurationCloudOnRampApiRaiseAlarmForAccountRequest {
	r.body = &body
	return r
}

func (r ConfigurationCloudOnRampApiRaiseAlarmForAccountRequest) Execute() (*http.Response, error) {
	return r.ApiService.RaiseAlarmForAccountExecute(r)
}

/*
RaiseAlarmForAccount Method for RaiseAlarmForAccount

Raise alarm for account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationCloudOnRampApiRaiseAlarmForAccountRequest
*/
func (a *ConfigurationCloudOnRampApiService) RaiseAlarmForAccount(ctx context.Context) ConfigurationCloudOnRampApiRaiseAlarmForAccountRequest {
	return ConfigurationCloudOnRampApiRaiseAlarmForAccountRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ConfigurationCloudOnRampApiService) RaiseAlarmForAccountExecute(r ConfigurationCloudOnRampApiRaiseAlarmForAccountRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationCloudOnRampApiService.RaiseAlarmForAccount")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/template/cor/account/alarm"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ConfigurationCloudOnRampApiRemoveDeviceIdRequest struct {
	ctx context.Context
	ApiService *ConfigurationCloudOnRampApiService
	accountid *string
	transitvpcid *string
	transitvpcname *string
	cloudregion *string
	devicePairId *string
	cloudtype *string
}

// Account Id
func (r ConfigurationCloudOnRampApiRemoveDeviceIdRequest) Accountid(accountid string) ConfigurationCloudOnRampApiRemoveDeviceIdRequest {
	r.accountid = &accountid
	return r
}

// VPC Id
func (r ConfigurationCloudOnRampApiRemoveDeviceIdRequest) Transitvpcid(transitvpcid string) ConfigurationCloudOnRampApiRemoveDeviceIdRequest {
	r.transitvpcid = &transitvpcid
	return r
}

// VPC Name
func (r ConfigurationCloudOnRampApiRemoveDeviceIdRequest) Transitvpcname(transitvpcname string) ConfigurationCloudOnRampApiRemoveDeviceIdRequest {
	r.transitvpcname = &transitvpcname
	return r
}

// Cloud region
func (r ConfigurationCloudOnRampApiRemoveDeviceIdRequest) Cloudregion(cloudregion string) ConfigurationCloudOnRampApiRemoveDeviceIdRequest {
	r.cloudregion = &cloudregion
	return r
}

// Device pair Id
func (r ConfigurationCloudOnRampApiRemoveDeviceIdRequest) DevicePairId(devicePairId string) ConfigurationCloudOnRampApiRemoveDeviceIdRequest {
	r.devicePairId = &devicePairId
	return r
}

// Cloud type
func (r ConfigurationCloudOnRampApiRemoveDeviceIdRequest) Cloudtype(cloudtype string) ConfigurationCloudOnRampApiRemoveDeviceIdRequest {
	r.cloudtype = &cloudtype
	return r
}

func (r ConfigurationCloudOnRampApiRemoveDeviceIdRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.RemoveDeviceIdExecute(r)
}

/*
RemoveDeviceId Method for RemoveDeviceId

Remove device pair

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationCloudOnRampApiRemoveDeviceIdRequest
*/
func (a *ConfigurationCloudOnRampApiService) RemoveDeviceId(ctx context.Context) ConfigurationCloudOnRampApiRemoveDeviceIdRequest {
	return ConfigurationCloudOnRampApiRemoveDeviceIdRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationCloudOnRampApiService) RemoveDeviceIdExecute(r ConfigurationCloudOnRampApiRemoveDeviceIdRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationCloudOnRampApiService.RemoveDeviceId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/template/cor/deleteDevicepair"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountid == nil {
		return localVarReturnValue, nil, reportError("accountid is required and must be specified")
	}
	if r.transitvpcid == nil {
		return localVarReturnValue, nil, reportError("transitvpcid is required and must be specified")
	}
	if r.transitvpcname == nil {
		return localVarReturnValue, nil, reportError("transitvpcname is required and must be specified")
	}
	if r.cloudregion == nil {
		return localVarReturnValue, nil, reportError("cloudregion is required and must be specified")
	}
	if r.devicePairId == nil {
		return localVarReturnValue, nil, reportError("devicePairId is required and must be specified")
	}

	localVarQueryParams.Add("accountid", parameterToString(*r.accountid, ""))
	localVarQueryParams.Add("transitvpcid", parameterToString(*r.transitvpcid, ""))
	localVarQueryParams.Add("transitvpcname", parameterToString(*r.transitvpcname, ""))
	localVarQueryParams.Add("cloudregion", parameterToString(*r.cloudregion, ""))
	if r.cloudtype != nil {
		localVarQueryParams.Add("cloudtype", parameterToString(*r.cloudtype, ""))
	}
	localVarQueryParams.Add("devicePairId", parameterToString(*r.devicePairId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationCloudOnRampApiRemoveTransitVPCRequest struct {
	ctx context.Context
	ApiService *ConfigurationCloudOnRampApiService
	accountid string
	transitvpcid *string
	cloudregion *string
	cloudtype *string
}

// Cloud VPC Id
func (r ConfigurationCloudOnRampApiRemoveTransitVPCRequest) Transitvpcid(transitvpcid string) ConfigurationCloudOnRampApiRemoveTransitVPCRequest {
	r.transitvpcid = &transitvpcid
	return r
}

// Cloud region
func (r ConfigurationCloudOnRampApiRemoveTransitVPCRequest) Cloudregion(cloudregion string) ConfigurationCloudOnRampApiRemoveTransitVPCRequest {
	r.cloudregion = &cloudregion
	return r
}

// Cloud type
func (r ConfigurationCloudOnRampApiRemoveTransitVPCRequest) Cloudtype(cloudtype string) ConfigurationCloudOnRampApiRemoveTransitVPCRequest {
	r.cloudtype = &cloudtype
	return r
}

func (r ConfigurationCloudOnRampApiRemoveTransitVPCRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.RemoveTransitVPCExecute(r)
}

/*
RemoveTransitVPC Method for RemoveTransitVPC

Delete transit VPC/VNet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountid Account Id
 @return ConfigurationCloudOnRampApiRemoveTransitVPCRequest
*/
func (a *ConfigurationCloudOnRampApiService) RemoveTransitVPC(ctx context.Context, accountid string) ConfigurationCloudOnRampApiRemoveTransitVPCRequest {
	return ConfigurationCloudOnRampApiRemoveTransitVPCRequest{
		ApiService: a,
		ctx: ctx,
		accountid: accountid,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationCloudOnRampApiService) RemoveTransitVPCExecute(r ConfigurationCloudOnRampApiRemoveTransitVPCRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationCloudOnRampApiService.RemoveTransitVPC")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/template/cor/accountid/{accountid}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountid"+"}", url.PathEscape(parameterToString(r.accountid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.transitvpcid == nil {
		return localVarReturnValue, nil, reportError("transitvpcid is required and must be specified")
	}
	if r.cloudregion == nil {
		return localVarReturnValue, nil, reportError("cloudregion is required and must be specified")
	}

	localVarQueryParams.Add("transitvpcid", parameterToString(*r.transitvpcid, ""))
	localVarQueryParams.Add("cloudregion", parameterToString(*r.cloudregion, ""))
	if r.cloudtype != nil {
		localVarQueryParams.Add("cloudtype", parameterToString(*r.cloudtype, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationCloudOnRampApiScaleDownRequest struct {
	ctx context.Context
	ApiService *ConfigurationCloudOnRampApiService
	body *map[string]interface{}
}

// Update VPC
func (r ConfigurationCloudOnRampApiScaleDownRequest) Body(body map[string]interface{}) ConfigurationCloudOnRampApiScaleDownRequest {
	r.body = &body
	return r
}

func (r ConfigurationCloudOnRampApiScaleDownRequest) Execute() (*http.Response, error) {
	return r.ApiService.ScaleDownExecute(r)
}

/*
ScaleDown Method for ScaleDown

Scale down cloud on ramp

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationCloudOnRampApiScaleDownRequest
*/
func (a *ConfigurationCloudOnRampApiService) ScaleDown(ctx context.Context) ConfigurationCloudOnRampApiScaleDownRequest {
	return ConfigurationCloudOnRampApiScaleDownRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ConfigurationCloudOnRampApiService) ScaleDownExecute(r ConfigurationCloudOnRampApiScaleDownRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationCloudOnRampApiService.ScaleDown")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/template/cor/scale/down"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ConfigurationCloudOnRampApiScaleUpRequest struct {
	ctx context.Context
	ApiService *ConfigurationCloudOnRampApiService
	body *map[string]interface{}
}

// Update VPC
func (r ConfigurationCloudOnRampApiScaleUpRequest) Body(body map[string]interface{}) ConfigurationCloudOnRampApiScaleUpRequest {
	r.body = &body
	return r
}

func (r ConfigurationCloudOnRampApiScaleUpRequest) Execute() (*http.Response, error) {
	return r.ApiService.ScaleUpExecute(r)
}

/*
ScaleUp Method for ScaleUp

Scale up cloud on ramp

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationCloudOnRampApiScaleUpRequest
*/
func (a *ConfigurationCloudOnRampApiService) ScaleUp(ctx context.Context) ConfigurationCloudOnRampApiScaleUpRequest {
	return ConfigurationCloudOnRampApiScaleUpRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ConfigurationCloudOnRampApiService) ScaleUpExecute(r ConfigurationCloudOnRampApiScaleUpRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationCloudOnRampApiService.ScaleUp")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/template/cor/scale/up"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ConfigurationCloudOnRampApiUnmapVPCsRequest struct {
	ctx context.Context
	ApiService *ConfigurationCloudOnRampApiService
	body *map[string]interface{}
}

// Unmap host to VPC/VNet
func (r ConfigurationCloudOnRampApiUnmapVPCsRequest) Body(body map[string]interface{}) ConfigurationCloudOnRampApiUnmapVPCsRequest {
	r.body = &body
	return r
}

func (r ConfigurationCloudOnRampApiUnmapVPCsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.UnmapVPCsExecute(r)
}

/*
UnmapVPCs Method for UnmapVPCs

Unmap host from transit VPC/VNet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationCloudOnRampApiUnmapVPCsRequest
*/
func (a *ConfigurationCloudOnRampApiService) UnmapVPCs(ctx context.Context) ConfigurationCloudOnRampApiUnmapVPCsRequest {
	return ConfigurationCloudOnRampApiUnmapVPCsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationCloudOnRampApiService) UnmapVPCsExecute(r ConfigurationCloudOnRampApiUnmapVPCsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationCloudOnRampApiService.UnmapVPCs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/template/cor/map"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationCloudOnRampApiUpdateHostVpcReachabilityRequest struct {
	ctx context.Context
	ApiService *ConfigurationCloudOnRampApiService
	body *map[string]interface{}
}

// Update VPC status
func (r ConfigurationCloudOnRampApiUpdateHostVpcReachabilityRequest) Body(body map[string]interface{}) ConfigurationCloudOnRampApiUpdateHostVpcReachabilityRequest {
	r.body = &body
	return r
}

func (r ConfigurationCloudOnRampApiUpdateHostVpcReachabilityRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateHostVpcReachabilityExecute(r)
}

/*
UpdateHostVpcReachability Method for UpdateHostVpcReachability

Update host VPC reachability

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationCloudOnRampApiUpdateHostVpcReachabilityRequest
*/
func (a *ConfigurationCloudOnRampApiService) UpdateHostVpcReachability(ctx context.Context) ConfigurationCloudOnRampApiUpdateHostVpcReachabilityRequest {
	return ConfigurationCloudOnRampApiUpdateHostVpcReachabilityRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ConfigurationCloudOnRampApiService) UpdateHostVpcReachabilityExecute(r ConfigurationCloudOnRampApiUpdateHostVpcReachabilityRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationCloudOnRampApiService.UpdateHostVpcReachability")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/template/cor/hostvpclist"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ConfigurationCloudOnRampApiUpdateTransitVPCRequest struct {
	ctx context.Context
	ApiService *ConfigurationCloudOnRampApiService
	body *map[string]interface{}
}

// VPC
func (r ConfigurationCloudOnRampApiUpdateTransitVPCRequest) Body(body map[string]interface{}) ConfigurationCloudOnRampApiUpdateTransitVPCRequest {
	r.body = &body
	return r
}

func (r ConfigurationCloudOnRampApiUpdateTransitVPCRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.UpdateTransitVPCExecute(r)
}

/*
UpdateTransitVPC Method for UpdateTransitVPC

Update transit VPC/VNet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationCloudOnRampApiUpdateTransitVPCRequest
*/
func (a *ConfigurationCloudOnRampApiService) UpdateTransitVPC(ctx context.Context) ConfigurationCloudOnRampApiUpdateTransitVPCRequest {
	return ConfigurationCloudOnRampApiUpdateTransitVPCRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationCloudOnRampApiService) UpdateTransitVPCExecute(r ConfigurationCloudOnRampApiUpdateTransitVPCRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationCloudOnRampApiService.UpdateTransitVPC")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/template/cor/transitvpc"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationCloudOnRampApiUpdateTransitVpcAutoscalePropertiesRequest struct {
	ctx context.Context
	ApiService *ConfigurationCloudOnRampApiService
	body *map[string]interface{}
}

// VPC
func (r ConfigurationCloudOnRampApiUpdateTransitVpcAutoscalePropertiesRequest) Body(body map[string]interface{}) ConfigurationCloudOnRampApiUpdateTransitVpcAutoscalePropertiesRequest {
	r.body = &body
	return r
}

func (r ConfigurationCloudOnRampApiUpdateTransitVpcAutoscalePropertiesRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.UpdateTransitVpcAutoscalePropertiesExecute(r)
}

/*
UpdateTransitVpcAutoscaleProperties Method for UpdateTransitVpcAutoscaleProperties

Update transit VPC autoscale properties

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationCloudOnRampApiUpdateTransitVpcAutoscalePropertiesRequest
*/
func (a *ConfigurationCloudOnRampApiService) UpdateTransitVpcAutoscaleProperties(ctx context.Context) ConfigurationCloudOnRampApiUpdateTransitVpcAutoscalePropertiesRequest {
	return ConfigurationCloudOnRampApiUpdateTransitVpcAutoscalePropertiesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationCloudOnRampApiService) UpdateTransitVpcAutoscalePropertiesExecute(r ConfigurationCloudOnRampApiUpdateTransitVpcAutoscalePropertiesRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationCloudOnRampApiService.UpdateTransitVpcAutoscaleProperties")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/template/cor/transitvpc/autoscale-properties"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationCloudOnRampApiUpdatestatusRequest struct {
	ctx context.Context
	ApiService *ConfigurationCloudOnRampApiService
	body *map[string]interface{}
}

// Status object
func (r ConfigurationCloudOnRampApiUpdatestatusRequest) Body(body map[string]interface{}) ConfigurationCloudOnRampApiUpdatestatusRequest {
	r.body = &body
	return r
}

func (r ConfigurationCloudOnRampApiUpdatestatusRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdatestatusExecute(r)
}

/*
Updatestatus Method for Updatestatus

Update task status

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationCloudOnRampApiUpdatestatusRequest
*/
func (a *ConfigurationCloudOnRampApiService) Updatestatus(ctx context.Context) ConfigurationCloudOnRampApiUpdatestatusRequest {
	return ConfigurationCloudOnRampApiUpdatestatusRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ConfigurationCloudOnRampApiService) UpdatestatusExecute(r ConfigurationCloudOnRampApiUpdatestatusRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationCloudOnRampApiService.Updatestatus")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/template/cor/status"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
