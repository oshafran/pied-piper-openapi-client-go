/*
Cisco SD-WAN vManage API

The vManage API exposes the functionality of operations maintaining devices and the overlay network

API version: 2.0.0
Contact: vmanage@cisco.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// ConfigurationDeviceSSLProxyCertificateManagementApiService ConfigurationDeviceSSLProxyCertificateManagementApi service
type ConfigurationDeviceSSLProxyCertificateManagementApiService service

type ConfigurationDeviceSSLProxyCertificateManagementApiAddWANEdgeRequest struct {
	ctx context.Context
	ApiService *ConfigurationDeviceSSLProxyCertificateManagementApiService
	deviceId string
	body *map[string]interface{}
}

// Cert state
func (r ConfigurationDeviceSSLProxyCertificateManagementApiAddWANEdgeRequest) Body(body map[string]interface{}) ConfigurationDeviceSSLProxyCertificateManagementApiAddWANEdgeRequest {
	r.body = &body
	return r
}

func (r ConfigurationDeviceSSLProxyCertificateManagementApiAddWANEdgeRequest) Execute() (*http.Response, error) {
	return r.ApiService.AddWANEdgeExecute(r)
}

/*
AddWANEdge Method for AddWANEdge

Add SSL proxy wan edge

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId Device Id
 @return ConfigurationDeviceSSLProxyCertificateManagementApiAddWANEdgeRequest
*/
func (a *ConfigurationDeviceSSLProxyCertificateManagementApiService) AddWANEdge(ctx context.Context, deviceId string) ConfigurationDeviceSSLProxyCertificateManagementApiAddWANEdgeRequest {
	return ConfigurationDeviceSSLProxyCertificateManagementApiAddWANEdgeRequest{
		ApiService: a,
		ctx: ctx,
		deviceId: deviceId,
	}
}

// Execute executes the request
func (a *ConfigurationDeviceSSLProxyCertificateManagementApiService) AddWANEdgeExecute(r ConfigurationDeviceSSLProxyCertificateManagementApiAddWANEdgeRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationDeviceSSLProxyCertificateManagementApiService.AddWANEdge")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sslproxy/certificate/wanedge/{deviceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterToString(r.deviceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ConfigurationDeviceSSLProxyCertificateManagementApiGenerateSSLProxyCSRRequest struct {
	ctx context.Context
	ApiService *ConfigurationDeviceSSLProxyCertificateManagementApiService
	body *map[string]interface{}
}

// CSR request
func (r ConfigurationDeviceSSLProxyCertificateManagementApiGenerateSSLProxyCSRRequest) Body(body map[string]interface{}) ConfigurationDeviceSSLProxyCertificateManagementApiGenerateSSLProxyCSRRequest {
	r.body = &body
	return r
}

func (r ConfigurationDeviceSSLProxyCertificateManagementApiGenerateSSLProxyCSRRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GenerateSSLProxyCSRExecute(r)
}

/*
GenerateSSLProxyCSR Method for GenerateSSLProxyCSR

Generate CSR

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationDeviceSSLProxyCertificateManagementApiGenerateSSLProxyCSRRequest
*/
func (a *ConfigurationDeviceSSLProxyCertificateManagementApiService) GenerateSSLProxyCSR(ctx context.Context) ConfigurationDeviceSSLProxyCertificateManagementApiGenerateSSLProxyCSRRequest {
	return ConfigurationDeviceSSLProxyCertificateManagementApiGenerateSSLProxyCSRRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationDeviceSSLProxyCertificateManagementApiService) GenerateSSLProxyCSRExecute(r ConfigurationDeviceSSLProxyCertificateManagementApiGenerateSSLProxyCSRRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationDeviceSSLProxyCertificateManagementApiService.GenerateSSLProxyCSR")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sslproxy/generate/vmanage/csr"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationDeviceSSLProxyCertificateManagementApiGenerateSslProxyCSRRequest struct {
	ctx context.Context
	ApiService *ConfigurationDeviceSSLProxyCertificateManagementApiService
	body *map[string]interface{}
}

// CSR request for edge
func (r ConfigurationDeviceSSLProxyCertificateManagementApiGenerateSslProxyCSRRequest) Body(body map[string]interface{}) ConfigurationDeviceSSLProxyCertificateManagementApiGenerateSslProxyCSRRequest {
	r.body = &body
	return r
}

func (r ConfigurationDeviceSSLProxyCertificateManagementApiGenerateSslProxyCSRRequest) Execute() (*http.Response, error) {
	return r.ApiService.GenerateSslProxyCSRExecute(r)
}

/*
GenerateSslProxyCSR Method for GenerateSslProxyCSR

CSR request SSL proxy for edge

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationDeviceSSLProxyCertificateManagementApiGenerateSslProxyCSRRequest

Deprecated
*/
func (a *ConfigurationDeviceSSLProxyCertificateManagementApiService) GenerateSslProxyCSR(ctx context.Context) ConfigurationDeviceSSLProxyCertificateManagementApiGenerateSslProxyCSRRequest {
	return ConfigurationDeviceSSLProxyCertificateManagementApiGenerateSslProxyCSRRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
// Deprecated
func (a *ConfigurationDeviceSSLProxyCertificateManagementApiService) GenerateSslProxyCSRExecute(r ConfigurationDeviceSSLProxyCertificateManagementApiGenerateSslProxyCSRRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationDeviceSSLProxyCertificateManagementApiService.GenerateSslProxyCSR")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sslproxy/generate/csr/sslproxy"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ConfigurationDeviceSSLProxyCertificateManagementApiGetAllDeviceCSRRequest struct {
	ctx context.Context
	ApiService *ConfigurationDeviceSSLProxyCertificateManagementApiService
	body *map[string]interface{}
}

// Device list
func (r ConfigurationDeviceSSLProxyCertificateManagementApiGetAllDeviceCSRRequest) Body(body map[string]interface{}) ConfigurationDeviceSSLProxyCertificateManagementApiGetAllDeviceCSRRequest {
	r.body = &body
	return r
}

func (r ConfigurationDeviceSSLProxyCertificateManagementApiGetAllDeviceCSRRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetAllDeviceCSRExecute(r)
}

/*
GetAllDeviceCSR Method for GetAllDeviceCSR

Get CSR for all cEdges

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationDeviceSSLProxyCertificateManagementApiGetAllDeviceCSRRequest
*/
func (a *ConfigurationDeviceSSLProxyCertificateManagementApiService) GetAllDeviceCSR(ctx context.Context) ConfigurationDeviceSSLProxyCertificateManagementApiGetAllDeviceCSRRequest {
	return ConfigurationDeviceSSLProxyCertificateManagementApiGetAllDeviceCSRRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationDeviceSSLProxyCertificateManagementApiService) GetAllDeviceCSRExecute(r ConfigurationDeviceSSLProxyCertificateManagementApiGetAllDeviceCSRRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationDeviceSSLProxyCertificateManagementApiService.GetAllDeviceCSR")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sslproxy/devicecsr"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationDeviceSSLProxyCertificateManagementApiGetAllDeviceCertificatesRequest struct {
	ctx context.Context
	ApiService *ConfigurationDeviceSSLProxyCertificateManagementApiService
	body *map[string]interface{}
}

// Device list
func (r ConfigurationDeviceSSLProxyCertificateManagementApiGetAllDeviceCertificatesRequest) Body(body map[string]interface{}) ConfigurationDeviceSSLProxyCertificateManagementApiGetAllDeviceCertificatesRequest {
	r.body = &body
	return r
}

func (r ConfigurationDeviceSSLProxyCertificateManagementApiGetAllDeviceCertificatesRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetAllDeviceCertificatesExecute(r)
}

/*
GetAllDeviceCertificates Method for GetAllDeviceCertificates

Get certificate for all cEdges

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationDeviceSSLProxyCertificateManagementApiGetAllDeviceCertificatesRequest
*/
func (a *ConfigurationDeviceSSLProxyCertificateManagementApiService) GetAllDeviceCertificates(ctx context.Context) ConfigurationDeviceSSLProxyCertificateManagementApiGetAllDeviceCertificatesRequest {
	return ConfigurationDeviceSSLProxyCertificateManagementApiGetAllDeviceCertificatesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationDeviceSSLProxyCertificateManagementApiService) GetAllDeviceCertificatesExecute(r ConfigurationDeviceSSLProxyCertificateManagementApiGetAllDeviceCertificatesRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationDeviceSSLProxyCertificateManagementApiService.GetAllDeviceCertificates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sslproxy/devicecertificates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationDeviceSSLProxyCertificateManagementApiGetCertificateStateRequest struct {
	ctx context.Context
	ApiService *ConfigurationDeviceSSLProxyCertificateManagementApiService
}

func (r ConfigurationDeviceSSLProxyCertificateManagementApiGetCertificateStateRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetCertificateStateExecute(r)
}

/*
GetCertificateState Method for GetCertificateState

Get certificate state

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationDeviceSSLProxyCertificateManagementApiGetCertificateStateRequest
*/
func (a *ConfigurationDeviceSSLProxyCertificateManagementApiService) GetCertificateState(ctx context.Context) ConfigurationDeviceSSLProxyCertificateManagementApiGetCertificateStateRequest {
	return ConfigurationDeviceSSLProxyCertificateManagementApiGetCertificateStateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationDeviceSSLProxyCertificateManagementApiService) GetCertificateStateExecute(r ConfigurationDeviceSSLProxyCertificateManagementApiGetCertificateStateRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationDeviceSSLProxyCertificateManagementApiService.GetCertificateState")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sslproxy/settings/certificate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationDeviceSSLProxyCertificateManagementApiGetEnterpriseCertificateRequest struct {
	ctx context.Context
	ApiService *ConfigurationDeviceSSLProxyCertificateManagementApiService
}

func (r ConfigurationDeviceSSLProxyCertificateManagementApiGetEnterpriseCertificateRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetEnterpriseCertificateExecute(r)
}

/*
GetEnterpriseCertificate Method for GetEnterpriseCertificate

Get enterprise certificate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationDeviceSSLProxyCertificateManagementApiGetEnterpriseCertificateRequest
*/
func (a *ConfigurationDeviceSSLProxyCertificateManagementApiService) GetEnterpriseCertificate(ctx context.Context) ConfigurationDeviceSSLProxyCertificateManagementApiGetEnterpriseCertificateRequest {
	return ConfigurationDeviceSSLProxyCertificateManagementApiGetEnterpriseCertificateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationDeviceSSLProxyCertificateManagementApiService) GetEnterpriseCertificateExecute(r ConfigurationDeviceSSLProxyCertificateManagementApiGetEnterpriseCertificateRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationDeviceSSLProxyCertificateManagementApiService.GetEnterpriseCertificate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sslproxy/settings/enterprise/certificate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationDeviceSSLProxyCertificateManagementApiGetProxyCertOfEdgeRequest struct {
	ctx context.Context
	ApiService *ConfigurationDeviceSSLProxyCertificateManagementApiService
	deviceId *string
}

// Device Id
func (r ConfigurationDeviceSSLProxyCertificateManagementApiGetProxyCertOfEdgeRequest) DeviceId(deviceId string) ConfigurationDeviceSSLProxyCertificateManagementApiGetProxyCertOfEdgeRequest {
	r.deviceId = &deviceId
	return r
}

func (r ConfigurationDeviceSSLProxyCertificateManagementApiGetProxyCertOfEdgeRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetProxyCertOfEdgeExecute(r)
}

/*
GetProxyCertOfEdge Method for GetProxyCertOfEdge

Get edge proxy certificate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationDeviceSSLProxyCertificateManagementApiGetProxyCertOfEdgeRequest
*/
func (a *ConfigurationDeviceSSLProxyCertificateManagementApiService) GetProxyCertOfEdge(ctx context.Context) ConfigurationDeviceSSLProxyCertificateManagementApiGetProxyCertOfEdgeRequest {
	return ConfigurationDeviceSSLProxyCertificateManagementApiGetProxyCertOfEdgeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationDeviceSSLProxyCertificateManagementApiService) GetProxyCertOfEdgeExecute(r ConfigurationDeviceSSLProxyCertificateManagementApiGetProxyCertOfEdgeRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationDeviceSSLProxyCertificateManagementApiService.GetProxyCertOfEdge")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sslproxy/certificate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deviceId == nil {
		return localVarReturnValue, nil, reportError("deviceId is required and must be specified")
	}

	localVarQueryParams.Add("deviceId", parameterToString(*r.deviceId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationDeviceSSLProxyCertificateManagementApiGetSelfSignedCertRequest struct {
	ctx context.Context
	ApiService *ConfigurationDeviceSSLProxyCertificateManagementApiService
}

func (r ConfigurationDeviceSSLProxyCertificateManagementApiGetSelfSignedCertRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetSelfSignedCertExecute(r)
}

/*
GetSelfSignedCert Method for GetSelfSignedCert

get self signed certificate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationDeviceSSLProxyCertificateManagementApiGetSelfSignedCertRequest
*/
func (a *ConfigurationDeviceSSLProxyCertificateManagementApiService) GetSelfSignedCert(ctx context.Context) ConfigurationDeviceSSLProxyCertificateManagementApiGetSelfSignedCertRequest {
	return ConfigurationDeviceSSLProxyCertificateManagementApiGetSelfSignedCertRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationDeviceSSLProxyCertificateManagementApiService) GetSelfSignedCertExecute(r ConfigurationDeviceSSLProxyCertificateManagementApiGetSelfSignedCertRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationDeviceSSLProxyCertificateManagementApiService.GetSelfSignedCert")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/certificate/vmanage/selfsignedcert"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationDeviceSSLProxyCertificateManagementApiGetSslProxyCSRRequest struct {
	ctx context.Context
	ApiService *ConfigurationDeviceSSLProxyCertificateManagementApiService
	deviceId *string
}

// device UUID
func (r ConfigurationDeviceSSLProxyCertificateManagementApiGetSslProxyCSRRequest) DeviceId(deviceId string) ConfigurationDeviceSSLProxyCertificateManagementApiGetSslProxyCSRRequest {
	r.deviceId = &deviceId
	return r
}

func (r ConfigurationDeviceSSLProxyCertificateManagementApiGetSslProxyCSRRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetSslProxyCSRExecute(r)
}

/*
GetSslProxyCSR Method for GetSslProxyCSR

Get SSL proxy CSR

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationDeviceSSLProxyCertificateManagementApiGetSslProxyCSRRequest
*/
func (a *ConfigurationDeviceSSLProxyCertificateManagementApiService) GetSslProxyCSR(ctx context.Context) ConfigurationDeviceSSLProxyCertificateManagementApiGetSslProxyCSRRequest {
	return ConfigurationDeviceSSLProxyCertificateManagementApiGetSslProxyCSRRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationDeviceSSLProxyCertificateManagementApiService) GetSslProxyCSRExecute(r ConfigurationDeviceSSLProxyCertificateManagementApiGetSslProxyCSRRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationDeviceSSLProxyCertificateManagementApiService.GetSslProxyCSR")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sslproxy/csr"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deviceId == nil {
		return localVarReturnValue, nil, reportError("deviceId is required and must be specified")
	}

	localVarQueryParams.Add("deviceId", parameterToString(*r.deviceId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationDeviceSSLProxyCertificateManagementApiGetSslProxyListRequest struct {
	ctx context.Context
	ApiService *ConfigurationDeviceSSLProxyCertificateManagementApiService
}

func (r ConfigurationDeviceSSLProxyCertificateManagementApiGetSslProxyListRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetSslProxyListExecute(r)
}

/*
GetSslProxyList Method for GetSslProxyList

Get SSL proxy certificate list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationDeviceSSLProxyCertificateManagementApiGetSslProxyListRequest
*/
func (a *ConfigurationDeviceSSLProxyCertificateManagementApiService) GetSslProxyList(ctx context.Context) ConfigurationDeviceSSLProxyCertificateManagementApiGetSslProxyListRequest {
	return ConfigurationDeviceSSLProxyCertificateManagementApiGetSslProxyListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *ConfigurationDeviceSSLProxyCertificateManagementApiService) GetSslProxyListExecute(r ConfigurationDeviceSSLProxyCertificateManagementApiGetSslProxyListRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationDeviceSSLProxyCertificateManagementApiService.GetSslProxyList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sslproxy/list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationDeviceSSLProxyCertificateManagementApiGetVManageEnterpriseRootCertificateRequest struct {
	ctx context.Context
	ApiService *ConfigurationDeviceSSLProxyCertificateManagementApiService
}

func (r ConfigurationDeviceSSLProxyCertificateManagementApiGetVManageEnterpriseRootCertificateRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetVManageEnterpriseRootCertificateExecute(r)
}

/*
GetVManageEnterpriseRootCertificate Method for GetVManageEnterpriseRootCertificate

Get vManage enterprise root certificate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationDeviceSSLProxyCertificateManagementApiGetVManageEnterpriseRootCertificateRequest
*/
func (a *ConfigurationDeviceSSLProxyCertificateManagementApiService) GetVManageEnterpriseRootCertificate(ctx context.Context) ConfigurationDeviceSSLProxyCertificateManagementApiGetVManageEnterpriseRootCertificateRequest {
	return ConfigurationDeviceSSLProxyCertificateManagementApiGetVManageEnterpriseRootCertificateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationDeviceSSLProxyCertificateManagementApiService) GetVManageEnterpriseRootCertificateExecute(r ConfigurationDeviceSSLProxyCertificateManagementApiGetVManageEnterpriseRootCertificateRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationDeviceSSLProxyCertificateManagementApiService.GetVManageEnterpriseRootCertificate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sslproxy/settings/enterprise/rootca"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationDeviceSSLProxyCertificateManagementApiGetvManageCSRRequest struct {
	ctx context.Context
	ApiService *ConfigurationDeviceSSLProxyCertificateManagementApiService
}

func (r ConfigurationDeviceSSLProxyCertificateManagementApiGetvManageCSRRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetvManageCSRExecute(r)
}

/*
GetvManageCSR Method for GetvManageCSR

Get vManage CSR

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationDeviceSSLProxyCertificateManagementApiGetvManageCSRRequest
*/
func (a *ConfigurationDeviceSSLProxyCertificateManagementApiService) GetvManageCSR(ctx context.Context) ConfigurationDeviceSSLProxyCertificateManagementApiGetvManageCSRRequest {
	return ConfigurationDeviceSSLProxyCertificateManagementApiGetvManageCSRRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationDeviceSSLProxyCertificateManagementApiService) GetvManageCSRExecute(r ConfigurationDeviceSSLProxyCertificateManagementApiGetvManageCSRRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationDeviceSSLProxyCertificateManagementApiService.GetvManageCSR")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sslproxy/settings/vmanage/csr"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationDeviceSSLProxyCertificateManagementApiGetvManageCertificateRequest struct {
	ctx context.Context
	ApiService *ConfigurationDeviceSSLProxyCertificateManagementApiService
}

func (r ConfigurationDeviceSSLProxyCertificateManagementApiGetvManageCertificateRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetvManageCertificateExecute(r)
}

/*
GetvManageCertificate Method for GetvManageCertificate

Get vManage intermediate certificate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationDeviceSSLProxyCertificateManagementApiGetvManageCertificateRequest
*/
func (a *ConfigurationDeviceSSLProxyCertificateManagementApiService) GetvManageCertificate(ctx context.Context) ConfigurationDeviceSSLProxyCertificateManagementApiGetvManageCertificateRequest {
	return ConfigurationDeviceSSLProxyCertificateManagementApiGetvManageCertificateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationDeviceSSLProxyCertificateManagementApiService) GetvManageCertificateExecute(r ConfigurationDeviceSSLProxyCertificateManagementApiGetvManageCertificateRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationDeviceSSLProxyCertificateManagementApiService.GetvManageCertificate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sslproxy/settings/vmanage/certificate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationDeviceSSLProxyCertificateManagementApiGetvManageRootCARequest struct {
	ctx context.Context
	ApiService *ConfigurationDeviceSSLProxyCertificateManagementApiService
}

func (r ConfigurationDeviceSSLProxyCertificateManagementApiGetvManageRootCARequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetvManageRootCAExecute(r)
}

/*
GetvManageRootCA Method for GetvManageRootCA

Get vManage root certificate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationDeviceSSLProxyCertificateManagementApiGetvManageRootCARequest
*/
func (a *ConfigurationDeviceSSLProxyCertificateManagementApiService) GetvManageRootCA(ctx context.Context) ConfigurationDeviceSSLProxyCertificateManagementApiGetvManageRootCARequest {
	return ConfigurationDeviceSSLProxyCertificateManagementApiGetvManageRootCARequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationDeviceSSLProxyCertificateManagementApiService) GetvManageRootCAExecute(r ConfigurationDeviceSSLProxyCertificateManagementApiGetvManageRootCARequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationDeviceSSLProxyCertificateManagementApiService.GetvManageRootCA")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sslproxy/settings/vmanage/rootca"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationDeviceSSLProxyCertificateManagementApiRenewCertificateRequest struct {
	ctx context.Context
	ApiService *ConfigurationDeviceSSLProxyCertificateManagementApiService
	body *map[string]interface{}
}

// Renew device certificate request
func (r ConfigurationDeviceSSLProxyCertificateManagementApiRenewCertificateRequest) Body(body map[string]interface{}) ConfigurationDeviceSSLProxyCertificateManagementApiRenewCertificateRequest {
	r.body = &body
	return r
}

func (r ConfigurationDeviceSSLProxyCertificateManagementApiRenewCertificateRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.RenewCertificateExecute(r)
}

/*
RenewCertificate Method for RenewCertificate

Renew device certificate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationDeviceSSLProxyCertificateManagementApiRenewCertificateRequest
*/
func (a *ConfigurationDeviceSSLProxyCertificateManagementApiService) RenewCertificate(ctx context.Context) ConfigurationDeviceSSLProxyCertificateManagementApiRenewCertificateRequest {
	return ConfigurationDeviceSSLProxyCertificateManagementApiRenewCertificateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationDeviceSSLProxyCertificateManagementApiService) RenewCertificateExecute(r ConfigurationDeviceSSLProxyCertificateManagementApiRenewCertificateRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationDeviceSSLProxyCertificateManagementApiService.RenewCertificate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sslproxy/renew"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationDeviceSSLProxyCertificateManagementApiRevokeCertificateRequest struct {
	ctx context.Context
	ApiService *ConfigurationDeviceSSLProxyCertificateManagementApiService
	body *map[string]interface{}
}

// Revoke device certificate request
func (r ConfigurationDeviceSSLProxyCertificateManagementApiRevokeCertificateRequest) Body(body map[string]interface{}) ConfigurationDeviceSSLProxyCertificateManagementApiRevokeCertificateRequest {
	r.body = &body
	return r
}

func (r ConfigurationDeviceSSLProxyCertificateManagementApiRevokeCertificateRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.RevokeCertificateExecute(r)
}

/*
RevokeCertificate Method for RevokeCertificate

Revoke device certificate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationDeviceSSLProxyCertificateManagementApiRevokeCertificateRequest
*/
func (a *ConfigurationDeviceSSLProxyCertificateManagementApiService) RevokeCertificate(ctx context.Context) ConfigurationDeviceSSLProxyCertificateManagementApiRevokeCertificateRequest {
	return ConfigurationDeviceSSLProxyCertificateManagementApiRevokeCertificateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationDeviceSSLProxyCertificateManagementApiService) RevokeCertificateExecute(r ConfigurationDeviceSSLProxyCertificateManagementApiRevokeCertificateRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationDeviceSSLProxyCertificateManagementApiService.RevokeCertificate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sslproxy/revoke"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationDeviceSSLProxyCertificateManagementApiRevokeRenewCertificateRequest struct {
	ctx context.Context
	ApiService *ConfigurationDeviceSSLProxyCertificateManagementApiService
	body *map[string]interface{}
}

// Revoke device certificate request
func (r ConfigurationDeviceSSLProxyCertificateManagementApiRevokeRenewCertificateRequest) Body(body map[string]interface{}) ConfigurationDeviceSSLProxyCertificateManagementApiRevokeRenewCertificateRequest {
	r.body = &body
	return r
}

func (r ConfigurationDeviceSSLProxyCertificateManagementApiRevokeRenewCertificateRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.RevokeRenewCertificateExecute(r)
}

/*
RevokeRenewCertificate Method for RevokeRenewCertificate

Revoke and renew device certificate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationDeviceSSLProxyCertificateManagementApiRevokeRenewCertificateRequest
*/
func (a *ConfigurationDeviceSSLProxyCertificateManagementApiService) RevokeRenewCertificate(ctx context.Context) ConfigurationDeviceSSLProxyCertificateManagementApiRevokeRenewCertificateRequest {
	return ConfigurationDeviceSSLProxyCertificateManagementApiRevokeRenewCertificateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationDeviceSSLProxyCertificateManagementApiService) RevokeRenewCertificateExecute(r ConfigurationDeviceSSLProxyCertificateManagementApiRevokeRenewCertificateRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationDeviceSSLProxyCertificateManagementApiService.RevokeRenewCertificate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sslproxy/revokerenew"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationDeviceSSLProxyCertificateManagementApiSetEnterpriseCertRequest struct {
	ctx context.Context
	ApiService *ConfigurationDeviceSSLProxyCertificateManagementApiService
	body *map[string]interface{}
}

// Config enterprise certificate request
func (r ConfigurationDeviceSSLProxyCertificateManagementApiSetEnterpriseCertRequest) Body(body map[string]interface{}) ConfigurationDeviceSSLProxyCertificateManagementApiSetEnterpriseCertRequest {
	r.body = &body
	return r
}

func (r ConfigurationDeviceSSLProxyCertificateManagementApiSetEnterpriseCertRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.SetEnterpriseCertExecute(r)
}

/*
SetEnterpriseCert Method for SetEnterpriseCert

Configure enterprise certificate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationDeviceSSLProxyCertificateManagementApiSetEnterpriseCertRequest
*/
func (a *ConfigurationDeviceSSLProxyCertificateManagementApiService) SetEnterpriseCert(ctx context.Context) ConfigurationDeviceSSLProxyCertificateManagementApiSetEnterpriseCertRequest {
	return ConfigurationDeviceSSLProxyCertificateManagementApiSetEnterpriseCertRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationDeviceSSLProxyCertificateManagementApiService) SetEnterpriseCertExecute(r ConfigurationDeviceSSLProxyCertificateManagementApiSetEnterpriseCertRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationDeviceSSLProxyCertificateManagementApiService.SetEnterpriseCert")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sslproxy/settings/enterprise/certificate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationDeviceSSLProxyCertificateManagementApiSetEnterpriseRootCaCertRequest struct {
	ctx context.Context
	ApiService *ConfigurationDeviceSSLProxyCertificateManagementApiService
	body *map[string]interface{}
}

// Set enterprise root CA request
func (r ConfigurationDeviceSSLProxyCertificateManagementApiSetEnterpriseRootCaCertRequest) Body(body map[string]interface{}) ConfigurationDeviceSSLProxyCertificateManagementApiSetEnterpriseRootCaCertRequest {
	r.body = &body
	return r
}

func (r ConfigurationDeviceSSLProxyCertificateManagementApiSetEnterpriseRootCaCertRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.SetEnterpriseRootCaCertExecute(r)
}

/*
SetEnterpriseRootCaCert Method for SetEnterpriseRootCaCert

Set vManage enterprise root certificate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationDeviceSSLProxyCertificateManagementApiSetEnterpriseRootCaCertRequest
*/
func (a *ConfigurationDeviceSSLProxyCertificateManagementApiService) SetEnterpriseRootCaCert(ctx context.Context) ConfigurationDeviceSSLProxyCertificateManagementApiSetEnterpriseRootCaCertRequest {
	return ConfigurationDeviceSSLProxyCertificateManagementApiSetEnterpriseRootCaCertRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationDeviceSSLProxyCertificateManagementApiService) SetEnterpriseRootCaCertExecute(r ConfigurationDeviceSSLProxyCertificateManagementApiSetEnterpriseRootCaCertRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationDeviceSSLProxyCertificateManagementApiService.SetEnterpriseRootCaCert")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sslproxy/settings/enterprise/rootca"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationDeviceSSLProxyCertificateManagementApiSetvManageRootCARequest struct {
	ctx context.Context
	ApiService *ConfigurationDeviceSSLProxyCertificateManagementApiService
	body *map[string]interface{}
}

// Set vManage root CA request
func (r ConfigurationDeviceSSLProxyCertificateManagementApiSetvManageRootCARequest) Body(body map[string]interface{}) ConfigurationDeviceSSLProxyCertificateManagementApiSetvManageRootCARequest {
	r.body = &body
	return r
}

func (r ConfigurationDeviceSSLProxyCertificateManagementApiSetvManageRootCARequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.SetvManageRootCAExecute(r)
}

/*
SetvManageRootCA Method for SetvManageRootCA

Set vManage root certificate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationDeviceSSLProxyCertificateManagementApiSetvManageRootCARequest
*/
func (a *ConfigurationDeviceSSLProxyCertificateManagementApiService) SetvManageRootCA(ctx context.Context) ConfigurationDeviceSSLProxyCertificateManagementApiSetvManageRootCARequest {
	return ConfigurationDeviceSSLProxyCertificateManagementApiSetvManageRootCARequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationDeviceSSLProxyCertificateManagementApiService) SetvManageRootCAExecute(r ConfigurationDeviceSSLProxyCertificateManagementApiSetvManageRootCARequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationDeviceSSLProxyCertificateManagementApiService.SetvManageRootCA")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sslproxy/settings/vmanage/rootca"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationDeviceSSLProxyCertificateManagementApiSetvManageintermediateCertRequest struct {
	ctx context.Context
	ApiService *ConfigurationDeviceSSLProxyCertificateManagementApiService
	body *map[string]interface{}
}

// Set vManage intermediate CA request
func (r ConfigurationDeviceSSLProxyCertificateManagementApiSetvManageintermediateCertRequest) Body(body map[string]interface{}) ConfigurationDeviceSSLProxyCertificateManagementApiSetvManageintermediateCertRequest {
	r.body = &body
	return r
}

func (r ConfigurationDeviceSSLProxyCertificateManagementApiSetvManageintermediateCertRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.SetvManageintermediateCertExecute(r)
}

/*
SetvManageintermediateCert Method for SetvManageintermediateCert

Set vManage root certificate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationDeviceSSLProxyCertificateManagementApiSetvManageintermediateCertRequest
*/
func (a *ConfigurationDeviceSSLProxyCertificateManagementApiService) SetvManageintermediateCert(ctx context.Context) ConfigurationDeviceSSLProxyCertificateManagementApiSetvManageintermediateCertRequest {
	return ConfigurationDeviceSSLProxyCertificateManagementApiSetvManageintermediateCertRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationDeviceSSLProxyCertificateManagementApiService) SetvManageintermediateCertExecute(r ConfigurationDeviceSSLProxyCertificateManagementApiSetvManageintermediateCertRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationDeviceSSLProxyCertificateManagementApiService.SetvManageintermediateCert")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sslproxy/settings/vmanage/certificate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationDeviceSSLProxyCertificateManagementApiUpdateCertificateRequest struct {
	ctx context.Context
	ApiService *ConfigurationDeviceSSLProxyCertificateManagementApiService
	body *map[string]interface{}
}

// Upload device certificate
func (r ConfigurationDeviceSSLProxyCertificateManagementApiUpdateCertificateRequest) Body(body map[string]interface{}) ConfigurationDeviceSSLProxyCertificateManagementApiUpdateCertificateRequest {
	r.body = &body
	return r
}

func (r ConfigurationDeviceSSLProxyCertificateManagementApiUpdateCertificateRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.UpdateCertificateExecute(r)
}

/*
UpdateCertificate Method for UpdateCertificate

Upload device certificate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationDeviceSSLProxyCertificateManagementApiUpdateCertificateRequest
*/
func (a *ConfigurationDeviceSSLProxyCertificateManagementApiService) UpdateCertificate(ctx context.Context) ConfigurationDeviceSSLProxyCertificateManagementApiUpdateCertificateRequest {
	return ConfigurationDeviceSSLProxyCertificateManagementApiUpdateCertificateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationDeviceSSLProxyCertificateManagementApiService) UpdateCertificateExecute(r ConfigurationDeviceSSLProxyCertificateManagementApiUpdateCertificateRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationDeviceSSLProxyCertificateManagementApiService.UpdateCertificate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sslproxy/certificate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationDeviceSSLProxyCertificateManagementApiUploadCertificiatesRequest struct {
	ctx context.Context
	ApiService *ConfigurationDeviceSSLProxyCertificateManagementApiService
}

func (r ConfigurationDeviceSSLProxyCertificateManagementApiUploadCertificiatesRequest) Execute() (*http.Response, error) {
	return r.ApiService.UploadCertificiatesExecute(r)
}

/*
UploadCertificiates Method for UploadCertificiates

Upload device certificates

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationDeviceSSLProxyCertificateManagementApiUploadCertificiatesRequest
*/
func (a *ConfigurationDeviceSSLProxyCertificateManagementApiService) UploadCertificiates(ctx context.Context) ConfigurationDeviceSSLProxyCertificateManagementApiUploadCertificiatesRequest {
	return ConfigurationDeviceSSLProxyCertificateManagementApiUploadCertificiatesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ConfigurationDeviceSSLProxyCertificateManagementApiService) UploadCertificiatesExecute(r ConfigurationDeviceSSLProxyCertificateManagementApiUploadCertificiatesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationDeviceSSLProxyCertificateManagementApiService.UploadCertificiates")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sslproxy/certificates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
