/*
Cisco SD-WAN vManage API

The vManage API exposes the functionality of operations maintaining devices and the overlay network

API version: 2.0.0
Contact: vmanage@cisco.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
)


// RealTimeMonitoringDPIApiService RealTimeMonitoringDPIApi service
type RealTimeMonitoringDPIApiService service

type RealTimeMonitoringDPIApiCreateDPICollectorListRequest struct {
	ctx context.Context
	ApiService *RealTimeMonitoringDPIApiService
	deviceId *string
	vpnId *string
	application *string
	family *string
}

// Device Id
func (r RealTimeMonitoringDPIApiCreateDPICollectorListRequest) DeviceId(deviceId string) RealTimeMonitoringDPIApiCreateDPICollectorListRequest {
	r.deviceId = &deviceId
	return r
}

// VPN Id
func (r RealTimeMonitoringDPIApiCreateDPICollectorListRequest) VpnId(vpnId string) RealTimeMonitoringDPIApiCreateDPICollectorListRequest {
	r.vpnId = &vpnId
	return r
}

// Application
func (r RealTimeMonitoringDPIApiCreateDPICollectorListRequest) Application(application string) RealTimeMonitoringDPIApiCreateDPICollectorListRequest {
	r.application = &application
	return r
}

// Family
func (r RealTimeMonitoringDPIApiCreateDPICollectorListRequest) Family(family string) RealTimeMonitoringDPIApiCreateDPICollectorListRequest {
	r.family = &family
	return r
}

func (r RealTimeMonitoringDPIApiCreateDPICollectorListRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.CreateDPICollectorListExecute(r)
}

/*
CreateDPICollectorList Method for CreateDPICollectorList

Get DPI applications from device (Real Time)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return RealTimeMonitoringDPIApiCreateDPICollectorListRequest
*/
func (a *RealTimeMonitoringDPIApiService) CreateDPICollectorList(ctx context.Context) RealTimeMonitoringDPIApiCreateDPICollectorListRequest {
	return RealTimeMonitoringDPIApiCreateDPICollectorListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *RealTimeMonitoringDPIApiService) CreateDPICollectorListExecute(r RealTimeMonitoringDPIApiCreateDPICollectorListRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealTimeMonitoringDPIApiService.CreateDPICollectorList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/dpi/applications"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deviceId == nil {
		return localVarReturnValue, nil, reportError("deviceId is required and must be specified")
	}

	if r.vpnId != nil {
		localVarQueryParams.Add("vpn-id", parameterToString(*r.vpnId, ""))
	}
	if r.application != nil {
		localVarQueryParams.Add("application", parameterToString(*r.application, ""))
	}
	if r.family != nil {
		localVarQueryParams.Add("family", parameterToString(*r.family, ""))
	}
	localVarQueryParams.Add("deviceId", parameterToString(*r.deviceId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RealTimeMonitoringDPIApiCreateDPIFlowsListRequest struct {
	ctx context.Context
	ApiService *RealTimeMonitoringDPIApiService
	deviceId *string
	vpnId *string
	srcIp *string
	application *string
	family *string
}

// Device Id
func (r RealTimeMonitoringDPIApiCreateDPIFlowsListRequest) DeviceId(deviceId string) RealTimeMonitoringDPIApiCreateDPIFlowsListRequest {
	r.deviceId = &deviceId
	return r
}

// VPN Id
func (r RealTimeMonitoringDPIApiCreateDPIFlowsListRequest) VpnId(vpnId string) RealTimeMonitoringDPIApiCreateDPIFlowsListRequest {
	r.vpnId = &vpnId
	return r
}

// Source IP
func (r RealTimeMonitoringDPIApiCreateDPIFlowsListRequest) SrcIp(srcIp string) RealTimeMonitoringDPIApiCreateDPIFlowsListRequest {
	r.srcIp = &srcIp
	return r
}

// Application
func (r RealTimeMonitoringDPIApiCreateDPIFlowsListRequest) Application(application string) RealTimeMonitoringDPIApiCreateDPIFlowsListRequest {
	r.application = &application
	return r
}

// Family
func (r RealTimeMonitoringDPIApiCreateDPIFlowsListRequest) Family(family string) RealTimeMonitoringDPIApiCreateDPIFlowsListRequest {
	r.family = &family
	return r
}

func (r RealTimeMonitoringDPIApiCreateDPIFlowsListRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.CreateDPIFlowsListExecute(r)
}

/*
CreateDPIFlowsList Method for CreateDPIFlowsList

Get DPI flow list from device (Real Time)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return RealTimeMonitoringDPIApiCreateDPIFlowsListRequest
*/
func (a *RealTimeMonitoringDPIApiService) CreateDPIFlowsList(ctx context.Context) RealTimeMonitoringDPIApiCreateDPIFlowsListRequest {
	return RealTimeMonitoringDPIApiCreateDPIFlowsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *RealTimeMonitoringDPIApiService) CreateDPIFlowsListExecute(r RealTimeMonitoringDPIApiCreateDPIFlowsListRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealTimeMonitoringDPIApiService.CreateDPIFlowsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/dpi/flows"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deviceId == nil {
		return localVarReturnValue, nil, reportError("deviceId is required and must be specified")
	}

	if r.vpnId != nil {
		localVarQueryParams.Add("vpn-id", parameterToString(*r.vpnId, ""))
	}
	if r.srcIp != nil {
		localVarQueryParams.Add("src-ip", parameterToString(*r.srcIp, ""))
	}
	if r.application != nil {
		localVarQueryParams.Add("application", parameterToString(*r.application, ""))
	}
	if r.family != nil {
		localVarQueryParams.Add("family", parameterToString(*r.family, ""))
	}
	localVarQueryParams.Add("deviceId", parameterToString(*r.deviceId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RealTimeMonitoringDPIApiCreateDPIStatisticsRequest struct {
	ctx context.Context
	ApiService *RealTimeMonitoringDPIApiService
	deviceId *string
	application *string
	family *string
}

// Device Id
func (r RealTimeMonitoringDPIApiCreateDPIStatisticsRequest) DeviceId(deviceId string) RealTimeMonitoringDPIApiCreateDPIStatisticsRequest {
	r.deviceId = &deviceId
	return r
}

// Application
func (r RealTimeMonitoringDPIApiCreateDPIStatisticsRequest) Application(application string) RealTimeMonitoringDPIApiCreateDPIStatisticsRequest {
	r.application = &application
	return r
}

// Family
func (r RealTimeMonitoringDPIApiCreateDPIStatisticsRequest) Family(family string) RealTimeMonitoringDPIApiCreateDPIStatisticsRequest {
	r.family = &family
	return r
}

func (r RealTimeMonitoringDPIApiCreateDPIStatisticsRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.CreateDPIStatisticsExecute(r)
}

/*
CreateDPIStatistics Method for CreateDPIStatistics

Get supported applications from device (Real Time)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return RealTimeMonitoringDPIApiCreateDPIStatisticsRequest
*/
func (a *RealTimeMonitoringDPIApiService) CreateDPIStatistics(ctx context.Context) RealTimeMonitoringDPIApiCreateDPIStatisticsRequest {
	return RealTimeMonitoringDPIApiCreateDPIStatisticsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *RealTimeMonitoringDPIApiService) CreateDPIStatisticsExecute(r RealTimeMonitoringDPIApiCreateDPIStatisticsRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealTimeMonitoringDPIApiService.CreateDPIStatistics")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/dpi/supported-applications"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deviceId == nil {
		return localVarReturnValue, nil, reportError("deviceId is required and must be specified")
	}

	if r.application != nil {
		localVarQueryParams.Add("application", parameterToString(*r.application, ""))
	}
	if r.family != nil {
		localVarQueryParams.Add("family", parameterToString(*r.family, ""))
	}
	localVarQueryParams.Add("deviceId", parameterToString(*r.deviceId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RealTimeMonitoringDPIApiCreateDPISummaryRealTimeRequest struct {
	ctx context.Context
	ApiService *RealTimeMonitoringDPIApiService
	deviceId *string
}

// Device Id
func (r RealTimeMonitoringDPIApiCreateDPISummaryRealTimeRequest) DeviceId(deviceId string) RealTimeMonitoringDPIApiCreateDPISummaryRealTimeRequest {
	r.deviceId = &deviceId
	return r
}

func (r RealTimeMonitoringDPIApiCreateDPISummaryRealTimeRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.CreateDPISummaryRealTimeExecute(r)
}

/*
CreateDPISummaryRealTime Method for CreateDPISummaryRealTime

Get DPI summary from device (Real Time)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return RealTimeMonitoringDPIApiCreateDPISummaryRealTimeRequest
*/
func (a *RealTimeMonitoringDPIApiService) CreateDPISummaryRealTime(ctx context.Context) RealTimeMonitoringDPIApiCreateDPISummaryRealTimeRequest {
	return RealTimeMonitoringDPIApiCreateDPISummaryRealTimeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *RealTimeMonitoringDPIApiService) CreateDPISummaryRealTimeExecute(r RealTimeMonitoringDPIApiCreateDPISummaryRealTimeRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealTimeMonitoringDPIApiService.CreateDPISummaryRealTime")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/dpi/summary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deviceId == nil {
		return localVarReturnValue, nil, reportError("deviceId is required and must be specified")
	}

	localVarQueryParams.Add("deviceId", parameterToString(*r.deviceId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RealTimeMonitoringDPIApiGetCommonApplicationListRequest struct {
	ctx context.Context
	ApiService *RealTimeMonitoringDPIApiService
}

func (r RealTimeMonitoringDPIApiGetCommonApplicationListRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetCommonApplicationListExecute(r)
}

/*
GetCommonApplicationList Method for GetCommonApplicationList

Get DPI common application list from device

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return RealTimeMonitoringDPIApiGetCommonApplicationListRequest
*/
func (a *RealTimeMonitoringDPIApiService) GetCommonApplicationList(ctx context.Context) RealTimeMonitoringDPIApiGetCommonApplicationListRequest {
	return RealTimeMonitoringDPIApiGetCommonApplicationListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *RealTimeMonitoringDPIApiService) GetCommonApplicationListExecute(r RealTimeMonitoringDPIApiGetCommonApplicationListRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealTimeMonitoringDPIApiService.GetCommonApplicationList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/dpi/common/applications"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RealTimeMonitoringDPIApiGetDPIDeviceDetailsFieldJSONRequest struct {
	ctx context.Context
	ApiService *RealTimeMonitoringDPIApiService
}

func (r RealTimeMonitoringDPIApiGetDPIDeviceDetailsFieldJSONRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetDPIDeviceDetailsFieldJSONExecute(r)
}

/*
GetDPIDeviceDetailsFieldJSON Method for GetDPIDeviceDetailsFieldJSON

Get DPI detailed field from device

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return RealTimeMonitoringDPIApiGetDPIDeviceDetailsFieldJSONRequest
*/
func (a *RealTimeMonitoringDPIApiService) GetDPIDeviceDetailsFieldJSON(ctx context.Context) RealTimeMonitoringDPIApiGetDPIDeviceDetailsFieldJSONRequest {
	return RealTimeMonitoringDPIApiGetDPIDeviceDetailsFieldJSONRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *RealTimeMonitoringDPIApiService) GetDPIDeviceDetailsFieldJSONExecute(r RealTimeMonitoringDPIApiGetDPIDeviceDetailsFieldJSONRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealTimeMonitoringDPIApiService.GetDPIDeviceDetailsFieldJSON")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/dpi/devicedetails/fields"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RealTimeMonitoringDPIApiGetDPIDeviceFieldJSONRequest struct {
	ctx context.Context
	ApiService *RealTimeMonitoringDPIApiService
	isDeviceDashBoard *bool
}

// Flag whether is device dashboard request
func (r RealTimeMonitoringDPIApiGetDPIDeviceFieldJSONRequest) IsDeviceDashBoard(isDeviceDashBoard bool) RealTimeMonitoringDPIApiGetDPIDeviceFieldJSONRequest {
	r.isDeviceDashBoard = &isDeviceDashBoard
	return r
}

func (r RealTimeMonitoringDPIApiGetDPIDeviceFieldJSONRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetDPIDeviceFieldJSONExecute(r)
}

/*
GetDPIDeviceFieldJSON Method for GetDPIDeviceFieldJSON

Get DPI query field from device

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return RealTimeMonitoringDPIApiGetDPIDeviceFieldJSONRequest
*/
func (a *RealTimeMonitoringDPIApiService) GetDPIDeviceFieldJSON(ctx context.Context) RealTimeMonitoringDPIApiGetDPIDeviceFieldJSONRequest {
	return RealTimeMonitoringDPIApiGetDPIDeviceFieldJSONRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *RealTimeMonitoringDPIApiService) GetDPIDeviceFieldJSONExecute(r RealTimeMonitoringDPIApiGetDPIDeviceFieldJSONRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealTimeMonitoringDPIApiService.GetDPIDeviceFieldJSON")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/dpi/application/fields"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.isDeviceDashBoard != nil {
		localVarQueryParams.Add("isDeviceDashBoard", parameterToString(*r.isDeviceDashBoard, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RealTimeMonitoringDPIApiGetDPIFieldJSONRequest struct {
	ctx context.Context
	ApiService *RealTimeMonitoringDPIApiService
}

func (r RealTimeMonitoringDPIApiGetDPIFieldJSONRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetDPIFieldJSONExecute(r)
}

/*
GetDPIFieldJSON Method for GetDPIFieldJSON

Get DPI field from device

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return RealTimeMonitoringDPIApiGetDPIFieldJSONRequest
*/
func (a *RealTimeMonitoringDPIApiService) GetDPIFieldJSON(ctx context.Context) RealTimeMonitoringDPIApiGetDPIFieldJSONRequest {
	return RealTimeMonitoringDPIApiGetDPIFieldJSONRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *RealTimeMonitoringDPIApiService) GetDPIFieldJSONExecute(r RealTimeMonitoringDPIApiGetDPIFieldJSONRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealTimeMonitoringDPIApiService.GetDPIFieldJSON")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/dpi/device/fields"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RealTimeMonitoringDPIApiGetQosmosApplicationListRequest struct {
	ctx context.Context
	ApiService *RealTimeMonitoringDPIApiService
}

func (r RealTimeMonitoringDPIApiGetQosmosApplicationListRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetQosmosApplicationListExecute(r)
}

/*
GetQosmosApplicationList Method for GetQosmosApplicationList

Get DPI QoSMos application list from device

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return RealTimeMonitoringDPIApiGetQosmosApplicationListRequest
*/
func (a *RealTimeMonitoringDPIApiService) GetQosmosApplicationList(ctx context.Context) RealTimeMonitoringDPIApiGetQosmosApplicationListRequest {
	return RealTimeMonitoringDPIApiGetQosmosApplicationListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *RealTimeMonitoringDPIApiService) GetQosmosApplicationListExecute(r RealTimeMonitoringDPIApiGetQosmosApplicationListRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealTimeMonitoringDPIApiService.GetQosmosApplicationList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/dpi/qosmos/applications"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
