/*
Cisco SD-WAN vManage API

The vManage API exposes the functionality of operations maintaining devices and the overlay network

API version: 2.0.0
Contact: vmanage@cisco.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// ConfigurationGeneralTemplateApiService ConfigurationGeneralTemplateApi service
type ConfigurationGeneralTemplateApiService service

type ConfigurationGeneralTemplateApiChangeTemplateResourceGroupRequest struct {
	ctx context.Context
	ApiService *ConfigurationGeneralTemplateApiService
	templateId string
	resourceGroupName string
}

func (r ConfigurationGeneralTemplateApiChangeTemplateResourceGroupRequest) Execute() (*http.Response, error) {
	return r.ApiService.ChangeTemplateResourceGroupExecute(r)
}

/*
ChangeTemplateResourceGroup Method for ChangeTemplateResourceGroup

Change template resource group

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param templateId Template Id
 @param resourceGroupName Resrouce group name
 @return ConfigurationGeneralTemplateApiChangeTemplateResourceGroupRequest
*/
func (a *ConfigurationGeneralTemplateApiService) ChangeTemplateResourceGroup(ctx context.Context, templateId string, resourceGroupName string) ConfigurationGeneralTemplateApiChangeTemplateResourceGroupRequest {
	return ConfigurationGeneralTemplateApiChangeTemplateResourceGroupRequest{
		ApiService: a,
		ctx: ctx,
		templateId: templateId,
		resourceGroupName: resourceGroupName,
	}
}

// Execute executes the request
func (a *ConfigurationGeneralTemplateApiService) ChangeTemplateResourceGroupExecute(r ConfigurationGeneralTemplateApiChangeTemplateResourceGroupRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationGeneralTemplateApiService.ChangeTemplateResourceGroup")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/template/feature/resource-group/{resourceGroupName}/{templateId}"
	localVarPath = strings.Replace(localVarPath, "{"+"templateId"+"}", url.PathEscape(parameterToString(r.templateId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"resourceGroupName"+"}", url.PathEscape(parameterToString(r.resourceGroupName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ConfigurationGeneralTemplateApiCloneTemplateRequest struct {
	ctx context.Context
	ApiService *ConfigurationGeneralTemplateApiService
	id *string
	name *string
	desc *string
}

// Template Id to clone from
func (r ConfigurationGeneralTemplateApiCloneTemplateRequest) Id(id string) ConfigurationGeneralTemplateApiCloneTemplateRequest {
	r.id = &id
	return r
}

// Name for the cloned template
func (r ConfigurationGeneralTemplateApiCloneTemplateRequest) Name(name string) ConfigurationGeneralTemplateApiCloneTemplateRequest {
	r.name = &name
	return r
}

// Description for the cloned template
func (r ConfigurationGeneralTemplateApiCloneTemplateRequest) Desc(desc string) ConfigurationGeneralTemplateApiCloneTemplateRequest {
	r.desc = &desc
	return r
}

func (r ConfigurationGeneralTemplateApiCloneTemplateRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.CloneTemplateExecute(r)
}

/*
CloneTemplate Method for CloneTemplate

Clone a feature template<br><br><br>Note: In a multitenant vManage system, this API is only available in the Provider view.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationGeneralTemplateApiCloneTemplateRequest
*/
func (a *ConfigurationGeneralTemplateApiService) CloneTemplate(ctx context.Context) ConfigurationGeneralTemplateApiCloneTemplateRequest {
	return ConfigurationGeneralTemplateApiCloneTemplateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationGeneralTemplateApiService) CloneTemplateExecute(r ConfigurationGeneralTemplateApiCloneTemplateRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationGeneralTemplateApiService.CloneTemplate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/template/feature/clone"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.id == nil {
		return localVarReturnValue, nil, reportError("id is required and must be specified")
	}
	if r.name == nil {
		return localVarReturnValue, nil, reportError("name is required and must be specified")
	}
	if r.desc == nil {
		return localVarReturnValue, nil, reportError("desc is required and must be specified")
	}

	localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	localVarQueryParams.Add("desc", parameterToString(*r.desc, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationGeneralTemplateApiCreateFeatureTemplateRequest struct {
	ctx context.Context
	ApiService *ConfigurationGeneralTemplateApiService
	body *map[string]interface{}
}

// Feature template
func (r ConfigurationGeneralTemplateApiCreateFeatureTemplateRequest) Body(body map[string]interface{}) ConfigurationGeneralTemplateApiCreateFeatureTemplateRequest {
	r.body = &body
	return r
}

func (r ConfigurationGeneralTemplateApiCreateFeatureTemplateRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.CreateFeatureTemplateExecute(r)
}

/*
CreateFeatureTemplate Method for CreateFeatureTemplate

Create feature template

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationGeneralTemplateApiCreateFeatureTemplateRequest
*/
func (a *ConfigurationGeneralTemplateApiService) CreateFeatureTemplate(ctx context.Context) ConfigurationGeneralTemplateApiCreateFeatureTemplateRequest {
	return ConfigurationGeneralTemplateApiCreateFeatureTemplateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationGeneralTemplateApiService) CreateFeatureTemplateExecute(r ConfigurationGeneralTemplateApiCreateFeatureTemplateRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationGeneralTemplateApiService.CreateFeatureTemplate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/template/feature"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationGeneralTemplateApiCreateLITemplateRequest struct {
	ctx context.Context
	ApiService *ConfigurationGeneralTemplateApiService
	body *map[string]interface{}
}

// LI template
func (r ConfigurationGeneralTemplateApiCreateLITemplateRequest) Body(body map[string]interface{}) ConfigurationGeneralTemplateApiCreateLITemplateRequest {
	r.body = &body
	return r
}

func (r ConfigurationGeneralTemplateApiCreateLITemplateRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.CreateLITemplateExecute(r)
}

/*
CreateLITemplate Method for CreateLITemplate

Create LI feature template<br><br><br>Note: In a multitenant vManage system, this API is only available in the Provider view.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationGeneralTemplateApiCreateLITemplateRequest
*/
func (a *ConfigurationGeneralTemplateApiService) CreateLITemplate(ctx context.Context) ConfigurationGeneralTemplateApiCreateLITemplateRequest {
	return ConfigurationGeneralTemplateApiCreateLITemplateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationGeneralTemplateApiService) CreateLITemplateExecute(r ConfigurationGeneralTemplateApiCreateLITemplateRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationGeneralTemplateApiService.CreateLITemplate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/template/feature/li"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationGeneralTemplateApiDeleteGeneralTemplateRequest struct {
	ctx context.Context
	ApiService *ConfigurationGeneralTemplateApiService
	templateId string
}

func (r ConfigurationGeneralTemplateApiDeleteGeneralTemplateRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteGeneralTemplateExecute(r)
}

/*
DeleteGeneralTemplate Method for DeleteGeneralTemplate

Delete feature template

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param templateId Template Id
 @return ConfigurationGeneralTemplateApiDeleteGeneralTemplateRequest
*/
func (a *ConfigurationGeneralTemplateApiService) DeleteGeneralTemplate(ctx context.Context, templateId string) ConfigurationGeneralTemplateApiDeleteGeneralTemplateRequest {
	return ConfigurationGeneralTemplateApiDeleteGeneralTemplateRequest{
		ApiService: a,
		ctx: ctx,
		templateId: templateId,
	}
}

// Execute executes the request
func (a *ConfigurationGeneralTemplateApiService) DeleteGeneralTemplateExecute(r ConfigurationGeneralTemplateApiDeleteGeneralTemplateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationGeneralTemplateApiService.DeleteGeneralTemplate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/template/feature/{templateId}"
	localVarPath = strings.Replace(localVarPath, "{"+"templateId"+"}", url.PathEscape(parameterToString(r.templateId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ConfigurationGeneralTemplateApiEditFeatureTemplateRequest struct {
	ctx context.Context
	ApiService *ConfigurationGeneralTemplateApiService
	templateId string
	body *map[string]interface{}
}

// Template
func (r ConfigurationGeneralTemplateApiEditFeatureTemplateRequest) Body(body map[string]interface{}) ConfigurationGeneralTemplateApiEditFeatureTemplateRequest {
	r.body = &body
	return r
}

func (r ConfigurationGeneralTemplateApiEditFeatureTemplateRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.EditFeatureTemplateExecute(r)
}

/*
EditFeatureTemplate Method for EditFeatureTemplate

Update feature template<br><br><br>Note: In a multitenant vManage system, this API is only available in the Provider view.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param templateId Template Id
 @return ConfigurationGeneralTemplateApiEditFeatureTemplateRequest
*/
func (a *ConfigurationGeneralTemplateApiService) EditFeatureTemplate(ctx context.Context, templateId string) ConfigurationGeneralTemplateApiEditFeatureTemplateRequest {
	return ConfigurationGeneralTemplateApiEditFeatureTemplateRequest{
		ApiService: a,
		ctx: ctx,
		templateId: templateId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationGeneralTemplateApiService) EditFeatureTemplateExecute(r ConfigurationGeneralTemplateApiEditFeatureTemplateRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationGeneralTemplateApiService.EditFeatureTemplate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/template/feature/{templateId}"
	localVarPath = strings.Replace(localVarPath, "{"+"templateId"+"}", url.PathEscape(parameterToString(r.templateId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationGeneralTemplateApiEditLITemplateRequest struct {
	ctx context.Context
	ApiService *ConfigurationGeneralTemplateApiService
	templateId string
	body *map[string]interface{}
}

// LI template
func (r ConfigurationGeneralTemplateApiEditLITemplateRequest) Body(body map[string]interface{}) ConfigurationGeneralTemplateApiEditLITemplateRequest {
	r.body = &body
	return r
}

func (r ConfigurationGeneralTemplateApiEditLITemplateRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.EditLITemplateExecute(r)
}

/*
EditLITemplate Method for EditLITemplate

Update LI feature template<br><br><br>Note: In a multitenant vManage system, this API is only available in the Provider view.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param templateId Template Id
 @return ConfigurationGeneralTemplateApiEditLITemplateRequest
*/
func (a *ConfigurationGeneralTemplateApiService) EditLITemplate(ctx context.Context, templateId string) ConfigurationGeneralTemplateApiEditLITemplateRequest {
	return ConfigurationGeneralTemplateApiEditLITemplateRequest{
		ApiService: a,
		ctx: ctx,
		templateId: templateId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationGeneralTemplateApiService) EditLITemplateExecute(r ConfigurationGeneralTemplateApiEditLITemplateRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationGeneralTemplateApiService.EditLITemplate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/template/feature/li/{templateId}"
	localVarPath = strings.Replace(localVarPath, "{"+"templateId"+"}", url.PathEscape(parameterToString(r.templateId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationGeneralTemplateApiGenerateFeatureTemplateListRequest struct {
	ctx context.Context
	ApiService *ConfigurationGeneralTemplateApiService
	summary *bool
	offset *int32
	limit *int32
}

// Flag to include template definition
func (r ConfigurationGeneralTemplateApiGenerateFeatureTemplateListRequest) Summary(summary bool) ConfigurationGeneralTemplateApiGenerateFeatureTemplateListRequest {
	r.summary = &summary
	return r
}

// Pagination offset
func (r ConfigurationGeneralTemplateApiGenerateFeatureTemplateListRequest) Offset(offset int32) ConfigurationGeneralTemplateApiGenerateFeatureTemplateListRequest {
	r.offset = &offset
	return r
}

// Pagination limit on templateId
func (r ConfigurationGeneralTemplateApiGenerateFeatureTemplateListRequest) Limit(limit int32) ConfigurationGeneralTemplateApiGenerateFeatureTemplateListRequest {
	r.limit = &limit
	return r
}

func (r ConfigurationGeneralTemplateApiGenerateFeatureTemplateListRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.GenerateFeatureTemplateListExecute(r)
}

/*
GenerateFeatureTemplateList Method for GenerateFeatureTemplateList

Get feature template list<br><br><br>Note: In a multitenant vManage system, this API is only available in the Provider view.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationGeneralTemplateApiGenerateFeatureTemplateListRequest
*/
func (a *ConfigurationGeneralTemplateApiService) GenerateFeatureTemplateList(ctx context.Context) ConfigurationGeneralTemplateApiGenerateFeatureTemplateListRequest {
	return ConfigurationGeneralTemplateApiGenerateFeatureTemplateListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *ConfigurationGeneralTemplateApiService) GenerateFeatureTemplateListExecute(r ConfigurationGeneralTemplateApiGenerateFeatureTemplateListRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationGeneralTemplateApiService.GenerateFeatureTemplateList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/template/feature"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.summary != nil {
		localVarQueryParams.Add("summary", parameterToString(*r.summary, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationGeneralTemplateApiGenerateMasterTemplateDefinitionRequest struct {
	ctx context.Context
	ApiService *ConfigurationGeneralTemplateApiService
	typeName string
}

func (r ConfigurationGeneralTemplateApiGenerateMasterTemplateDefinitionRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GenerateMasterTemplateDefinitionExecute(r)
}

/*
GenerateMasterTemplateDefinition Method for GenerateMasterTemplateDefinition

Generate template type definition by device type<br><br><br>Note: In a multitenant vManage system, this API is only available in the Provider view.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param typeName Device type
 @return ConfigurationGeneralTemplateApiGenerateMasterTemplateDefinitionRequest
*/
func (a *ConfigurationGeneralTemplateApiService) GenerateMasterTemplateDefinition(ctx context.Context, typeName string) ConfigurationGeneralTemplateApiGenerateMasterTemplateDefinitionRequest {
	return ConfigurationGeneralTemplateApiGenerateMasterTemplateDefinitionRequest{
		ApiService: a,
		ctx: ctx,
		typeName: typeName,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationGeneralTemplateApiService) GenerateMasterTemplateDefinitionExecute(r ConfigurationGeneralTemplateApiGenerateMasterTemplateDefinitionRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationGeneralTemplateApiService.GenerateMasterTemplateDefinition")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/template/feature/master/{type_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"type_name"+"}", url.PathEscape(parameterToString(r.typeName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationGeneralTemplateApiGenerateTemplateByDeviceTypeRequest struct {
	ctx context.Context
	ApiService *ConfigurationGeneralTemplateApiService
	deviceType string
}

func (r ConfigurationGeneralTemplateApiGenerateTemplateByDeviceTypeRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.GenerateTemplateByDeviceTypeExecute(r)
}

/*
GenerateTemplateByDeviceType Method for GenerateTemplateByDeviceType

Generate template based on device<br><br><br>Note: In a multitenant vManage system, this API is only available in the Provider view.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceType Device type
 @return ConfigurationGeneralTemplateApiGenerateTemplateByDeviceTypeRequest
*/
func (a *ConfigurationGeneralTemplateApiService) GenerateTemplateByDeviceType(ctx context.Context, deviceType string) ConfigurationGeneralTemplateApiGenerateTemplateByDeviceTypeRequest {
	return ConfigurationGeneralTemplateApiGenerateTemplateByDeviceTypeRequest{
		ApiService: a,
		ctx: ctx,
		deviceType: deviceType,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *ConfigurationGeneralTemplateApiService) GenerateTemplateByDeviceTypeExecute(r ConfigurationGeneralTemplateApiGenerateTemplateByDeviceTypeRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationGeneralTemplateApiService.GenerateTemplateByDeviceType")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/template/feature/{deviceType}"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceType"+"}", url.PathEscape(parameterToString(r.deviceType, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationGeneralTemplateApiGenerateTemplateTypeDefinitionRequest struct {
	ctx context.Context
	ApiService *ConfigurationGeneralTemplateApiService
	typeName string
	version string
}

func (r ConfigurationGeneralTemplateApiGenerateTemplateTypeDefinitionRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.GenerateTemplateTypeDefinitionExecute(r)
}

/*
GenerateTemplateTypeDefinition Method for GenerateTemplateTypeDefinition

Generate template type definition<br><br><br>Note: In a multitenant vManage system, this API is only available in the Provider view.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param typeName Feature template type
 @param version Version
 @return ConfigurationGeneralTemplateApiGenerateTemplateTypeDefinitionRequest
*/
func (a *ConfigurationGeneralTemplateApiService) GenerateTemplateTypeDefinition(ctx context.Context, typeName string, version string) ConfigurationGeneralTemplateApiGenerateTemplateTypeDefinitionRequest {
	return ConfigurationGeneralTemplateApiGenerateTemplateTypeDefinitionRequest{
		ApiService: a,
		ctx: ctx,
		typeName: typeName,
		version: version,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *ConfigurationGeneralTemplateApiService) GenerateTemplateTypeDefinitionExecute(r ConfigurationGeneralTemplateApiGenerateTemplateTypeDefinitionRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationGeneralTemplateApiService.GenerateTemplateTypeDefinition")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/template/feature/types/definition/{type_name}/{version}"
	localVarPath = strings.Replace(localVarPath, "{"+"type_name"+"}", url.PathEscape(parameterToString(r.typeName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterToString(r.version, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationGeneralTemplateApiGenerateTemplateTypesRequest struct {
	ctx context.Context
	ApiService *ConfigurationGeneralTemplateApiService
	type_ *string
}

// Device type
func (r ConfigurationGeneralTemplateApiGenerateTemplateTypesRequest) Type_(type_ string) ConfigurationGeneralTemplateApiGenerateTemplateTypesRequest {
	r.type_ = &type_
	return r
}

func (r ConfigurationGeneralTemplateApiGenerateTemplateTypesRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.GenerateTemplateTypesExecute(r)
}

/*
GenerateTemplateTypes Method for GenerateTemplateTypes

Generate template types<br><br><br>Note: In a multitenant vManage system, this API is only available in the Provider view.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationGeneralTemplateApiGenerateTemplateTypesRequest
*/
func (a *ConfigurationGeneralTemplateApiService) GenerateTemplateTypes(ctx context.Context) ConfigurationGeneralTemplateApiGenerateTemplateTypesRequest {
	return ConfigurationGeneralTemplateApiGenerateTemplateTypesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *ConfigurationGeneralTemplateApiService) GenerateTemplateTypesExecute(r ConfigurationGeneralTemplateApiGenerateTemplateTypesRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationGeneralTemplateApiService.GenerateTemplateTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/template/feature/types"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}

	localVarQueryParams.Add("type", parameterToString(*r.type_, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationGeneralTemplateApiGetDefaultNetworksRequest struct {
	ctx context.Context
	ApiService *ConfigurationGeneralTemplateApiService
	deviceModel *string
}

// Device model
func (r ConfigurationGeneralTemplateApiGetDefaultNetworksRequest) DeviceModel(deviceModel string) ConfigurationGeneralTemplateApiGetDefaultNetworksRequest {
	r.deviceModel = &deviceModel
	return r
}

func (r ConfigurationGeneralTemplateApiGetDefaultNetworksRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetDefaultNetworksExecute(r)
}

/*
GetDefaultNetworks Method for GetDefaultNetworks

Get default networks<br><br><br>Note: In a multitenant vManage system, this API is only available in the Provider view.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationGeneralTemplateApiGetDefaultNetworksRequest
*/
func (a *ConfigurationGeneralTemplateApiService) GetDefaultNetworks(ctx context.Context) ConfigurationGeneralTemplateApiGetDefaultNetworksRequest {
	return ConfigurationGeneralTemplateApiGetDefaultNetworksRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationGeneralTemplateApiService) GetDefaultNetworksExecute(r ConfigurationGeneralTemplateApiGetDefaultNetworksRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationGeneralTemplateApiService.GetDefaultNetworks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/template/feature/default/networks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deviceModel == nil {
		return localVarReturnValue, nil, reportError("deviceModel is required and must be specified")
	}

	localVarQueryParams.Add("deviceModel", parameterToString(*r.deviceModel, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationGeneralTemplateApiGetDeviceTemplatesAttachedToFeatureRequest struct {
	ctx context.Context
	ApiService *ConfigurationGeneralTemplateApiService
	templateId string
}

func (r ConfigurationGeneralTemplateApiGetDeviceTemplatesAttachedToFeatureRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetDeviceTemplatesAttachedToFeatureExecute(r)
}

/*
GetDeviceTemplatesAttachedToFeature Method for GetDeviceTemplatesAttachedToFeature

Get all device templates for this feature template<br><br><br>Note: In a multitenant vManage system, this API is only available in the Provider view.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param templateId Feature template Id
 @return ConfigurationGeneralTemplateApiGetDeviceTemplatesAttachedToFeatureRequest
*/
func (a *ConfigurationGeneralTemplateApiService) GetDeviceTemplatesAttachedToFeature(ctx context.Context, templateId string) ConfigurationGeneralTemplateApiGetDeviceTemplatesAttachedToFeatureRequest {
	return ConfigurationGeneralTemplateApiGetDeviceTemplatesAttachedToFeatureRequest{
		ApiService: a,
		ctx: ctx,
		templateId: templateId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationGeneralTemplateApiService) GetDeviceTemplatesAttachedToFeatureExecute(r ConfigurationGeneralTemplateApiGetDeviceTemplatesAttachedToFeatureRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationGeneralTemplateApiService.GetDeviceTemplatesAttachedToFeature")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/template/feature/devicetemplates/{templateId}"
	localVarPath = strings.Replace(localVarPath, "{"+"templateId"+"}", url.PathEscape(parameterToString(r.templateId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationGeneralTemplateApiGetEncryptedStringRequest struct {
	ctx context.Context
	ApiService *ConfigurationGeneralTemplateApiService
	body *map[string]interface{}
}

// Type6 Encryption
func (r ConfigurationGeneralTemplateApiGetEncryptedStringRequest) Body(body map[string]interface{}) ConfigurationGeneralTemplateApiGetEncryptedStringRequest {
	r.body = &body
	return r
}

func (r ConfigurationGeneralTemplateApiGetEncryptedStringRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetEncryptedStringExecute(r)
}

/*
GetEncryptedString Method for GetEncryptedString

Get Type 6 Encryptedd String for a given value

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationGeneralTemplateApiGetEncryptedStringRequest
*/
func (a *ConfigurationGeneralTemplateApiService) GetEncryptedString(ctx context.Context) ConfigurationGeneralTemplateApiGetEncryptedStringRequest {
	return ConfigurationGeneralTemplateApiGetEncryptedStringRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationGeneralTemplateApiService) GetEncryptedStringExecute(r ConfigurationGeneralTemplateApiGetEncryptedStringRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationGeneralTemplateApiService.GetEncryptedString")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/template/security/encryptText/encrypt"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationGeneralTemplateApiGetGeneralTemplateRequest struct {
	ctx context.Context
	ApiService *ConfigurationGeneralTemplateApiService
	templateId string
}

func (r ConfigurationGeneralTemplateApiGetGeneralTemplateRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetGeneralTemplateExecute(r)
}

/*
GetGeneralTemplate Method for GetGeneralTemplate

Get template object definition for given template Id<br><br><br>Note: In a multitenant vManage system, this API is only available in the Provider view.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param templateId Template Id
 @return ConfigurationGeneralTemplateApiGetGeneralTemplateRequest
*/
func (a *ConfigurationGeneralTemplateApiService) GetGeneralTemplate(ctx context.Context, templateId string) ConfigurationGeneralTemplateApiGetGeneralTemplateRequest {
	return ConfigurationGeneralTemplateApiGetGeneralTemplateRequest{
		ApiService: a,
		ctx: ctx,
		templateId: templateId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationGeneralTemplateApiService) GetGeneralTemplateExecute(r ConfigurationGeneralTemplateApiGetGeneralTemplateRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationGeneralTemplateApiService.GetGeneralTemplate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/template/feature/object/{templateId}"
	localVarPath = strings.Replace(localVarPath, "{"+"templateId"+"}", url.PathEscape(parameterToString(r.templateId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationGeneralTemplateApiGetNetworkInterfaceRequest struct {
	ctx context.Context
	ApiService *ConfigurationGeneralTemplateApiService
	deviceModel *string
}

// Device model
func (r ConfigurationGeneralTemplateApiGetNetworkInterfaceRequest) DeviceModel(deviceModel string) ConfigurationGeneralTemplateApiGetNetworkInterfaceRequest {
	r.deviceModel = &deviceModel
	return r
}

func (r ConfigurationGeneralTemplateApiGetNetworkInterfaceRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetNetworkInterfaceExecute(r)
}

/*
GetNetworkInterface Method for GetNetworkInterface

Get default network interface<br><br><br>Note: In a multitenant vManage system, this API is only available in the Provider view.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationGeneralTemplateApiGetNetworkInterfaceRequest
*/
func (a *ConfigurationGeneralTemplateApiService) GetNetworkInterface(ctx context.Context) ConfigurationGeneralTemplateApiGetNetworkInterfaceRequest {
	return ConfigurationGeneralTemplateApiGetNetworkInterfaceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationGeneralTemplateApiService) GetNetworkInterfaceExecute(r ConfigurationGeneralTemplateApiGetNetworkInterfaceRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationGeneralTemplateApiService.GetNetworkInterface")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/template/feature/default/networkinterface"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deviceModel == nil {
		return localVarReturnValue, nil, reportError("deviceModel is required and must be specified")
	}

	localVarQueryParams.Add("deviceModel", parameterToString(*r.deviceModel, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationGeneralTemplateApiGetTemplateDefinitionRequest struct {
	ctx context.Context
	ApiService *ConfigurationGeneralTemplateApiService
	templateId string
}

func (r ConfigurationGeneralTemplateApiGetTemplateDefinitionRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetTemplateDefinitionExecute(r)
}

/*
GetTemplateDefinition Method for GetTemplateDefinition

Get the configured template definition for given template Id<br><br><br>Note: In a multitenant vManage system, this API is only available in the Provider view.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param templateId Template Id
 @return ConfigurationGeneralTemplateApiGetTemplateDefinitionRequest
*/
func (a *ConfigurationGeneralTemplateApiService) GetTemplateDefinition(ctx context.Context, templateId string) ConfigurationGeneralTemplateApiGetTemplateDefinitionRequest {
	return ConfigurationGeneralTemplateApiGetTemplateDefinitionRequest{
		ApiService: a,
		ctx: ctx,
		templateId: templateId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConfigurationGeneralTemplateApiService) GetTemplateDefinitionExecute(r ConfigurationGeneralTemplateApiGetTemplateDefinitionRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationGeneralTemplateApiService.GetTemplateDefinition")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/template/feature/definition/{templateId}"
	localVarPath = strings.Replace(localVarPath, "{"+"templateId"+"}", url.PathEscape(parameterToString(r.templateId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationGeneralTemplateApiGetTemplateForMigrationRequest struct {
	ctx context.Context
	ApiService *ConfigurationGeneralTemplateApiService
}

func (r ConfigurationGeneralTemplateApiGetTemplateForMigrationRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetTemplateForMigrationExecute(r)
}

/*
GetTemplateForMigration Method for GetTemplateForMigration

Generate a list of templates which require migration<br><br><br>Note: In a multitenant vManage system, this API is only available in the Provider view.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationGeneralTemplateApiGetTemplateForMigrationRequest
*/
func (a *ConfigurationGeneralTemplateApiService) GetTemplateForMigration(ctx context.Context) ConfigurationGeneralTemplateApiGetTemplateForMigrationRequest {
	return ConfigurationGeneralTemplateApiGetTemplateForMigrationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *ConfigurationGeneralTemplateApiService) GetTemplateForMigrationExecute(r ConfigurationGeneralTemplateApiGetTemplateForMigrationRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationGeneralTemplateApiService.GetTemplateForMigration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/template/feature/migration"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConfigurationGeneralTemplateApiListLITemplateRequest struct {
	ctx context.Context
	ApiService *ConfigurationGeneralTemplateApiService
}

func (r ConfigurationGeneralTemplateApiListLITemplateRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.ListLITemplateExecute(r)
}

/*
ListLITemplate Method for ListLITemplate

Get LI feature template

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConfigurationGeneralTemplateApiListLITemplateRequest
*/
func (a *ConfigurationGeneralTemplateApiService) ListLITemplate(ctx context.Context) ConfigurationGeneralTemplateApiListLITemplateRequest {
	return ConfigurationGeneralTemplateApiListLITemplateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *ConfigurationGeneralTemplateApiService) ListLITemplateExecute(r ConfigurationGeneralTemplateApiListLITemplateRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationGeneralTemplateApiService.ListLITemplate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/template/feature/li"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
