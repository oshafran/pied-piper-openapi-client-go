/*
Cisco SD-WAN vManage API

The vManage API exposes the functionality of operations maintaining devices and the overlay network

API version: 2.0.0
Contact: vmanage@cisco.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
)


// RealTimeMonitoringDeviceControlApiService RealTimeMonitoringDeviceControlApi service
type RealTimeMonitoringDeviceControlApiService service

type RealTimeMonitoringDeviceControlApiCreateConnectionHistoryListRealTimeRequest struct {
	ctx context.Context
	ApiService *RealTimeMonitoringDeviceControlApiService
	deviceId *string
	peerType *string
	systemIp *string
}

// Device IP
func (r RealTimeMonitoringDeviceControlApiCreateConnectionHistoryListRealTimeRequest) DeviceId(deviceId string) RealTimeMonitoringDeviceControlApiCreateConnectionHistoryListRealTimeRequest {
	r.deviceId = &deviceId
	return r
}

// Peer type
func (r RealTimeMonitoringDeviceControlApiCreateConnectionHistoryListRealTimeRequest) PeerType(peerType string) RealTimeMonitoringDeviceControlApiCreateConnectionHistoryListRealTimeRequest {
	r.peerType = &peerType
	return r
}

// Peer system IP
func (r RealTimeMonitoringDeviceControlApiCreateConnectionHistoryListRealTimeRequest) SystemIp(systemIp string) RealTimeMonitoringDeviceControlApiCreateConnectionHistoryListRealTimeRequest {
	r.systemIp = &systemIp
	return r
}

func (r RealTimeMonitoringDeviceControlApiCreateConnectionHistoryListRealTimeRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.CreateConnectionHistoryListRealTimeExecute(r)
}

/*
CreateConnectionHistoryListRealTime Method for CreateConnectionHistoryListRealTime

Get connections history list from device (Real Time)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return RealTimeMonitoringDeviceControlApiCreateConnectionHistoryListRealTimeRequest
*/
func (a *RealTimeMonitoringDeviceControlApiService) CreateConnectionHistoryListRealTime(ctx context.Context) RealTimeMonitoringDeviceControlApiCreateConnectionHistoryListRealTimeRequest {
	return RealTimeMonitoringDeviceControlApiCreateConnectionHistoryListRealTimeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *RealTimeMonitoringDeviceControlApiService) CreateConnectionHistoryListRealTimeExecute(r RealTimeMonitoringDeviceControlApiCreateConnectionHistoryListRealTimeRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealTimeMonitoringDeviceControlApiService.CreateConnectionHistoryListRealTime")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/control/connectionshistory"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deviceId == nil {
		return localVarReturnValue, nil, reportError("deviceId is required and must be specified")
	}

	if r.peerType != nil {
		localVarQueryParams.Add("peer-type", parameterToString(*r.peerType, ""))
	}
	if r.systemIp != nil {
		localVarQueryParams.Add("system-ip", parameterToString(*r.systemIp, ""))
	}
	localVarQueryParams.Add("deviceId", parameterToString(*r.deviceId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RealTimeMonitoringDeviceControlApiCreateConnectionsSummaryRequest struct {
	ctx context.Context
	ApiService *RealTimeMonitoringDeviceControlApiService
	deviceId *string
}

// Device IP
func (r RealTimeMonitoringDeviceControlApiCreateConnectionsSummaryRequest) DeviceId(deviceId string) RealTimeMonitoringDeviceControlApiCreateConnectionsSummaryRequest {
	r.deviceId = &deviceId
	return r
}

func (r RealTimeMonitoringDeviceControlApiCreateConnectionsSummaryRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.CreateConnectionsSummaryExecute(r)
}

/*
CreateConnectionsSummary Method for CreateConnectionsSummary

Get connections summary from device (Real Time)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return RealTimeMonitoringDeviceControlApiCreateConnectionsSummaryRequest
*/
func (a *RealTimeMonitoringDeviceControlApiService) CreateConnectionsSummary(ctx context.Context) RealTimeMonitoringDeviceControlApiCreateConnectionsSummaryRequest {
	return RealTimeMonitoringDeviceControlApiCreateConnectionsSummaryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *RealTimeMonitoringDeviceControlApiService) CreateConnectionsSummaryExecute(r RealTimeMonitoringDeviceControlApiCreateConnectionsSummaryRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealTimeMonitoringDeviceControlApiService.CreateConnectionsSummary")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/control/summary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deviceId == nil {
		return localVarReturnValue, nil, reportError("deviceId is required and must be specified")
	}

	localVarQueryParams.Add("deviceId", parameterToString(*r.deviceId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RealTimeMonitoringDeviceControlApiCreateLinkListRequest struct {
	ctx context.Context
	ApiService *RealTimeMonitoringDeviceControlApiService
	state *string
}

// Device State
func (r RealTimeMonitoringDeviceControlApiCreateLinkListRequest) State(state string) RealTimeMonitoringDeviceControlApiCreateLinkListRequest {
	r.state = &state
	return r
}

func (r RealTimeMonitoringDeviceControlApiCreateLinkListRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.CreateLinkListExecute(r)
}

/*
CreateLinkList Method for CreateLinkList

Get connections list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return RealTimeMonitoringDeviceControlApiCreateLinkListRequest
*/
func (a *RealTimeMonitoringDeviceControlApiService) CreateLinkList(ctx context.Context) RealTimeMonitoringDeviceControlApiCreateLinkListRequest {
	return RealTimeMonitoringDeviceControlApiCreateLinkListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *RealTimeMonitoringDeviceControlApiService) CreateLinkListExecute(r RealTimeMonitoringDeviceControlApiCreateLinkListRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealTimeMonitoringDeviceControlApiService.CreateLinkList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/control/links"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.state == nil {
		return localVarReturnValue, nil, reportError("state is required and must be specified")
	}

	localVarQueryParams.Add("state", parameterToString(*r.state, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RealTimeMonitoringDeviceControlApiCreateLocalPropertiesListListRealTImeRequest struct {
	ctx context.Context
	ApiService *RealTimeMonitoringDeviceControlApiService
	deviceId *string
}

// Device IP
func (r RealTimeMonitoringDeviceControlApiCreateLocalPropertiesListListRealTImeRequest) DeviceId(deviceId string) RealTimeMonitoringDeviceControlApiCreateLocalPropertiesListListRealTImeRequest {
	r.deviceId = &deviceId
	return r
}

func (r RealTimeMonitoringDeviceControlApiCreateLocalPropertiesListListRealTImeRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.CreateLocalPropertiesListListRealTImeExecute(r)
}

/*
CreateLocalPropertiesListListRealTIme Method for CreateLocalPropertiesListListRealTIme

Get local properties list (Real Time)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return RealTimeMonitoringDeviceControlApiCreateLocalPropertiesListListRealTImeRequest
*/
func (a *RealTimeMonitoringDeviceControlApiService) CreateLocalPropertiesListListRealTIme(ctx context.Context) RealTimeMonitoringDeviceControlApiCreateLocalPropertiesListListRealTImeRequest {
	return RealTimeMonitoringDeviceControlApiCreateLocalPropertiesListListRealTImeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *RealTimeMonitoringDeviceControlApiService) CreateLocalPropertiesListListRealTImeExecute(r RealTimeMonitoringDeviceControlApiCreateLocalPropertiesListListRealTImeRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealTimeMonitoringDeviceControlApiService.CreateLocalPropertiesListListRealTIme")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/control/localproperties"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deviceId == nil {
		return localVarReturnValue, nil, reportError("deviceId is required and must be specified")
	}

	localVarQueryParams.Add("deviceId", parameterToString(*r.deviceId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RealTimeMonitoringDeviceControlApiCreateLocalPropertiesSyncedListRequest struct {
	ctx context.Context
	ApiService *RealTimeMonitoringDeviceControlApiService
	deviceId *string
}

// Device Id
func (r RealTimeMonitoringDeviceControlApiCreateLocalPropertiesSyncedListRequest) DeviceId(deviceId string) RealTimeMonitoringDeviceControlApiCreateLocalPropertiesSyncedListRequest {
	r.deviceId = &deviceId
	return r
}

func (r RealTimeMonitoringDeviceControlApiCreateLocalPropertiesSyncedListRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.CreateLocalPropertiesSyncedListExecute(r)
}

/*
CreateLocalPropertiesSyncedList Method for CreateLocalPropertiesSyncedList

Get local properties list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return RealTimeMonitoringDeviceControlApiCreateLocalPropertiesSyncedListRequest
*/
func (a *RealTimeMonitoringDeviceControlApiService) CreateLocalPropertiesSyncedList(ctx context.Context) RealTimeMonitoringDeviceControlApiCreateLocalPropertiesSyncedListRequest {
	return RealTimeMonitoringDeviceControlApiCreateLocalPropertiesSyncedListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *RealTimeMonitoringDeviceControlApiService) CreateLocalPropertiesSyncedListExecute(r RealTimeMonitoringDeviceControlApiCreateLocalPropertiesSyncedListRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealTimeMonitoringDeviceControlApiService.CreateLocalPropertiesSyncedList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/control/synced/localproperties"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deviceId == nil {
		return localVarReturnValue, nil, reportError("deviceId is required and must be specified")
	}

	localVarQueryParams.Add("deviceId", parameterToString(*r.deviceId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RealTimeMonitoringDeviceControlApiCreateRealTimeConnectionListRequest struct {
	ctx context.Context
	ApiService *RealTimeMonitoringDeviceControlApiService
	deviceId *string
	peerType *string
	systemIp *string
}

// Device IP
func (r RealTimeMonitoringDeviceControlApiCreateRealTimeConnectionListRequest) DeviceId(deviceId string) RealTimeMonitoringDeviceControlApiCreateRealTimeConnectionListRequest {
	r.deviceId = &deviceId
	return r
}

// Peer type
func (r RealTimeMonitoringDeviceControlApiCreateRealTimeConnectionListRequest) PeerType(peerType string) RealTimeMonitoringDeviceControlApiCreateRealTimeConnectionListRequest {
	r.peerType = &peerType
	return r
}

// Peer system IP
func (r RealTimeMonitoringDeviceControlApiCreateRealTimeConnectionListRequest) SystemIp(systemIp string) RealTimeMonitoringDeviceControlApiCreateRealTimeConnectionListRequest {
	r.systemIp = &systemIp
	return r
}

func (r RealTimeMonitoringDeviceControlApiCreateRealTimeConnectionListRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.CreateRealTimeConnectionListExecute(r)
}

/*
CreateRealTimeConnectionList Method for CreateRealTimeConnectionList

Get connections list from device (Real Time)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return RealTimeMonitoringDeviceControlApiCreateRealTimeConnectionListRequest
*/
func (a *RealTimeMonitoringDeviceControlApiService) CreateRealTimeConnectionList(ctx context.Context) RealTimeMonitoringDeviceControlApiCreateRealTimeConnectionListRequest {
	return RealTimeMonitoringDeviceControlApiCreateRealTimeConnectionListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *RealTimeMonitoringDeviceControlApiService) CreateRealTimeConnectionListExecute(r RealTimeMonitoringDeviceControlApiCreateRealTimeConnectionListRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealTimeMonitoringDeviceControlApiService.CreateRealTimeConnectionList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/control/connections"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deviceId == nil {
		return localVarReturnValue, nil, reportError("deviceId is required and must be specified")
	}

	if r.peerType != nil {
		localVarQueryParams.Add("peer-type", parameterToString(*r.peerType, ""))
	}
	if r.systemIp != nil {
		localVarQueryParams.Add("system-ip", parameterToString(*r.systemIp, ""))
	}
	localVarQueryParams.Add("deviceId", parameterToString(*r.deviceId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RealTimeMonitoringDeviceControlApiCreateSyncedConnectionListRequest struct {
	ctx context.Context
	ApiService *RealTimeMonitoringDeviceControlApiService
	deviceId *string
	peerType *string
	systemIp *string
}

// Device IP
func (r RealTimeMonitoringDeviceControlApiCreateSyncedConnectionListRequest) DeviceId(deviceId string) RealTimeMonitoringDeviceControlApiCreateSyncedConnectionListRequest {
	r.deviceId = &deviceId
	return r
}

// Peer type
func (r RealTimeMonitoringDeviceControlApiCreateSyncedConnectionListRequest) PeerType(peerType string) RealTimeMonitoringDeviceControlApiCreateSyncedConnectionListRequest {
	r.peerType = &peerType
	return r
}

// Peer system IP
func (r RealTimeMonitoringDeviceControlApiCreateSyncedConnectionListRequest) SystemIp(systemIp string) RealTimeMonitoringDeviceControlApiCreateSyncedConnectionListRequest {
	r.systemIp = &systemIp
	return r
}

func (r RealTimeMonitoringDeviceControlApiCreateSyncedConnectionListRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.CreateSyncedConnectionListExecute(r)
}

/*
CreateSyncedConnectionList Method for CreateSyncedConnectionList

Get connections list from vManage

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return RealTimeMonitoringDeviceControlApiCreateSyncedConnectionListRequest
*/
func (a *RealTimeMonitoringDeviceControlApiService) CreateSyncedConnectionList(ctx context.Context) RealTimeMonitoringDeviceControlApiCreateSyncedConnectionListRequest {
	return RealTimeMonitoringDeviceControlApiCreateSyncedConnectionListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *RealTimeMonitoringDeviceControlApiService) CreateSyncedConnectionListExecute(r RealTimeMonitoringDeviceControlApiCreateSyncedConnectionListRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealTimeMonitoringDeviceControlApiService.CreateSyncedConnectionList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/control/synced/connections"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deviceId == nil {
		return localVarReturnValue, nil, reportError("deviceId is required and must be specified")
	}

	if r.peerType != nil {
		localVarQueryParams.Add("peer-type", parameterToString(*r.peerType, ""))
	}
	if r.systemIp != nil {
		localVarQueryParams.Add("system-ip", parameterToString(*r.systemIp, ""))
	}
	localVarQueryParams.Add("deviceId", parameterToString(*r.deviceId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RealTimeMonitoringDeviceControlApiCreateValidDevicesListRealTimeRequest struct {
	ctx context.Context
	ApiService *RealTimeMonitoringDeviceControlApiService
	deviceId *string
}

// Device Id
func (r RealTimeMonitoringDeviceControlApiCreateValidDevicesListRealTimeRequest) DeviceId(deviceId string) RealTimeMonitoringDeviceControlApiCreateValidDevicesListRealTimeRequest {
	r.deviceId = &deviceId
	return r
}

func (r RealTimeMonitoringDeviceControlApiCreateValidDevicesListRealTimeRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.CreateValidDevicesListRealTimeExecute(r)
}

/*
CreateValidDevicesListRealTime Method for CreateValidDevicesListRealTime

Get valid device list (Real Time)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return RealTimeMonitoringDeviceControlApiCreateValidDevicesListRealTimeRequest
*/
func (a *RealTimeMonitoringDeviceControlApiService) CreateValidDevicesListRealTime(ctx context.Context) RealTimeMonitoringDeviceControlApiCreateValidDevicesListRealTimeRequest {
	return RealTimeMonitoringDeviceControlApiCreateValidDevicesListRealTimeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *RealTimeMonitoringDeviceControlApiService) CreateValidDevicesListRealTimeExecute(r RealTimeMonitoringDeviceControlApiCreateValidDevicesListRealTimeRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealTimeMonitoringDeviceControlApiService.CreateValidDevicesListRealTime")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/control/validdevices"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deviceId == nil {
		return localVarReturnValue, nil, reportError("deviceId is required and must be specified")
	}

	localVarQueryParams.Add("deviceId", parameterToString(*r.deviceId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RealTimeMonitoringDeviceControlApiCreateValidVSmartsListRealTimeRequest struct {
	ctx context.Context
	ApiService *RealTimeMonitoringDeviceControlApiService
	deviceId *string
}

// Device IP
func (r RealTimeMonitoringDeviceControlApiCreateValidVSmartsListRealTimeRequest) DeviceId(deviceId string) RealTimeMonitoringDeviceControlApiCreateValidVSmartsListRealTimeRequest {
	r.deviceId = &deviceId
	return r
}

func (r RealTimeMonitoringDeviceControlApiCreateValidVSmartsListRealTimeRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.CreateValidVSmartsListRealTimeExecute(r)
}

/*
CreateValidVSmartsListRealTime Method for CreateValidVSmartsListRealTime

Get valid vSmart list from device (Real Time)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return RealTimeMonitoringDeviceControlApiCreateValidVSmartsListRealTimeRequest
*/
func (a *RealTimeMonitoringDeviceControlApiService) CreateValidVSmartsListRealTime(ctx context.Context) RealTimeMonitoringDeviceControlApiCreateValidVSmartsListRealTimeRequest {
	return RealTimeMonitoringDeviceControlApiCreateValidVSmartsListRealTimeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *RealTimeMonitoringDeviceControlApiService) CreateValidVSmartsListRealTimeExecute(r RealTimeMonitoringDeviceControlApiCreateValidVSmartsListRealTimeRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealTimeMonitoringDeviceControlApiService.CreateValidVSmartsListRealTime")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/control/validvsmarts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deviceId == nil {
		return localVarReturnValue, nil, reportError("deviceId is required and must be specified")
	}

	localVarQueryParams.Add("deviceId", parameterToString(*r.deviceId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RealTimeMonitoringDeviceControlApiCreateWanInterfaceListListRequest struct {
	ctx context.Context
	ApiService *RealTimeMonitoringDeviceControlApiService
	deviceId *string
}

// Device IP
func (r RealTimeMonitoringDeviceControlApiCreateWanInterfaceListListRequest) DeviceId(deviceId string) RealTimeMonitoringDeviceControlApiCreateWanInterfaceListListRequest {
	r.deviceId = &deviceId
	return r
}

func (r RealTimeMonitoringDeviceControlApiCreateWanInterfaceListListRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.CreateWanInterfaceListListExecute(r)
}

/*
CreateWanInterfaceListList Method for CreateWanInterfaceListList

Get WAN interface list (Real Time)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return RealTimeMonitoringDeviceControlApiCreateWanInterfaceListListRequest
*/
func (a *RealTimeMonitoringDeviceControlApiService) CreateWanInterfaceListList(ctx context.Context) RealTimeMonitoringDeviceControlApiCreateWanInterfaceListListRequest {
	return RealTimeMonitoringDeviceControlApiCreateWanInterfaceListListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *RealTimeMonitoringDeviceControlApiService) CreateWanInterfaceListListExecute(r RealTimeMonitoringDeviceControlApiCreateWanInterfaceListListRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealTimeMonitoringDeviceControlApiService.CreateWanInterfaceListList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/control/waninterface"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deviceId == nil {
		return localVarReturnValue, nil, reportError("deviceId is required and must be specified")
	}

	localVarQueryParams.Add("deviceId", parameterToString(*r.deviceId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RealTimeMonitoringDeviceControlApiCreateWanInterfaceSyncedListRequest struct {
	ctx context.Context
	ApiService *RealTimeMonitoringDeviceControlApiService
	deviceId *string
}

// Device Id
func (r RealTimeMonitoringDeviceControlApiCreateWanInterfaceSyncedListRequest) DeviceId(deviceId string) RealTimeMonitoringDeviceControlApiCreateWanInterfaceSyncedListRequest {
	r.deviceId = &deviceId
	return r
}

func (r RealTimeMonitoringDeviceControlApiCreateWanInterfaceSyncedListRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.CreateWanInterfaceSyncedListExecute(r)
}

/*
CreateWanInterfaceSyncedList Method for CreateWanInterfaceSyncedList

Get WAN interface list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return RealTimeMonitoringDeviceControlApiCreateWanInterfaceSyncedListRequest
*/
func (a *RealTimeMonitoringDeviceControlApiService) CreateWanInterfaceSyncedList(ctx context.Context) RealTimeMonitoringDeviceControlApiCreateWanInterfaceSyncedListRequest {
	return RealTimeMonitoringDeviceControlApiCreateWanInterfaceSyncedListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *RealTimeMonitoringDeviceControlApiService) CreateWanInterfaceSyncedListExecute(r RealTimeMonitoringDeviceControlApiCreateWanInterfaceSyncedListRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealTimeMonitoringDeviceControlApiService.CreateWanInterfaceSyncedList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/control/synced/waninterface"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deviceId == nil {
		return localVarReturnValue, nil, reportError("deviceId is required and must be specified")
	}

	localVarQueryParams.Add("deviceId", parameterToString(*r.deviceId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RealTimeMonitoringDeviceControlApiGetAffinityConfigRequest struct {
	ctx context.Context
	ApiService *RealTimeMonitoringDeviceControlApiService
	deviceId *string
}

// Device IP
func (r RealTimeMonitoringDeviceControlApiGetAffinityConfigRequest) DeviceId(deviceId string) RealTimeMonitoringDeviceControlApiGetAffinityConfigRequest {
	r.deviceId = &deviceId
	return r
}

func (r RealTimeMonitoringDeviceControlApiGetAffinityConfigRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetAffinityConfigExecute(r)
}

/*
GetAffinityConfig Method for GetAffinityConfig

Get affinity config from device (Real Time)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return RealTimeMonitoringDeviceControlApiGetAffinityConfigRequest
*/
func (a *RealTimeMonitoringDeviceControlApiService) GetAffinityConfig(ctx context.Context) RealTimeMonitoringDeviceControlApiGetAffinityConfigRequest {
	return RealTimeMonitoringDeviceControlApiGetAffinityConfigRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *RealTimeMonitoringDeviceControlApiService) GetAffinityConfigExecute(r RealTimeMonitoringDeviceControlApiGetAffinityConfigRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealTimeMonitoringDeviceControlApiService.GetAffinityConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/control/affinity/config"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deviceId == nil {
		return localVarReturnValue, nil, reportError("deviceId is required and must be specified")
	}

	localVarQueryParams.Add("deviceId", parameterToString(*r.deviceId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RealTimeMonitoringDeviceControlApiGetAffinityStatusRequest struct {
	ctx context.Context
	ApiService *RealTimeMonitoringDeviceControlApiService
	deviceId *string
}

// Device IP
func (r RealTimeMonitoringDeviceControlApiGetAffinityStatusRequest) DeviceId(deviceId string) RealTimeMonitoringDeviceControlApiGetAffinityStatusRequest {
	r.deviceId = &deviceId
	return r
}

func (r RealTimeMonitoringDeviceControlApiGetAffinityStatusRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetAffinityStatusExecute(r)
}

/*
GetAffinityStatus Method for GetAffinityStatus

Get affinity status from device (Real Time)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return RealTimeMonitoringDeviceControlApiGetAffinityStatusRequest
*/
func (a *RealTimeMonitoringDeviceControlApiService) GetAffinityStatus(ctx context.Context) RealTimeMonitoringDeviceControlApiGetAffinityStatusRequest {
	return RealTimeMonitoringDeviceControlApiGetAffinityStatusRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *RealTimeMonitoringDeviceControlApiService) GetAffinityStatusExecute(r RealTimeMonitoringDeviceControlApiGetAffinityStatusRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealTimeMonitoringDeviceControlApiService.GetAffinityStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/control/affinity/status"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deviceId == nil {
		return localVarReturnValue, nil, reportError("deviceId is required and must be specified")
	}

	localVarQueryParams.Add("deviceId", parameterToString(*r.deviceId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RealTimeMonitoringDeviceControlApiGetConnectionStatisticsRequest struct {
	ctx context.Context
	ApiService *RealTimeMonitoringDeviceControlApiService
	deviceId *string
}

// Device IP
func (r RealTimeMonitoringDeviceControlApiGetConnectionStatisticsRequest) DeviceId(deviceId string) RealTimeMonitoringDeviceControlApiGetConnectionStatisticsRequest {
	r.deviceId = &deviceId
	return r
}

func (r RealTimeMonitoringDeviceControlApiGetConnectionStatisticsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetConnectionStatisticsExecute(r)
}

/*
GetConnectionStatistics Method for GetConnectionStatistics

Get connection statistics from device (Real Time)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return RealTimeMonitoringDeviceControlApiGetConnectionStatisticsRequest
*/
func (a *RealTimeMonitoringDeviceControlApiService) GetConnectionStatistics(ctx context.Context) RealTimeMonitoringDeviceControlApiGetConnectionStatisticsRequest {
	return RealTimeMonitoringDeviceControlApiGetConnectionStatisticsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *RealTimeMonitoringDeviceControlApiService) GetConnectionStatisticsExecute(r RealTimeMonitoringDeviceControlApiGetConnectionStatisticsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealTimeMonitoringDeviceControlApiService.GetConnectionStatistics")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/control/statistics"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deviceId == nil {
		return localVarReturnValue, nil, reportError("deviceId is required and must be specified")
	}

	localVarQueryParams.Add("deviceId", parameterToString(*r.deviceId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RealTimeMonitoringDeviceControlApiGetDeviceControlStatusSummaryRequest struct {
	ctx context.Context
	ApiService *RealTimeMonitoringDeviceControlApiService
	deviceId *string
}

// Device Id
func (r RealTimeMonitoringDeviceControlApiGetDeviceControlStatusSummaryRequest) DeviceId(deviceId string) RealTimeMonitoringDeviceControlApiGetDeviceControlStatusSummaryRequest {
	r.deviceId = &deviceId
	return r
}

func (r RealTimeMonitoringDeviceControlApiGetDeviceControlStatusSummaryRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetDeviceControlStatusSummaryExecute(r)
}

/*
GetDeviceControlStatusSummary Method for GetDeviceControlStatusSummary

Get device control status summary

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return RealTimeMonitoringDeviceControlApiGetDeviceControlStatusSummaryRequest
*/
func (a *RealTimeMonitoringDeviceControlApiService) GetDeviceControlStatusSummary(ctx context.Context) RealTimeMonitoringDeviceControlApiGetDeviceControlStatusSummaryRequest {
	return RealTimeMonitoringDeviceControlApiGetDeviceControlStatusSummaryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *RealTimeMonitoringDeviceControlApiService) GetDeviceControlStatusSummaryExecute(r RealTimeMonitoringDeviceControlApiGetDeviceControlStatusSummaryRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealTimeMonitoringDeviceControlApiService.GetDeviceControlStatusSummary")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/control/summary/device"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deviceId == nil {
		return localVarReturnValue, nil, reportError("deviceId is required and must be specified")
	}

	localVarQueryParams.Add("deviceId", parameterToString(*r.deviceId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RealTimeMonitoringDeviceControlApiGetLocalDeviceStatusRequest struct {
	ctx context.Context
	ApiService *RealTimeMonitoringDeviceControlApiService
}

func (r RealTimeMonitoringDeviceControlApiGetLocalDeviceStatusRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetLocalDeviceStatusExecute(r)
}

/*
GetLocalDeviceStatus Method for GetLocalDeviceStatus

Get local device status

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return RealTimeMonitoringDeviceControlApiGetLocalDeviceStatusRequest
*/
func (a *RealTimeMonitoringDeviceControlApiService) GetLocalDeviceStatus(ctx context.Context) RealTimeMonitoringDeviceControlApiGetLocalDeviceStatusRequest {
	return RealTimeMonitoringDeviceControlApiGetLocalDeviceStatusRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *RealTimeMonitoringDeviceControlApiService) GetLocalDeviceStatusExecute(r RealTimeMonitoringDeviceControlApiGetLocalDeviceStatusRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealTimeMonitoringDeviceControlApiService.GetLocalDeviceStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/control/status"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RealTimeMonitoringDeviceControlApiGetPortHopColorRequest struct {
	ctx context.Context
	ApiService *RealTimeMonitoringDeviceControlApiService
	deviceId *string
}

// Device IP
func (r RealTimeMonitoringDeviceControlApiGetPortHopColorRequest) DeviceId(deviceId string) RealTimeMonitoringDeviceControlApiGetPortHopColorRequest {
	r.deviceId = &deviceId
	return r
}

func (r RealTimeMonitoringDeviceControlApiGetPortHopColorRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetPortHopColorExecute(r)
}

/*
GetPortHopColor Method for GetPortHopColor

Get port hop colors

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return RealTimeMonitoringDeviceControlApiGetPortHopColorRequest
*/
func (a *RealTimeMonitoringDeviceControlApiService) GetPortHopColor(ctx context.Context) RealTimeMonitoringDeviceControlApiGetPortHopColorRequest {
	return RealTimeMonitoringDeviceControlApiGetPortHopColorRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *RealTimeMonitoringDeviceControlApiService) GetPortHopColorExecute(r RealTimeMonitoringDeviceControlApiGetPortHopColorRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealTimeMonitoringDeviceControlApiService.GetPortHopColor")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/control/waninterface/color"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deviceId == nil {
		return localVarReturnValue, nil, reportError("deviceId is required and must be specified")
	}

	localVarQueryParams.Add("deviceId", parameterToString(*r.deviceId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RealTimeMonitoringDeviceControlApiGetTotalCountForDeviceStatesRequest struct {
	ctx context.Context
	ApiService *RealTimeMonitoringDeviceControlApiService
	isCached *bool
}

// Device State cached
func (r RealTimeMonitoringDeviceControlApiGetTotalCountForDeviceStatesRequest) IsCached(isCached bool) RealTimeMonitoringDeviceControlApiGetTotalCountForDeviceStatesRequest {
	r.isCached = &isCached
	return r
}

func (r RealTimeMonitoringDeviceControlApiGetTotalCountForDeviceStatesRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetTotalCountForDeviceStatesExecute(r)
}

/*
GetTotalCountForDeviceStates Method for GetTotalCountForDeviceStates

Get number of vedges and vsmart device in different control states

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return RealTimeMonitoringDeviceControlApiGetTotalCountForDeviceStatesRequest
*/
func (a *RealTimeMonitoringDeviceControlApiService) GetTotalCountForDeviceStates(ctx context.Context) RealTimeMonitoringDeviceControlApiGetTotalCountForDeviceStatesRequest {
	return RealTimeMonitoringDeviceControlApiGetTotalCountForDeviceStatesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *RealTimeMonitoringDeviceControlApiService) GetTotalCountForDeviceStatesExecute(r RealTimeMonitoringDeviceControlApiGetTotalCountForDeviceStatesRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealTimeMonitoringDeviceControlApiService.GetTotalCountForDeviceStates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/control/count"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.isCached != nil {
		localVarQueryParams.Add("isCached", parameterToString(*r.isCached, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RealTimeMonitoringDeviceControlApiGetValidVManageIdRealTimeRequest struct {
	ctx context.Context
	ApiService *RealTimeMonitoringDeviceControlApiService
	deviceId *string
}

// Device Id
func (r RealTimeMonitoringDeviceControlApiGetValidVManageIdRealTimeRequest) DeviceId(deviceId string) RealTimeMonitoringDeviceControlApiGetValidVManageIdRealTimeRequest {
	r.deviceId = &deviceId
	return r
}

func (r RealTimeMonitoringDeviceControlApiGetValidVManageIdRealTimeRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetValidVManageIdRealTimeExecute(r)
}

/*
GetValidVManageIdRealTime Method for GetValidVManageIdRealTime

Get valid vManage from device (Real Time)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return RealTimeMonitoringDeviceControlApiGetValidVManageIdRealTimeRequest
*/
func (a *RealTimeMonitoringDeviceControlApiService) GetValidVManageIdRealTime(ctx context.Context) RealTimeMonitoringDeviceControlApiGetValidVManageIdRealTimeRequest {
	return RealTimeMonitoringDeviceControlApiGetValidVManageIdRealTimeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *RealTimeMonitoringDeviceControlApiService) GetValidVManageIdRealTimeExecute(r RealTimeMonitoringDeviceControlApiGetValidVManageIdRealTimeRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealTimeMonitoringDeviceControlApiService.GetValidVManageIdRealTime")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/control/validvmanageid"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deviceId == nil {
		return localVarReturnValue, nil, reportError("deviceId is required and must be specified")
	}

	localVarQueryParams.Add("deviceId", parameterToString(*r.deviceId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RealTimeMonitoringDeviceControlApiNetworkSummaryRequest struct {
	ctx context.Context
	ApiService *RealTimeMonitoringDeviceControlApiService
	state *string
}

// Device State
func (r RealTimeMonitoringDeviceControlApiNetworkSummaryRequest) State(state string) RealTimeMonitoringDeviceControlApiNetworkSummaryRequest {
	r.state = &state
	return r
}

func (r RealTimeMonitoringDeviceControlApiNetworkSummaryRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.NetworkSummaryExecute(r)
}

/*
NetworkSummary Method for NetworkSummary

Get list of unreachable devices

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return RealTimeMonitoringDeviceControlApiNetworkSummaryRequest
*/
func (a *RealTimeMonitoringDeviceControlApiService) NetworkSummary(ctx context.Context) RealTimeMonitoringDeviceControlApiNetworkSummaryRequest {
	return RealTimeMonitoringDeviceControlApiNetworkSummaryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *RealTimeMonitoringDeviceControlApiService) NetworkSummaryExecute(r RealTimeMonitoringDeviceControlApiNetworkSummaryRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealTimeMonitoringDeviceControlApiService.NetworkSummary")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/device/control/networksummary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.state != nil {
		localVarQueryParams.Add("state", parameterToString(*r.state, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
