/*
Cisco SD-WAN vManage API

The vManage API exposes the functionality of operations maintaining devices and the overlay network

API version: 2.0.0
Contact: vmanage@cisco.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// TroubleshootingToolsDiagnosticsApiService TroubleshootingToolsDiagnosticsApi service
type TroubleshootingToolsDiagnosticsApiService service

type TroubleshootingToolsDiagnosticsApiClearSessionRequest struct {
	ctx context.Context
	ApiService *TroubleshootingToolsDiagnosticsApiService
	sessionId string
}

func (r TroubleshootingToolsDiagnosticsApiClearSessionRequest) Execute() (*http.Response, error) {
	return r.ApiService.ClearSessionExecute(r)
}

/*
ClearSession Method for ClearSession

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sessionId Session Id
 @return TroubleshootingToolsDiagnosticsApiClearSessionRequest
*/
func (a *TroubleshootingToolsDiagnosticsApiService) ClearSession(ctx context.Context, sessionId string) TroubleshootingToolsDiagnosticsApiClearSessionRequest {
	return TroubleshootingToolsDiagnosticsApiClearSessionRequest{
		ApiService: a,
		ctx: ctx,
		sessionId: sessionId,
	}
}

// Execute executes the request
func (a *TroubleshootingToolsDiagnosticsApiService) ClearSessionExecute(r TroubleshootingToolsDiagnosticsApiClearSessionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TroubleshootingToolsDiagnosticsApiService.ClearSession")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stream/device/log/sessions/clear/{sessionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"sessionId"+"}", url.PathEscape(parameterToString(r.sessionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type TroubleshootingToolsDiagnosticsApiDisableDeviceLogRequest struct {
	ctx context.Context
	ApiService *TroubleshootingToolsDiagnosticsApiService
	sessionId Uuid
}

func (r TroubleshootingToolsDiagnosticsApiDisableDeviceLogRequest) Execute() (*http.Response, error) {
	return r.ApiService.DisableDeviceLogExecute(r)
}

/*
DisableDeviceLog Method for DisableDeviceLog

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sessionId
 @return TroubleshootingToolsDiagnosticsApiDisableDeviceLogRequest
*/
func (a *TroubleshootingToolsDiagnosticsApiService) DisableDeviceLog(ctx context.Context, sessionId Uuid) TroubleshootingToolsDiagnosticsApiDisableDeviceLogRequest {
	return TroubleshootingToolsDiagnosticsApiDisableDeviceLogRequest{
		ApiService: a,
		ctx: ctx,
		sessionId: sessionId,
	}
}

// Execute executes the request
func (a *TroubleshootingToolsDiagnosticsApiService) DisableDeviceLogExecute(r TroubleshootingToolsDiagnosticsApiDisableDeviceLogRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TroubleshootingToolsDiagnosticsApiService.DisableDeviceLog")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stream/device/log/disable/{sessionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"sessionId"+"}", url.PathEscape(parameterToString(r.sessionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type TroubleshootingToolsDiagnosticsApiDisablePacketCaptureSessionRequest struct {
	ctx context.Context
	ApiService *TroubleshootingToolsDiagnosticsApiService
	sessionId Uuid
}

func (r TroubleshootingToolsDiagnosticsApiDisablePacketCaptureSessionRequest) Execute() (*http.Response, error) {
	return r.ApiService.DisablePacketCaptureSessionExecute(r)
}

/*
DisablePacketCaptureSession Method for DisablePacketCaptureSession

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sessionId
 @return TroubleshootingToolsDiagnosticsApiDisablePacketCaptureSessionRequest
*/
func (a *TroubleshootingToolsDiagnosticsApiService) DisablePacketCaptureSession(ctx context.Context, sessionId Uuid) TroubleshootingToolsDiagnosticsApiDisablePacketCaptureSessionRequest {
	return TroubleshootingToolsDiagnosticsApiDisablePacketCaptureSessionRequest{
		ApiService: a,
		ctx: ctx,
		sessionId: sessionId,
	}
}

// Execute executes the request
func (a *TroubleshootingToolsDiagnosticsApiService) DisablePacketCaptureSessionExecute(r TroubleshootingToolsDiagnosticsApiDisablePacketCaptureSessionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TroubleshootingToolsDiagnosticsApiService.DisablePacketCaptureSession")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stream/device/capture/disable/{sessionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"sessionId"+"}", url.PathEscape(parameterToString(r.sessionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type TroubleshootingToolsDiagnosticsApiDisableSpeedTestSessionRequest struct {
	ctx context.Context
	ApiService *TroubleshootingToolsDiagnosticsApiService
	sessionId Uuid
}

func (r TroubleshootingToolsDiagnosticsApiDisableSpeedTestSessionRequest) Execute() (*http.Response, error) {
	return r.ApiService.DisableSpeedTestSessionExecute(r)
}

/*
DisableSpeedTestSession Method for DisableSpeedTestSession

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sessionId
 @return TroubleshootingToolsDiagnosticsApiDisableSpeedTestSessionRequest
*/
func (a *TroubleshootingToolsDiagnosticsApiService) DisableSpeedTestSession(ctx context.Context, sessionId Uuid) TroubleshootingToolsDiagnosticsApiDisableSpeedTestSessionRequest {
	return TroubleshootingToolsDiagnosticsApiDisableSpeedTestSessionRequest{
		ApiService: a,
		ctx: ctx,
		sessionId: sessionId,
	}
}

// Execute executes the request
func (a *TroubleshootingToolsDiagnosticsApiService) DisableSpeedTestSessionExecute(r TroubleshootingToolsDiagnosticsApiDisableSpeedTestSessionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TroubleshootingToolsDiagnosticsApiService.DisableSpeedTestSession")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stream/device/speed/disable/{sessionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"sessionId"+"}", url.PathEscape(parameterToString(r.sessionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type TroubleshootingToolsDiagnosticsApiDownloadDebugLogRequest struct {
	ctx context.Context
	ApiService *TroubleshootingToolsDiagnosticsApiService
	sessionId string
}

func (r TroubleshootingToolsDiagnosticsApiDownloadDebugLogRequest) Execute() (*http.Response, error) {
	return r.ApiService.DownloadDebugLogExecute(r)
}

/*
DownloadDebugLog Method for DownloadDebugLog

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sessionId Session Id
 @return TroubleshootingToolsDiagnosticsApiDownloadDebugLogRequest
*/
func (a *TroubleshootingToolsDiagnosticsApiService) DownloadDebugLog(ctx context.Context, sessionId string) TroubleshootingToolsDiagnosticsApiDownloadDebugLogRequest {
	return TroubleshootingToolsDiagnosticsApiDownloadDebugLogRequest{
		ApiService: a,
		ctx: ctx,
		sessionId: sessionId,
	}
}

// Execute executes the request
func (a *TroubleshootingToolsDiagnosticsApiService) DownloadDebugLogExecute(r TroubleshootingToolsDiagnosticsApiDownloadDebugLogRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TroubleshootingToolsDiagnosticsApiService.DownloadDebugLog")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stream/device/log/download/{sessionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"sessionId"+"}", url.PathEscape(parameterToString(r.sessionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type TroubleshootingToolsDiagnosticsApiDownloadFileRequest struct {
	ctx context.Context
	ApiService *TroubleshootingToolsDiagnosticsApiService
	sessionId Uuid
}

func (r TroubleshootingToolsDiagnosticsApiDownloadFileRequest) Execute() (*http.Response, error) {
	return r.ApiService.DownloadFileExecute(r)
}

/*
DownloadFile Method for DownloadFile

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sessionId
 @return TroubleshootingToolsDiagnosticsApiDownloadFileRequest
*/
func (a *TroubleshootingToolsDiagnosticsApiService) DownloadFile(ctx context.Context, sessionId Uuid) TroubleshootingToolsDiagnosticsApiDownloadFileRequest {
	return TroubleshootingToolsDiagnosticsApiDownloadFileRequest{
		ApiService: a,
		ctx: ctx,
		sessionId: sessionId,
	}
}

// Execute executes the request
func (a *TroubleshootingToolsDiagnosticsApiService) DownloadFileExecute(r TroubleshootingToolsDiagnosticsApiDownloadFileRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TroubleshootingToolsDiagnosticsApiService.DownloadFile")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stream/device/capture/download/{sessionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"sessionId"+"}", url.PathEscape(parameterToString(r.sessionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type TroubleshootingToolsDiagnosticsApiForceStopPcapSessionRequest struct {
	ctx context.Context
	ApiService *TroubleshootingToolsDiagnosticsApiService
	sessionId Uuid
}

func (r TroubleshootingToolsDiagnosticsApiForceStopPcapSessionRequest) Execute() (*http.Response, error) {
	return r.ApiService.ForceStopPcapSessionExecute(r)
}

/*
ForceStopPcapSession Method for ForceStopPcapSession

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sessionId
 @return TroubleshootingToolsDiagnosticsApiForceStopPcapSessionRequest
*/
func (a *TroubleshootingToolsDiagnosticsApiService) ForceStopPcapSession(ctx context.Context, sessionId Uuid) TroubleshootingToolsDiagnosticsApiForceStopPcapSessionRequest {
	return TroubleshootingToolsDiagnosticsApiForceStopPcapSessionRequest{
		ApiService: a,
		ctx: ctx,
		sessionId: sessionId,
	}
}

// Execute executes the request
func (a *TroubleshootingToolsDiagnosticsApiService) ForceStopPcapSessionExecute(r TroubleshootingToolsDiagnosticsApiForceStopPcapSessionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TroubleshootingToolsDiagnosticsApiService.ForceStopPcapSession")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stream/device/capture/forcedisbale/{sessionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"sessionId"+"}", url.PathEscape(parameterToString(r.sessionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type TroubleshootingToolsDiagnosticsApiFormPostPacketCaptureRequest struct {
	ctx context.Context
	ApiService *TroubleshootingToolsDiagnosticsApiService
	deviceUUID string
	sessionId Uuid
}

func (r TroubleshootingToolsDiagnosticsApiFormPostPacketCaptureRequest) Execute() (*http.Response, error) {
	return r.ApiService.FormPostPacketCaptureExecute(r)
}

/*
FormPostPacketCapture Method for FormPostPacketCapture

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceUUID
 @param sessionId
 @return TroubleshootingToolsDiagnosticsApiFormPostPacketCaptureRequest
*/
func (a *TroubleshootingToolsDiagnosticsApiService) FormPostPacketCapture(ctx context.Context, deviceUUID string, sessionId Uuid) TroubleshootingToolsDiagnosticsApiFormPostPacketCaptureRequest {
	return TroubleshootingToolsDiagnosticsApiFormPostPacketCaptureRequest{
		ApiService: a,
		ctx: ctx,
		deviceUUID: deviceUUID,
		sessionId: sessionId,
	}
}

// Execute executes the request
func (a *TroubleshootingToolsDiagnosticsApiService) FormPostPacketCaptureExecute(r TroubleshootingToolsDiagnosticsApiFormPostPacketCaptureRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TroubleshootingToolsDiagnosticsApiService.FormPostPacketCapture")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stream/device/capture/{deviceUUID}/{sessionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceUUID"+"}", url.PathEscape(parameterToString(r.deviceUUID, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sessionId"+"}", url.PathEscape(parameterToString(r.sessionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type TroubleshootingToolsDiagnosticsApiGetAggregationDataByQuery27Request struct {
	ctx context.Context
	ApiService *TroubleshootingToolsDiagnosticsApiService
	query *string
}

// Query filter
func (r TroubleshootingToolsDiagnosticsApiGetAggregationDataByQuery27Request) Query(query string) TroubleshootingToolsDiagnosticsApiGetAggregationDataByQuery27Request {
	r.query = &query
	return r
}

func (r TroubleshootingToolsDiagnosticsApiGetAggregationDataByQuery27Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetAggregationDataByQuery27Execute(r)
}

/*
GetAggregationDataByQuery27 Method for GetAggregationDataByQuery27

Get aggregated data based on input query and filters. The data can be filtered on time and other unique parameters based upon necessity and intended usage

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TroubleshootingToolsDiagnosticsApiGetAggregationDataByQuery27Request
*/
func (a *TroubleshootingToolsDiagnosticsApiService) GetAggregationDataByQuery27(ctx context.Context) TroubleshootingToolsDiagnosticsApiGetAggregationDataByQuery27Request {
	return TroubleshootingToolsDiagnosticsApiGetAggregationDataByQuery27Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *TroubleshootingToolsDiagnosticsApiService) GetAggregationDataByQuery27Execute(r TroubleshootingToolsDiagnosticsApiGetAggregationDataByQuery27Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TroubleshootingToolsDiagnosticsApiService.GetAggregationDataByQuery27")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stream/device/nwpi/aggregation"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.query != nil {
		localVarQueryParams.Add("query", parameterToString(*r.query, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TroubleshootingToolsDiagnosticsApiGetAggregationDataByQuery28Request struct {
	ctx context.Context
	ApiService *TroubleshootingToolsDiagnosticsApiService
	query *string
}

// Query filter
func (r TroubleshootingToolsDiagnosticsApiGetAggregationDataByQuery28Request) Query(query string) TroubleshootingToolsDiagnosticsApiGetAggregationDataByQuery28Request {
	r.query = &query
	return r
}

func (r TroubleshootingToolsDiagnosticsApiGetAggregationDataByQuery28Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetAggregationDataByQuery28Execute(r)
}

/*
GetAggregationDataByQuery28 Method for GetAggregationDataByQuery28

Get aggregated data based on input query and filters. The data can be filtered on time and other unique parameters based upon necessity and intended usage

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TroubleshootingToolsDiagnosticsApiGetAggregationDataByQuery28Request
*/
func (a *TroubleshootingToolsDiagnosticsApiService) GetAggregationDataByQuery28(ctx context.Context) TroubleshootingToolsDiagnosticsApiGetAggregationDataByQuery28Request {
	return TroubleshootingToolsDiagnosticsApiGetAggregationDataByQuery28Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *TroubleshootingToolsDiagnosticsApiService) GetAggregationDataByQuery28Execute(r TroubleshootingToolsDiagnosticsApiGetAggregationDataByQuery28Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TroubleshootingToolsDiagnosticsApiService.GetAggregationDataByQuery28")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/statistics/speedtest/aggregation"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.query != nil {
		localVarQueryParams.Add("query", parameterToString(*r.query, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TroubleshootingToolsDiagnosticsApiGetConcurrentDataRequest struct {
	ctx context.Context
	ApiService *TroubleshootingToolsDiagnosticsApiService
	traceId *int32
	timestamp *int64
}

// trace id
func (r TroubleshootingToolsDiagnosticsApiGetConcurrentDataRequest) TraceId(traceId int32) TroubleshootingToolsDiagnosticsApiGetConcurrentDataRequest {
	r.traceId = &traceId
	return r
}

// start time
func (r TroubleshootingToolsDiagnosticsApiGetConcurrentDataRequest) Timestamp(timestamp int64) TroubleshootingToolsDiagnosticsApiGetConcurrentDataRequest {
	r.timestamp = &timestamp
	return r
}

func (r TroubleshootingToolsDiagnosticsApiGetConcurrentDataRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetConcurrentDataExecute(r)
}

/*
GetConcurrentData Method for GetConcurrentData

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TroubleshootingToolsDiagnosticsApiGetConcurrentDataRequest
*/
func (a *TroubleshootingToolsDiagnosticsApiService) GetConcurrentData(ctx context.Context) TroubleshootingToolsDiagnosticsApiGetConcurrentDataRequest {
	return TroubleshootingToolsDiagnosticsApiGetConcurrentDataRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *TroubleshootingToolsDiagnosticsApiService) GetConcurrentDataExecute(r TroubleshootingToolsDiagnosticsApiGetConcurrentDataRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TroubleshootingToolsDiagnosticsApiService.GetConcurrentData")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stream/device/nwpi/concurrentData"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.traceId == nil {
		return nil, reportError("traceId is required and must be specified")
	}
	if r.timestamp == nil {
		return nil, reportError("timestamp is required and must be specified")
	}

	localVarQueryParams.Add("traceId", parameterToString(*r.traceId, ""))
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type TroubleshootingToolsDiagnosticsApiGetConcurrentDomainDataRequest struct {
	ctx context.Context
	ApiService *TroubleshootingToolsDiagnosticsApiService
	traceId *int32
	timestamp *int64
}

// trace id
func (r TroubleshootingToolsDiagnosticsApiGetConcurrentDomainDataRequest) TraceId(traceId int32) TroubleshootingToolsDiagnosticsApiGetConcurrentDomainDataRequest {
	r.traceId = &traceId
	return r
}

// start time
func (r TroubleshootingToolsDiagnosticsApiGetConcurrentDomainDataRequest) Timestamp(timestamp int64) TroubleshootingToolsDiagnosticsApiGetConcurrentDomainDataRequest {
	r.timestamp = &timestamp
	return r
}

func (r TroubleshootingToolsDiagnosticsApiGetConcurrentDomainDataRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetConcurrentDomainDataExecute(r)
}

/*
GetConcurrentDomainData Method for GetConcurrentDomainData

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TroubleshootingToolsDiagnosticsApiGetConcurrentDomainDataRequest
*/
func (a *TroubleshootingToolsDiagnosticsApiService) GetConcurrentDomainData(ctx context.Context) TroubleshootingToolsDiagnosticsApiGetConcurrentDomainDataRequest {
	return TroubleshootingToolsDiagnosticsApiGetConcurrentDomainDataRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *TroubleshootingToolsDiagnosticsApiService) GetConcurrentDomainDataExecute(r TroubleshootingToolsDiagnosticsApiGetConcurrentDomainDataRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TroubleshootingToolsDiagnosticsApiService.GetConcurrentDomainData")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stream/device/nwpi/concurrentDomainData"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.traceId == nil {
		return nil, reportError("traceId is required and must be specified")
	}
	if r.timestamp == nil {
		return nil, reportError("timestamp is required and must be specified")
	}

	localVarQueryParams.Add("traceId", parameterToString(*r.traceId, ""))
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type TroubleshootingToolsDiagnosticsApiGetCount29Request struct {
	ctx context.Context
	ApiService *TroubleshootingToolsDiagnosticsApiService
	query *string
}

// Query
func (r TroubleshootingToolsDiagnosticsApiGetCount29Request) Query(query string) TroubleshootingToolsDiagnosticsApiGetCount29Request {
	r.query = &query
	return r
}

func (r TroubleshootingToolsDiagnosticsApiGetCount29Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetCount29Execute(r)
}

/*
GetCount29 Method for GetCount29

Get response count of a query

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TroubleshootingToolsDiagnosticsApiGetCount29Request
*/
func (a *TroubleshootingToolsDiagnosticsApiService) GetCount29(ctx context.Context) TroubleshootingToolsDiagnosticsApiGetCount29Request {
	return TroubleshootingToolsDiagnosticsApiGetCount29Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *TroubleshootingToolsDiagnosticsApiService) GetCount29Execute(r TroubleshootingToolsDiagnosticsApiGetCount29Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TroubleshootingToolsDiagnosticsApiService.GetCount29")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stream/device/nwpi/doccount"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.query == nil {
		return localVarReturnValue, nil, reportError("query is required and must be specified")
	}

	localVarQueryParams.Add("query", parameterToString(*r.query, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TroubleshootingToolsDiagnosticsApiGetCount30Request struct {
	ctx context.Context
	ApiService *TroubleshootingToolsDiagnosticsApiService
	query *string
}

// Query
func (r TroubleshootingToolsDiagnosticsApiGetCount30Request) Query(query string) TroubleshootingToolsDiagnosticsApiGetCount30Request {
	r.query = &query
	return r
}

func (r TroubleshootingToolsDiagnosticsApiGetCount30Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetCount30Execute(r)
}

/*
GetCount30 Method for GetCount30

Get response count of a query

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TroubleshootingToolsDiagnosticsApiGetCount30Request
*/
func (a *TroubleshootingToolsDiagnosticsApiService) GetCount30(ctx context.Context) TroubleshootingToolsDiagnosticsApiGetCount30Request {
	return TroubleshootingToolsDiagnosticsApiGetCount30Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *TroubleshootingToolsDiagnosticsApiService) GetCount30Execute(r TroubleshootingToolsDiagnosticsApiGetCount30Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TroubleshootingToolsDiagnosticsApiService.GetCount30")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/statistics/speedtest/doccount"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.query == nil {
		return localVarReturnValue, nil, reportError("query is required and must be specified")
	}

	localVarQueryParams.Add("query", parameterToString(*r.query, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TroubleshootingToolsDiagnosticsApiGetCountPost29Request struct {
	ctx context.Context
	ApiService *TroubleshootingToolsDiagnosticsApiService
	body *map[string]interface{}
}

// Query
func (r TroubleshootingToolsDiagnosticsApiGetCountPost29Request) Body(body map[string]interface{}) TroubleshootingToolsDiagnosticsApiGetCountPost29Request {
	r.body = &body
	return r
}

func (r TroubleshootingToolsDiagnosticsApiGetCountPost29Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetCountPost29Execute(r)
}

/*
GetCountPost29 Method for GetCountPost29

Get response count of a query

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TroubleshootingToolsDiagnosticsApiGetCountPost29Request
*/
func (a *TroubleshootingToolsDiagnosticsApiService) GetCountPost29(ctx context.Context) TroubleshootingToolsDiagnosticsApiGetCountPost29Request {
	return TroubleshootingToolsDiagnosticsApiGetCountPost29Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *TroubleshootingToolsDiagnosticsApiService) GetCountPost29Execute(r TroubleshootingToolsDiagnosticsApiGetCountPost29Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TroubleshootingToolsDiagnosticsApiService.GetCountPost29")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stream/device/nwpi/doccount"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TroubleshootingToolsDiagnosticsApiGetCountPost30Request struct {
	ctx context.Context
	ApiService *TroubleshootingToolsDiagnosticsApiService
	body *map[string]interface{}
}

// Query
func (r TroubleshootingToolsDiagnosticsApiGetCountPost30Request) Body(body map[string]interface{}) TroubleshootingToolsDiagnosticsApiGetCountPost30Request {
	r.body = &body
	return r
}

func (r TroubleshootingToolsDiagnosticsApiGetCountPost30Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetCountPost30Execute(r)
}

/*
GetCountPost30 Method for GetCountPost30

Get response count of a query

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TroubleshootingToolsDiagnosticsApiGetCountPost30Request
*/
func (a *TroubleshootingToolsDiagnosticsApiService) GetCountPost30(ctx context.Context) TroubleshootingToolsDiagnosticsApiGetCountPost30Request {
	return TroubleshootingToolsDiagnosticsApiGetCountPost30Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *TroubleshootingToolsDiagnosticsApiService) GetCountPost30Execute(r TroubleshootingToolsDiagnosticsApiGetCountPost30Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TroubleshootingToolsDiagnosticsApiService.GetCountPost30")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/statistics/speedtest/doccount"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TroubleshootingToolsDiagnosticsApiGetDBSchemaRequest struct {
	ctx context.Context
	ApiService *TroubleshootingToolsDiagnosticsApiService
}

func (r TroubleshootingToolsDiagnosticsApiGetDBSchemaRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetDBSchemaExecute(r)
}

/*
GetDBSchema Method for GetDBSchema

Get the current database schema

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TroubleshootingToolsDiagnosticsApiGetDBSchemaRequest
*/
func (a *TroubleshootingToolsDiagnosticsApiService) GetDBSchema(ctx context.Context) TroubleshootingToolsDiagnosticsApiGetDBSchemaRequest {
	return TroubleshootingToolsDiagnosticsApiGetDBSchemaRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *TroubleshootingToolsDiagnosticsApiService) GetDBSchemaExecute(r TroubleshootingToolsDiagnosticsApiGetDBSchemaRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TroubleshootingToolsDiagnosticsApiService.GetDBSchema")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/diagnostics/dbschema"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TroubleshootingToolsDiagnosticsApiGetDeviceLogRequest struct {
	ctx context.Context
	ApiService *TroubleshootingToolsDiagnosticsApiService
	sessionId Uuid
	logId *int64
}

func (r TroubleshootingToolsDiagnosticsApiGetDeviceLogRequest) LogId(logId int64) TroubleshootingToolsDiagnosticsApiGetDeviceLogRequest {
	r.logId = &logId
	return r
}

func (r TroubleshootingToolsDiagnosticsApiGetDeviceLogRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetDeviceLogExecute(r)
}

/*
GetDeviceLog Method for GetDeviceLog

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sessionId
 @return TroubleshootingToolsDiagnosticsApiGetDeviceLogRequest
*/
func (a *TroubleshootingToolsDiagnosticsApiService) GetDeviceLog(ctx context.Context, sessionId Uuid) TroubleshootingToolsDiagnosticsApiGetDeviceLogRequest {
	return TroubleshootingToolsDiagnosticsApiGetDeviceLogRequest{
		ApiService: a,
		ctx: ctx,
		sessionId: sessionId,
	}
}

// Execute executes the request
func (a *TroubleshootingToolsDiagnosticsApiService) GetDeviceLogExecute(r TroubleshootingToolsDiagnosticsApiGetDeviceLogRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TroubleshootingToolsDiagnosticsApiService.GetDeviceLog")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stream/device/log/{sessionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"sessionId"+"}", url.PathEscape(parameterToString(r.sessionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.logId != nil {
		localVarQueryParams.Add("logId", parameterToString(*r.logId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type TroubleshootingToolsDiagnosticsApiGetDomainMetricRequest struct {
	ctx context.Context
	ApiService *TroubleshootingToolsDiagnosticsApiService
	traceId *int32
	timestamp *int64
	domain *string
	firstTimestamp *int64
	lastTimestamp *int64
}

// trace id
func (r TroubleshootingToolsDiagnosticsApiGetDomainMetricRequest) TraceId(traceId int32) TroubleshootingToolsDiagnosticsApiGetDomainMetricRequest {
	r.traceId = &traceId
	return r
}

// start time
func (r TroubleshootingToolsDiagnosticsApiGetDomainMetricRequest) Timestamp(timestamp int64) TroubleshootingToolsDiagnosticsApiGetDomainMetricRequest {
	r.timestamp = &timestamp
	return r
}

// domain name
func (r TroubleshootingToolsDiagnosticsApiGetDomainMetricRequest) Domain(domain string) TroubleshootingToolsDiagnosticsApiGetDomainMetricRequest {
	r.domain = &domain
	return r
}

// first timestamp of xAxis
func (r TroubleshootingToolsDiagnosticsApiGetDomainMetricRequest) FirstTimestamp(firstTimestamp int64) TroubleshootingToolsDiagnosticsApiGetDomainMetricRequest {
	r.firstTimestamp = &firstTimestamp
	return r
}

// last timestamp of xAxis
func (r TroubleshootingToolsDiagnosticsApiGetDomainMetricRequest) LastTimestamp(lastTimestamp int64) TroubleshootingToolsDiagnosticsApiGetDomainMetricRequest {
	r.lastTimestamp = &lastTimestamp
	return r
}

func (r TroubleshootingToolsDiagnosticsApiGetDomainMetricRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetDomainMetricExecute(r)
}

/*
GetDomainMetric Method for GetDomainMetric

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TroubleshootingToolsDiagnosticsApiGetDomainMetricRequest
*/
func (a *TroubleshootingToolsDiagnosticsApiService) GetDomainMetric(ctx context.Context) TroubleshootingToolsDiagnosticsApiGetDomainMetricRequest {
	return TroubleshootingToolsDiagnosticsApiGetDomainMetricRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *TroubleshootingToolsDiagnosticsApiService) GetDomainMetricExecute(r TroubleshootingToolsDiagnosticsApiGetDomainMetricRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TroubleshootingToolsDiagnosticsApiService.GetDomainMetric")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stream/device/nwpi/domainMetric"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.traceId == nil {
		return nil, reportError("traceId is required and must be specified")
	}
	if r.timestamp == nil {
		return nil, reportError("timestamp is required and must be specified")
	}
	if r.domain == nil {
		return nil, reportError("domain is required and must be specified")
	}
	if r.firstTimestamp == nil {
		return nil, reportError("firstTimestamp is required and must be specified")
	}
	if r.lastTimestamp == nil {
		return nil, reportError("lastTimestamp is required and must be specified")
	}

	localVarQueryParams.Add("traceId", parameterToString(*r.traceId, ""))
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("domain", parameterToString(*r.domain, ""))
	localVarQueryParams.Add("firstTimestamp", parameterToString(*r.firstTimestamp, ""))
	localVarQueryParams.Add("lastTimestamp", parameterToString(*r.lastTimestamp, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type TroubleshootingToolsDiagnosticsApiGetFileDownloadStatusRequest struct {
	ctx context.Context
	ApiService *TroubleshootingToolsDiagnosticsApiService
	sessionId Uuid
}

func (r TroubleshootingToolsDiagnosticsApiGetFileDownloadStatusRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetFileDownloadStatusExecute(r)
}

/*
GetFileDownloadStatus Method for GetFileDownloadStatus

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sessionId
 @return TroubleshootingToolsDiagnosticsApiGetFileDownloadStatusRequest
*/
func (a *TroubleshootingToolsDiagnosticsApiService) GetFileDownloadStatus(ctx context.Context, sessionId Uuid) TroubleshootingToolsDiagnosticsApiGetFileDownloadStatusRequest {
	return TroubleshootingToolsDiagnosticsApiGetFileDownloadStatusRequest{
		ApiService: a,
		ctx: ctx,
		sessionId: sessionId,
	}
}

// Execute executes the request
func (a *TroubleshootingToolsDiagnosticsApiService) GetFileDownloadStatusExecute(r TroubleshootingToolsDiagnosticsApiGetFileDownloadStatusRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TroubleshootingToolsDiagnosticsApiService.GetFileDownloadStatus")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stream/device/capture/status/{sessionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"sessionId"+"}", url.PathEscape(parameterToString(r.sessionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type TroubleshootingToolsDiagnosticsApiGetFinalizedDataRequest struct {
	ctx context.Context
	ApiService *TroubleshootingToolsDiagnosticsApiService
	traceId *int32
	timestamp *int64
}

// trace id
func (r TroubleshootingToolsDiagnosticsApiGetFinalizedDataRequest) TraceId(traceId int32) TroubleshootingToolsDiagnosticsApiGetFinalizedDataRequest {
	r.traceId = &traceId
	return r
}

// start time
func (r TroubleshootingToolsDiagnosticsApiGetFinalizedDataRequest) Timestamp(timestamp int64) TroubleshootingToolsDiagnosticsApiGetFinalizedDataRequest {
	r.timestamp = &timestamp
	return r
}

func (r TroubleshootingToolsDiagnosticsApiGetFinalizedDataRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetFinalizedDataExecute(r)
}

/*
GetFinalizedData Method for GetFinalizedData

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TroubleshootingToolsDiagnosticsApiGetFinalizedDataRequest
*/
func (a *TroubleshootingToolsDiagnosticsApiService) GetFinalizedData(ctx context.Context) TroubleshootingToolsDiagnosticsApiGetFinalizedDataRequest {
	return TroubleshootingToolsDiagnosticsApiGetFinalizedDataRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *TroubleshootingToolsDiagnosticsApiService) GetFinalizedDataExecute(r TroubleshootingToolsDiagnosticsApiGetFinalizedDataRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TroubleshootingToolsDiagnosticsApiService.GetFinalizedData")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stream/device/nwpi/finalizedData"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.traceId == nil {
		return nil, reportError("traceId is required and must be specified")
	}
	if r.timestamp == nil {
		return nil, reportError("timestamp is required and must be specified")
	}

	localVarQueryParams.Add("traceId", parameterToString(*r.traceId, ""))
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type TroubleshootingToolsDiagnosticsApiGetFinalizedDomainDataRequest struct {
	ctx context.Context
	ApiService *TroubleshootingToolsDiagnosticsApiService
	traceId *int32
	timestamp *int64
}

// trace id
func (r TroubleshootingToolsDiagnosticsApiGetFinalizedDomainDataRequest) TraceId(traceId int32) TroubleshootingToolsDiagnosticsApiGetFinalizedDomainDataRequest {
	r.traceId = &traceId
	return r
}

// start time
func (r TroubleshootingToolsDiagnosticsApiGetFinalizedDomainDataRequest) Timestamp(timestamp int64) TroubleshootingToolsDiagnosticsApiGetFinalizedDomainDataRequest {
	r.timestamp = &timestamp
	return r
}

func (r TroubleshootingToolsDiagnosticsApiGetFinalizedDomainDataRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetFinalizedDomainDataExecute(r)
}

/*
GetFinalizedDomainData Method for GetFinalizedDomainData

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TroubleshootingToolsDiagnosticsApiGetFinalizedDomainDataRequest
*/
func (a *TroubleshootingToolsDiagnosticsApiService) GetFinalizedDomainData(ctx context.Context) TroubleshootingToolsDiagnosticsApiGetFinalizedDomainDataRequest {
	return TroubleshootingToolsDiagnosticsApiGetFinalizedDomainDataRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *TroubleshootingToolsDiagnosticsApiService) GetFinalizedDomainDataExecute(r TroubleshootingToolsDiagnosticsApiGetFinalizedDomainDataRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TroubleshootingToolsDiagnosticsApiService.GetFinalizedDomainData")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stream/device/nwpi/finalizedDomainData"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.traceId == nil {
		return nil, reportError("traceId is required and must be specified")
	}
	if r.timestamp == nil {
		return nil, reportError("timestamp is required and must be specified")
	}

	localVarQueryParams.Add("traceId", parameterToString(*r.traceId, ""))
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type TroubleshootingToolsDiagnosticsApiGetFlowDetailRequest struct {
	ctx context.Context
	ApiService *TroubleshootingToolsDiagnosticsApiService
	traceId *int32
	timestamp *int64
	flowId *int32
}

// trace id
func (r TroubleshootingToolsDiagnosticsApiGetFlowDetailRequest) TraceId(traceId int32) TroubleshootingToolsDiagnosticsApiGetFlowDetailRequest {
	r.traceId = &traceId
	return r
}

// start time
func (r TroubleshootingToolsDiagnosticsApiGetFlowDetailRequest) Timestamp(timestamp int64) TroubleshootingToolsDiagnosticsApiGetFlowDetailRequest {
	r.timestamp = &timestamp
	return r
}

// flow id
func (r TroubleshootingToolsDiagnosticsApiGetFlowDetailRequest) FlowId(flowId int32) TroubleshootingToolsDiagnosticsApiGetFlowDetailRequest {
	r.flowId = &flowId
	return r
}

func (r TroubleshootingToolsDiagnosticsApiGetFlowDetailRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetFlowDetailExecute(r)
}

/*
GetFlowDetail Method for GetFlowDetail

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TroubleshootingToolsDiagnosticsApiGetFlowDetailRequest
*/
func (a *TroubleshootingToolsDiagnosticsApiService) GetFlowDetail(ctx context.Context) TroubleshootingToolsDiagnosticsApiGetFlowDetailRequest {
	return TroubleshootingToolsDiagnosticsApiGetFlowDetailRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *TroubleshootingToolsDiagnosticsApiService) GetFlowDetailExecute(r TroubleshootingToolsDiagnosticsApiGetFlowDetailRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TroubleshootingToolsDiagnosticsApiService.GetFlowDetail")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stream/device/nwpi/flowDetail"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.traceId == nil {
		return nil, reportError("traceId is required and must be specified")
	}
	if r.timestamp == nil {
		return nil, reportError("timestamp is required and must be specified")
	}
	if r.flowId == nil {
		return nil, reportError("flowId is required and must be specified")
	}

	localVarQueryParams.Add("traceId", parameterToString(*r.traceId, ""))
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("flowId", parameterToString(*r.flowId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type TroubleshootingToolsDiagnosticsApiGetFlowMetricRequest struct {
	ctx context.Context
	ApiService *TroubleshootingToolsDiagnosticsApiService
	traceId *int32
	timestamp *int64
	flowId *int32
	firstTimestamp *int64
	lastTimestamp *int64
}

// trace id
func (r TroubleshootingToolsDiagnosticsApiGetFlowMetricRequest) TraceId(traceId int32) TroubleshootingToolsDiagnosticsApiGetFlowMetricRequest {
	r.traceId = &traceId
	return r
}

// start time
func (r TroubleshootingToolsDiagnosticsApiGetFlowMetricRequest) Timestamp(timestamp int64) TroubleshootingToolsDiagnosticsApiGetFlowMetricRequest {
	r.timestamp = &timestamp
	return r
}

// flow id
func (r TroubleshootingToolsDiagnosticsApiGetFlowMetricRequest) FlowId(flowId int32) TroubleshootingToolsDiagnosticsApiGetFlowMetricRequest {
	r.flowId = &flowId
	return r
}

// first timestamp of xAxis
func (r TroubleshootingToolsDiagnosticsApiGetFlowMetricRequest) FirstTimestamp(firstTimestamp int64) TroubleshootingToolsDiagnosticsApiGetFlowMetricRequest {
	r.firstTimestamp = &firstTimestamp
	return r
}

// last timestamp of xAxis
func (r TroubleshootingToolsDiagnosticsApiGetFlowMetricRequest) LastTimestamp(lastTimestamp int64) TroubleshootingToolsDiagnosticsApiGetFlowMetricRequest {
	r.lastTimestamp = &lastTimestamp
	return r
}

func (r TroubleshootingToolsDiagnosticsApiGetFlowMetricRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetFlowMetricExecute(r)
}

/*
GetFlowMetric Method for GetFlowMetric

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TroubleshootingToolsDiagnosticsApiGetFlowMetricRequest
*/
func (a *TroubleshootingToolsDiagnosticsApiService) GetFlowMetric(ctx context.Context) TroubleshootingToolsDiagnosticsApiGetFlowMetricRequest {
	return TroubleshootingToolsDiagnosticsApiGetFlowMetricRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *TroubleshootingToolsDiagnosticsApiService) GetFlowMetricExecute(r TroubleshootingToolsDiagnosticsApiGetFlowMetricRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TroubleshootingToolsDiagnosticsApiService.GetFlowMetric")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stream/device/nwpi/flowMetric"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.traceId == nil {
		return nil, reportError("traceId is required and must be specified")
	}
	if r.timestamp == nil {
		return nil, reportError("timestamp is required and must be specified")
	}
	if r.flowId == nil {
		return nil, reportError("flowId is required and must be specified")
	}
	if r.firstTimestamp == nil {
		return nil, reportError("firstTimestamp is required and must be specified")
	}
	if r.lastTimestamp == nil {
		return nil, reportError("lastTimestamp is required and must be specified")
	}

	localVarQueryParams.Add("traceId", parameterToString(*r.traceId, ""))
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("flowId", parameterToString(*r.flowId, ""))
	localVarQueryParams.Add("firstTimestamp", parameterToString(*r.firstTimestamp, ""))
	localVarQueryParams.Add("lastTimestamp", parameterToString(*r.lastTimestamp, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type TroubleshootingToolsDiagnosticsApiGetInterfaceBandwidthRequest struct {
	ctx context.Context
	ApiService *TroubleshootingToolsDiagnosticsApiService
	circuit *string
	deviceUUID *DeviceUuid
}

func (r TroubleshootingToolsDiagnosticsApiGetInterfaceBandwidthRequest) Circuit(circuit string) TroubleshootingToolsDiagnosticsApiGetInterfaceBandwidthRequest {
	r.circuit = &circuit
	return r
}

func (r TroubleshootingToolsDiagnosticsApiGetInterfaceBandwidthRequest) DeviceUUID(deviceUUID DeviceUuid) TroubleshootingToolsDiagnosticsApiGetInterfaceBandwidthRequest {
	r.deviceUUID = &deviceUUID
	return r
}

func (r TroubleshootingToolsDiagnosticsApiGetInterfaceBandwidthRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetInterfaceBandwidthExecute(r)
}

/*
GetInterfaceBandwidth Method for GetInterfaceBandwidth

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TroubleshootingToolsDiagnosticsApiGetInterfaceBandwidthRequest
*/
func (a *TroubleshootingToolsDiagnosticsApiService) GetInterfaceBandwidth(ctx context.Context) TroubleshootingToolsDiagnosticsApiGetInterfaceBandwidthRequest {
	return TroubleshootingToolsDiagnosticsApiGetInterfaceBandwidthRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *TroubleshootingToolsDiagnosticsApiService) GetInterfaceBandwidthExecute(r TroubleshootingToolsDiagnosticsApiGetInterfaceBandwidthRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TroubleshootingToolsDiagnosticsApiService.GetInterfaceBandwidth")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stream/device/speed/interface/bandwidth"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.circuit == nil {
		return nil, reportError("circuit is required and must be specified")
	}
	if r.deviceUUID == nil {
		return nil, reportError("deviceUUID is required and must be specified")
	}

	localVarQueryParams.Add("circuit", parameterToString(*r.circuit, ""))
	localVarQueryParams.Add("deviceUUID", parameterToString(*r.deviceUUID, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type TroubleshootingToolsDiagnosticsApiGetLogTypeRequest struct {
	ctx context.Context
	ApiService *TroubleshootingToolsDiagnosticsApiService
	uuid *string
}

// Device uuid
func (r TroubleshootingToolsDiagnosticsApiGetLogTypeRequest) Uuid(uuid string) TroubleshootingToolsDiagnosticsApiGetLogTypeRequest {
	r.uuid = &uuid
	return r
}

func (r TroubleshootingToolsDiagnosticsApiGetLogTypeRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetLogTypeExecute(r)
}

/*
GetLogType Method for GetLogType

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TroubleshootingToolsDiagnosticsApiGetLogTypeRequest
*/
func (a *TroubleshootingToolsDiagnosticsApiService) GetLogType(ctx context.Context) TroubleshootingToolsDiagnosticsApiGetLogTypeRequest {
	return TroubleshootingToolsDiagnosticsApiGetLogTypeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *TroubleshootingToolsDiagnosticsApiService) GetLogTypeExecute(r TroubleshootingToolsDiagnosticsApiGetLogTypeRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TroubleshootingToolsDiagnosticsApiService.GetLogType")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stream/device/log/type"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.uuid == nil {
		return nil, reportError("uuid is required and must be specified")
	}

	localVarQueryParams.Add("uuid", parameterToString(*r.uuid, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type TroubleshootingToolsDiagnosticsApiGetMonitorStateRequest struct {
	ctx context.Context
	ApiService *TroubleshootingToolsDiagnosticsApiService
	traceId *int32
	state *string
}

// trace id
func (r TroubleshootingToolsDiagnosticsApiGetMonitorStateRequest) TraceId(traceId int32) TroubleshootingToolsDiagnosticsApiGetMonitorStateRequest {
	r.traceId = &traceId
	return r
}

// trace state
func (r TroubleshootingToolsDiagnosticsApiGetMonitorStateRequest) State(state string) TroubleshootingToolsDiagnosticsApiGetMonitorStateRequest {
	r.state = &state
	return r
}

func (r TroubleshootingToolsDiagnosticsApiGetMonitorStateRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetMonitorStateExecute(r)
}

/*
GetMonitorState Method for GetMonitorState

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TroubleshootingToolsDiagnosticsApiGetMonitorStateRequest
*/
func (a *TroubleshootingToolsDiagnosticsApiService) GetMonitorState(ctx context.Context) TroubleshootingToolsDiagnosticsApiGetMonitorStateRequest {
	return TroubleshootingToolsDiagnosticsApiGetMonitorStateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *TroubleshootingToolsDiagnosticsApiService) GetMonitorStateExecute(r TroubleshootingToolsDiagnosticsApiGetMonitorStateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TroubleshootingToolsDiagnosticsApiService.GetMonitorState")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stream/device/nwpi/getMonitorState"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.traceId == nil {
		return nil, reportError("traceId is required and must be specified")
	}
	if r.state == nil {
		return nil, reportError("state is required and must be specified")
	}

	localVarQueryParams.Add("traceId", parameterToString(*r.traceId, ""))
	localVarQueryParams.Add("state", parameterToString(*r.state, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type TroubleshootingToolsDiagnosticsApiGetNwpiDscpRequest struct {
	ctx context.Context
	ApiService *TroubleshootingToolsDiagnosticsApiService
}

func (r TroubleshootingToolsDiagnosticsApiGetNwpiDscpRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetNwpiDscpExecute(r)
}

/*
GetNwpiDscp Method for GetNwpiDscp

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TroubleshootingToolsDiagnosticsApiGetNwpiDscpRequest
*/
func (a *TroubleshootingToolsDiagnosticsApiService) GetNwpiDscp(ctx context.Context) TroubleshootingToolsDiagnosticsApiGetNwpiDscpRequest {
	return TroubleshootingToolsDiagnosticsApiGetNwpiDscpRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *TroubleshootingToolsDiagnosticsApiService) GetNwpiDscpExecute(r TroubleshootingToolsDiagnosticsApiGetNwpiDscpRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TroubleshootingToolsDiagnosticsApiService.GetNwpiDscp")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stream/device/nwpi/nwpiDSCP"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type TroubleshootingToolsDiagnosticsApiGetNwpiNbarAppGroupRequest struct {
	ctx context.Context
	ApiService *TroubleshootingToolsDiagnosticsApiService
}

func (r TroubleshootingToolsDiagnosticsApiGetNwpiNbarAppGroupRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetNwpiNbarAppGroupExecute(r)
}

/*
GetNwpiNbarAppGroup Method for GetNwpiNbarAppGroup

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TroubleshootingToolsDiagnosticsApiGetNwpiNbarAppGroupRequest
*/
func (a *TroubleshootingToolsDiagnosticsApiService) GetNwpiNbarAppGroup(ctx context.Context) TroubleshootingToolsDiagnosticsApiGetNwpiNbarAppGroupRequest {
	return TroubleshootingToolsDiagnosticsApiGetNwpiNbarAppGroupRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *TroubleshootingToolsDiagnosticsApiService) GetNwpiNbarAppGroupExecute(r TroubleshootingToolsDiagnosticsApiGetNwpiNbarAppGroupRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TroubleshootingToolsDiagnosticsApiService.GetNwpiNbarAppGroup")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stream/device/nwpi/nwpiNbarAppGroup"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type TroubleshootingToolsDiagnosticsApiGetNwpiProtocolRequest struct {
	ctx context.Context
	ApiService *TroubleshootingToolsDiagnosticsApiService
}

func (r TroubleshootingToolsDiagnosticsApiGetNwpiProtocolRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetNwpiProtocolExecute(r)
}

/*
GetNwpiProtocol Method for GetNwpiProtocol

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TroubleshootingToolsDiagnosticsApiGetNwpiProtocolRequest
*/
func (a *TroubleshootingToolsDiagnosticsApiService) GetNwpiProtocol(ctx context.Context) TroubleshootingToolsDiagnosticsApiGetNwpiProtocolRequest {
	return TroubleshootingToolsDiagnosticsApiGetNwpiProtocolRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *TroubleshootingToolsDiagnosticsApiService) GetNwpiProtocolExecute(r TroubleshootingToolsDiagnosticsApiGetNwpiProtocolRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TroubleshootingToolsDiagnosticsApiService.GetNwpiProtocol")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stream/device/nwpi/nwpiProtocol"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type TroubleshootingToolsDiagnosticsApiGetPacketFeaturesRequest struct {
	ctx context.Context
	ApiService *TroubleshootingToolsDiagnosticsApiService
	traceId *int32
	timestamp *int64
	flowId *int32
}

// trace id
func (r TroubleshootingToolsDiagnosticsApiGetPacketFeaturesRequest) TraceId(traceId int32) TroubleshootingToolsDiagnosticsApiGetPacketFeaturesRequest {
	r.traceId = &traceId
	return r
}

// start time
func (r TroubleshootingToolsDiagnosticsApiGetPacketFeaturesRequest) Timestamp(timestamp int64) TroubleshootingToolsDiagnosticsApiGetPacketFeaturesRequest {
	r.timestamp = &timestamp
	return r
}

// flow id
func (r TroubleshootingToolsDiagnosticsApiGetPacketFeaturesRequest) FlowId(flowId int32) TroubleshootingToolsDiagnosticsApiGetPacketFeaturesRequest {
	r.flowId = &flowId
	return r
}

func (r TroubleshootingToolsDiagnosticsApiGetPacketFeaturesRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetPacketFeaturesExecute(r)
}

/*
GetPacketFeatures Method for GetPacketFeatures

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TroubleshootingToolsDiagnosticsApiGetPacketFeaturesRequest
*/
func (a *TroubleshootingToolsDiagnosticsApiService) GetPacketFeatures(ctx context.Context) TroubleshootingToolsDiagnosticsApiGetPacketFeaturesRequest {
	return TroubleshootingToolsDiagnosticsApiGetPacketFeaturesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *TroubleshootingToolsDiagnosticsApiService) GetPacketFeaturesExecute(r TroubleshootingToolsDiagnosticsApiGetPacketFeaturesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TroubleshootingToolsDiagnosticsApiService.GetPacketFeatures")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stream/device/nwpi/packetFeatures"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.traceId == nil {
		return nil, reportError("traceId is required and must be specified")
	}
	if r.timestamp == nil {
		return nil, reportError("timestamp is required and must be specified")
	}
	if r.flowId == nil {
		return nil, reportError("flowId is required and must be specified")
	}

	localVarQueryParams.Add("traceId", parameterToString(*r.traceId, ""))
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("flowId", parameterToString(*r.flowId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type TroubleshootingToolsDiagnosticsApiGetPostAggregationAppDataByQuery26Request struct {
	ctx context.Context
	ApiService *TroubleshootingToolsDiagnosticsApiService
	body *map[string]interface{}
}

// Stats query string
func (r TroubleshootingToolsDiagnosticsApiGetPostAggregationAppDataByQuery26Request) Body(body map[string]interface{}) TroubleshootingToolsDiagnosticsApiGetPostAggregationAppDataByQuery26Request {
	r.body = &body
	return r
}

func (r TroubleshootingToolsDiagnosticsApiGetPostAggregationAppDataByQuery26Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetPostAggregationAppDataByQuery26Execute(r)
}

/*
GetPostAggregationAppDataByQuery26 Method for GetPostAggregationAppDataByQuery26

Get aggregated data based on input query and filters. The data can be filtered on time and other unique parameters based upon necessity and intended usage

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TroubleshootingToolsDiagnosticsApiGetPostAggregationAppDataByQuery26Request
*/
func (a *TroubleshootingToolsDiagnosticsApiService) GetPostAggregationAppDataByQuery26(ctx context.Context) TroubleshootingToolsDiagnosticsApiGetPostAggregationAppDataByQuery26Request {
	return TroubleshootingToolsDiagnosticsApiGetPostAggregationAppDataByQuery26Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *TroubleshootingToolsDiagnosticsApiService) GetPostAggregationAppDataByQuery26Execute(r TroubleshootingToolsDiagnosticsApiGetPostAggregationAppDataByQuery26Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TroubleshootingToolsDiagnosticsApiService.GetPostAggregationAppDataByQuery26")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stream/device/nwpi/app-agg/aggregation"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TroubleshootingToolsDiagnosticsApiGetPostAggregationAppDataByQuery27Request struct {
	ctx context.Context
	ApiService *TroubleshootingToolsDiagnosticsApiService
	body *map[string]interface{}
}

// Stats query string
func (r TroubleshootingToolsDiagnosticsApiGetPostAggregationAppDataByQuery27Request) Body(body map[string]interface{}) TroubleshootingToolsDiagnosticsApiGetPostAggregationAppDataByQuery27Request {
	r.body = &body
	return r
}

func (r TroubleshootingToolsDiagnosticsApiGetPostAggregationAppDataByQuery27Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetPostAggregationAppDataByQuery27Execute(r)
}

/*
GetPostAggregationAppDataByQuery27 Method for GetPostAggregationAppDataByQuery27

Get aggregated data based on input query and filters. The data can be filtered on time and other unique parameters based upon necessity and intended usage

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TroubleshootingToolsDiagnosticsApiGetPostAggregationAppDataByQuery27Request
*/
func (a *TroubleshootingToolsDiagnosticsApiService) GetPostAggregationAppDataByQuery27(ctx context.Context) TroubleshootingToolsDiagnosticsApiGetPostAggregationAppDataByQuery27Request {
	return TroubleshootingToolsDiagnosticsApiGetPostAggregationAppDataByQuery27Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *TroubleshootingToolsDiagnosticsApiService) GetPostAggregationAppDataByQuery27Execute(r TroubleshootingToolsDiagnosticsApiGetPostAggregationAppDataByQuery27Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TroubleshootingToolsDiagnosticsApiService.GetPostAggregationAppDataByQuery27")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/statistics/speedtest/app-agg/aggregation"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TroubleshootingToolsDiagnosticsApiGetPostAggregationDataByQuery27Request struct {
	ctx context.Context
	ApiService *TroubleshootingToolsDiagnosticsApiService
	body *map[string]interface{}
}

// Stats query string
func (r TroubleshootingToolsDiagnosticsApiGetPostAggregationDataByQuery27Request) Body(body map[string]interface{}) TroubleshootingToolsDiagnosticsApiGetPostAggregationDataByQuery27Request {
	r.body = &body
	return r
}

func (r TroubleshootingToolsDiagnosticsApiGetPostAggregationDataByQuery27Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetPostAggregationDataByQuery27Execute(r)
}

/*
GetPostAggregationDataByQuery27 Method for GetPostAggregationDataByQuery27

Get aggregated data based on input query and filters. The data can be filtered on time and other unique parameters based upon necessity and intended usage

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TroubleshootingToolsDiagnosticsApiGetPostAggregationDataByQuery27Request
*/
func (a *TroubleshootingToolsDiagnosticsApiService) GetPostAggregationDataByQuery27(ctx context.Context) TroubleshootingToolsDiagnosticsApiGetPostAggregationDataByQuery27Request {
	return TroubleshootingToolsDiagnosticsApiGetPostAggregationDataByQuery27Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *TroubleshootingToolsDiagnosticsApiService) GetPostAggregationDataByQuery27Execute(r TroubleshootingToolsDiagnosticsApiGetPostAggregationDataByQuery27Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TroubleshootingToolsDiagnosticsApiService.GetPostAggregationDataByQuery27")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stream/device/nwpi/aggregation"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TroubleshootingToolsDiagnosticsApiGetPostAggregationDataByQuery28Request struct {
	ctx context.Context
	ApiService *TroubleshootingToolsDiagnosticsApiService
	body *map[string]interface{}
}

// Stats query string
func (r TroubleshootingToolsDiagnosticsApiGetPostAggregationDataByQuery28Request) Body(body map[string]interface{}) TroubleshootingToolsDiagnosticsApiGetPostAggregationDataByQuery28Request {
	r.body = &body
	return r
}

func (r TroubleshootingToolsDiagnosticsApiGetPostAggregationDataByQuery28Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetPostAggregationDataByQuery28Execute(r)
}

/*
GetPostAggregationDataByQuery28 Method for GetPostAggregationDataByQuery28

Get aggregated data based on input query and filters. The data can be filtered on time and other unique parameters based upon necessity and intended usage

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TroubleshootingToolsDiagnosticsApiGetPostAggregationDataByQuery28Request
*/
func (a *TroubleshootingToolsDiagnosticsApiService) GetPostAggregationDataByQuery28(ctx context.Context) TroubleshootingToolsDiagnosticsApiGetPostAggregationDataByQuery28Request {
	return TroubleshootingToolsDiagnosticsApiGetPostAggregationDataByQuery28Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *TroubleshootingToolsDiagnosticsApiService) GetPostAggregationDataByQuery28Execute(r TroubleshootingToolsDiagnosticsApiGetPostAggregationDataByQuery28Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TroubleshootingToolsDiagnosticsApiService.GetPostAggregationDataByQuery28")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/statistics/speedtest/aggregation"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TroubleshootingToolsDiagnosticsApiGetPostStatBulkRawData27Request struct {
	ctx context.Context
	ApiService *TroubleshootingToolsDiagnosticsApiService
	scrollId *string
	count *string
	body *map[string]interface{}
}

// ES scroll Id
func (r TroubleshootingToolsDiagnosticsApiGetPostStatBulkRawData27Request) ScrollId(scrollId string) TroubleshootingToolsDiagnosticsApiGetPostStatBulkRawData27Request {
	r.scrollId = &scrollId
	return r
}

// Result size
func (r TroubleshootingToolsDiagnosticsApiGetPostStatBulkRawData27Request) Count(count string) TroubleshootingToolsDiagnosticsApiGetPostStatBulkRawData27Request {
	r.count = &count
	return r
}

// Stats query string
func (r TroubleshootingToolsDiagnosticsApiGetPostStatBulkRawData27Request) Body(body map[string]interface{}) TroubleshootingToolsDiagnosticsApiGetPostStatBulkRawData27Request {
	r.body = &body
	return r
}

func (r TroubleshootingToolsDiagnosticsApiGetPostStatBulkRawData27Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetPostStatBulkRawData27Execute(r)
}

/*
GetPostStatBulkRawData27 Method for GetPostStatBulkRawData27

Get stats raw data

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TroubleshootingToolsDiagnosticsApiGetPostStatBulkRawData27Request
*/
func (a *TroubleshootingToolsDiagnosticsApiService) GetPostStatBulkRawData27(ctx context.Context) TroubleshootingToolsDiagnosticsApiGetPostStatBulkRawData27Request {
	return TroubleshootingToolsDiagnosticsApiGetPostStatBulkRawData27Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *TroubleshootingToolsDiagnosticsApiService) GetPostStatBulkRawData27Execute(r TroubleshootingToolsDiagnosticsApiGetPostStatBulkRawData27Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TroubleshootingToolsDiagnosticsApiService.GetPostStatBulkRawData27")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stream/device/nwpi/page"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.scrollId != nil {
		localVarQueryParams.Add("scrollId", parameterToString(*r.scrollId, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("count", parameterToString(*r.count, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TroubleshootingToolsDiagnosticsApiGetPostStatBulkRawData28Request struct {
	ctx context.Context
	ApiService *TroubleshootingToolsDiagnosticsApiService
	scrollId *string
	count *string
	body *map[string]interface{}
}

// ES scroll Id
func (r TroubleshootingToolsDiagnosticsApiGetPostStatBulkRawData28Request) ScrollId(scrollId string) TroubleshootingToolsDiagnosticsApiGetPostStatBulkRawData28Request {
	r.scrollId = &scrollId
	return r
}

// Result size
func (r TroubleshootingToolsDiagnosticsApiGetPostStatBulkRawData28Request) Count(count string) TroubleshootingToolsDiagnosticsApiGetPostStatBulkRawData28Request {
	r.count = &count
	return r
}

// Stats query string
func (r TroubleshootingToolsDiagnosticsApiGetPostStatBulkRawData28Request) Body(body map[string]interface{}) TroubleshootingToolsDiagnosticsApiGetPostStatBulkRawData28Request {
	r.body = &body
	return r
}

func (r TroubleshootingToolsDiagnosticsApiGetPostStatBulkRawData28Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetPostStatBulkRawData28Execute(r)
}

/*
GetPostStatBulkRawData28 Method for GetPostStatBulkRawData28

Get stats raw data

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TroubleshootingToolsDiagnosticsApiGetPostStatBulkRawData28Request
*/
func (a *TroubleshootingToolsDiagnosticsApiService) GetPostStatBulkRawData28(ctx context.Context) TroubleshootingToolsDiagnosticsApiGetPostStatBulkRawData28Request {
	return TroubleshootingToolsDiagnosticsApiGetPostStatBulkRawData28Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *TroubleshootingToolsDiagnosticsApiService) GetPostStatBulkRawData28Execute(r TroubleshootingToolsDiagnosticsApiGetPostStatBulkRawData28Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TroubleshootingToolsDiagnosticsApiService.GetPostStatBulkRawData28")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/statistics/speedtest/page"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.scrollId != nil {
		localVarQueryParams.Add("scrollId", parameterToString(*r.scrollId, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("count", parameterToString(*r.count, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TroubleshootingToolsDiagnosticsApiGetSessionRequest struct {
	ctx context.Context
	ApiService *TroubleshootingToolsDiagnosticsApiService
	body *string
}

func (r TroubleshootingToolsDiagnosticsApiGetSessionRequest) Body(body string) TroubleshootingToolsDiagnosticsApiGetSessionRequest {
	r.body = &body
	return r
}

func (r TroubleshootingToolsDiagnosticsApiGetSessionRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetSessionExecute(r)
}

/*
GetSession Method for GetSession

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TroubleshootingToolsDiagnosticsApiGetSessionRequest
*/
func (a *TroubleshootingToolsDiagnosticsApiService) GetSession(ctx context.Context) TroubleshootingToolsDiagnosticsApiGetSessionRequest {
	return TroubleshootingToolsDiagnosticsApiGetSessionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *TroubleshootingToolsDiagnosticsApiService) GetSessionExecute(r TroubleshootingToolsDiagnosticsApiGetSessionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TroubleshootingToolsDiagnosticsApiService.GetSession")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stream/device/speed"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type TroubleshootingToolsDiagnosticsApiGetSessionInfoCaptureRequest struct {
	ctx context.Context
	ApiService *TroubleshootingToolsDiagnosticsApiService
	body *string
}

func (r TroubleshootingToolsDiagnosticsApiGetSessionInfoCaptureRequest) Body(body string) TroubleshootingToolsDiagnosticsApiGetSessionInfoCaptureRequest {
	r.body = &body
	return r
}

func (r TroubleshootingToolsDiagnosticsApiGetSessionInfoCaptureRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetSessionInfoCaptureExecute(r)
}

/*
GetSessionInfoCapture Method for GetSessionInfoCapture

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TroubleshootingToolsDiagnosticsApiGetSessionInfoCaptureRequest
*/
func (a *TroubleshootingToolsDiagnosticsApiService) GetSessionInfoCapture(ctx context.Context) TroubleshootingToolsDiagnosticsApiGetSessionInfoCaptureRequest {
	return TroubleshootingToolsDiagnosticsApiGetSessionInfoCaptureRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *TroubleshootingToolsDiagnosticsApiService) GetSessionInfoCaptureExecute(r TroubleshootingToolsDiagnosticsApiGetSessionInfoCaptureRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TroubleshootingToolsDiagnosticsApiService.GetSessionInfoCapture")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stream/device/capture"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type TroubleshootingToolsDiagnosticsApiGetSessionInfoLogRequest struct {
	ctx context.Context
	ApiService *TroubleshootingToolsDiagnosticsApiService
	body *string
}

func (r TroubleshootingToolsDiagnosticsApiGetSessionInfoLogRequest) Body(body string) TroubleshootingToolsDiagnosticsApiGetSessionInfoLogRequest {
	r.body = &body
	return r
}

func (r TroubleshootingToolsDiagnosticsApiGetSessionInfoLogRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetSessionInfoLogExecute(r)
}

/*
GetSessionInfoLog Method for GetSessionInfoLog

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TroubleshootingToolsDiagnosticsApiGetSessionInfoLogRequest
*/
func (a *TroubleshootingToolsDiagnosticsApiService) GetSessionInfoLog(ctx context.Context) TroubleshootingToolsDiagnosticsApiGetSessionInfoLogRequest {
	return TroubleshootingToolsDiagnosticsApiGetSessionInfoLogRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *TroubleshootingToolsDiagnosticsApiService) GetSessionInfoLogExecute(r TroubleshootingToolsDiagnosticsApiGetSessionInfoLogRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TroubleshootingToolsDiagnosticsApiService.GetSessionInfoLog")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stream/device/log"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type TroubleshootingToolsDiagnosticsApiGetSessionsRequest struct {
	ctx context.Context
	ApiService *TroubleshootingToolsDiagnosticsApiService
}

func (r TroubleshootingToolsDiagnosticsApiGetSessionsRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetSessionsExecute(r)
}

/*
GetSessions Method for GetSessions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TroubleshootingToolsDiagnosticsApiGetSessionsRequest
*/
func (a *TroubleshootingToolsDiagnosticsApiService) GetSessions(ctx context.Context) TroubleshootingToolsDiagnosticsApiGetSessionsRequest {
	return TroubleshootingToolsDiagnosticsApiGetSessionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *TroubleshootingToolsDiagnosticsApiService) GetSessionsExecute(r TroubleshootingToolsDiagnosticsApiGetSessionsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TroubleshootingToolsDiagnosticsApiService.GetSessions")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stream/device/log/sessions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type TroubleshootingToolsDiagnosticsApiGetSpeedTestRequest struct {
	ctx context.Context
	ApiService *TroubleshootingToolsDiagnosticsApiService
	sessionId Uuid
	logId *int64
}

func (r TroubleshootingToolsDiagnosticsApiGetSpeedTestRequest) LogId(logId int64) TroubleshootingToolsDiagnosticsApiGetSpeedTestRequest {
	r.logId = &logId
	return r
}

func (r TroubleshootingToolsDiagnosticsApiGetSpeedTestRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetSpeedTestExecute(r)
}

/*
GetSpeedTest Method for GetSpeedTest

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sessionId
 @return TroubleshootingToolsDiagnosticsApiGetSpeedTestRequest
*/
func (a *TroubleshootingToolsDiagnosticsApiService) GetSpeedTest(ctx context.Context, sessionId Uuid) TroubleshootingToolsDiagnosticsApiGetSpeedTestRequest {
	return TroubleshootingToolsDiagnosticsApiGetSpeedTestRequest{
		ApiService: a,
		ctx: ctx,
		sessionId: sessionId,
	}
}

// Execute executes the request
func (a *TroubleshootingToolsDiagnosticsApiService) GetSpeedTestExecute(r TroubleshootingToolsDiagnosticsApiGetSpeedTestRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TroubleshootingToolsDiagnosticsApiService.GetSpeedTest")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stream/device/speed/{sessionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"sessionId"+"}", url.PathEscape(parameterToString(r.sessionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.logId != nil {
		localVarQueryParams.Add("logId", parameterToString(*r.logId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type TroubleshootingToolsDiagnosticsApiGetSpeedTestStatusRequest struct {
	ctx context.Context
	ApiService *TroubleshootingToolsDiagnosticsApiService
	sessionId Uuid
}

func (r TroubleshootingToolsDiagnosticsApiGetSpeedTestStatusRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetSpeedTestStatusExecute(r)
}

/*
GetSpeedTestStatus Method for GetSpeedTestStatus

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sessionId
 @return TroubleshootingToolsDiagnosticsApiGetSpeedTestStatusRequest
*/
func (a *TroubleshootingToolsDiagnosticsApiService) GetSpeedTestStatus(ctx context.Context, sessionId Uuid) TroubleshootingToolsDiagnosticsApiGetSpeedTestStatusRequest {
	return TroubleshootingToolsDiagnosticsApiGetSpeedTestStatusRequest{
		ApiService: a,
		ctx: ctx,
		sessionId: sessionId,
	}
}

// Execute executes the request
func (a *TroubleshootingToolsDiagnosticsApiService) GetSpeedTestStatusExecute(r TroubleshootingToolsDiagnosticsApiGetSpeedTestStatusRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TroubleshootingToolsDiagnosticsApiService.GetSpeedTestStatus")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stream/device/speed/status/{sessionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"sessionId"+"}", url.PathEscape(parameterToString(r.sessionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type TroubleshootingToolsDiagnosticsApiGetStatBulkRawData27Request struct {
	ctx context.Context
	ApiService *TroubleshootingToolsDiagnosticsApiService
	query *string
	scrollId *string
	count *string
}

// Query string
func (r TroubleshootingToolsDiagnosticsApiGetStatBulkRawData27Request) Query(query string) TroubleshootingToolsDiagnosticsApiGetStatBulkRawData27Request {
	r.query = &query
	return r
}

// ES scroll Id
func (r TroubleshootingToolsDiagnosticsApiGetStatBulkRawData27Request) ScrollId(scrollId string) TroubleshootingToolsDiagnosticsApiGetStatBulkRawData27Request {
	r.scrollId = &scrollId
	return r
}

// Result size
func (r TroubleshootingToolsDiagnosticsApiGetStatBulkRawData27Request) Count(count string) TroubleshootingToolsDiagnosticsApiGetStatBulkRawData27Request {
	r.count = &count
	return r
}

func (r TroubleshootingToolsDiagnosticsApiGetStatBulkRawData27Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetStatBulkRawData27Execute(r)
}

/*
GetStatBulkRawData27 Method for GetStatBulkRawData27

Get stats raw data

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TroubleshootingToolsDiagnosticsApiGetStatBulkRawData27Request
*/
func (a *TroubleshootingToolsDiagnosticsApiService) GetStatBulkRawData27(ctx context.Context) TroubleshootingToolsDiagnosticsApiGetStatBulkRawData27Request {
	return TroubleshootingToolsDiagnosticsApiGetStatBulkRawData27Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *TroubleshootingToolsDiagnosticsApiService) GetStatBulkRawData27Execute(r TroubleshootingToolsDiagnosticsApiGetStatBulkRawData27Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TroubleshootingToolsDiagnosticsApiService.GetStatBulkRawData27")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stream/device/nwpi/page"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.query != nil {
		localVarQueryParams.Add("query", parameterToString(*r.query, ""))
	}
	if r.scrollId != nil {
		localVarQueryParams.Add("scrollId", parameterToString(*r.scrollId, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("count", parameterToString(*r.count, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TroubleshootingToolsDiagnosticsApiGetStatBulkRawData28Request struct {
	ctx context.Context
	ApiService *TroubleshootingToolsDiagnosticsApiService
	query *string
	scrollId *string
	count *string
}

// Query string
func (r TroubleshootingToolsDiagnosticsApiGetStatBulkRawData28Request) Query(query string) TroubleshootingToolsDiagnosticsApiGetStatBulkRawData28Request {
	r.query = &query
	return r
}

// ES scroll Id
func (r TroubleshootingToolsDiagnosticsApiGetStatBulkRawData28Request) ScrollId(scrollId string) TroubleshootingToolsDiagnosticsApiGetStatBulkRawData28Request {
	r.scrollId = &scrollId
	return r
}

// Result size
func (r TroubleshootingToolsDiagnosticsApiGetStatBulkRawData28Request) Count(count string) TroubleshootingToolsDiagnosticsApiGetStatBulkRawData28Request {
	r.count = &count
	return r
}

func (r TroubleshootingToolsDiagnosticsApiGetStatBulkRawData28Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetStatBulkRawData28Execute(r)
}

/*
GetStatBulkRawData28 Method for GetStatBulkRawData28

Get stats raw data

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TroubleshootingToolsDiagnosticsApiGetStatBulkRawData28Request
*/
func (a *TroubleshootingToolsDiagnosticsApiService) GetStatBulkRawData28(ctx context.Context) TroubleshootingToolsDiagnosticsApiGetStatBulkRawData28Request {
	return TroubleshootingToolsDiagnosticsApiGetStatBulkRawData28Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *TroubleshootingToolsDiagnosticsApiService) GetStatBulkRawData28Execute(r TroubleshootingToolsDiagnosticsApiGetStatBulkRawData28Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TroubleshootingToolsDiagnosticsApiService.GetStatBulkRawData28")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/statistics/speedtest/page"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.query != nil {
		localVarQueryParams.Add("query", parameterToString(*r.query, ""))
	}
	if r.scrollId != nil {
		localVarQueryParams.Add("scrollId", parameterToString(*r.scrollId, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("count", parameterToString(*r.count, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TroubleshootingToolsDiagnosticsApiGetStatDataFields29Request struct {
	ctx context.Context
	ApiService *TroubleshootingToolsDiagnosticsApiService
}

func (r TroubleshootingToolsDiagnosticsApiGetStatDataFields29Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetStatDataFields29Execute(r)
}

/*
GetStatDataFields29 Method for GetStatDataFields29

Get fields and type

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TroubleshootingToolsDiagnosticsApiGetStatDataFields29Request
*/
func (a *TroubleshootingToolsDiagnosticsApiService) GetStatDataFields29(ctx context.Context) TroubleshootingToolsDiagnosticsApiGetStatDataFields29Request {
	return TroubleshootingToolsDiagnosticsApiGetStatDataFields29Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *TroubleshootingToolsDiagnosticsApiService) GetStatDataFields29Execute(r TroubleshootingToolsDiagnosticsApiGetStatDataFields29Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TroubleshootingToolsDiagnosticsApiService.GetStatDataFields29")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stream/device/nwpi/fields"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TroubleshootingToolsDiagnosticsApiGetStatDataFields30Request struct {
	ctx context.Context
	ApiService *TroubleshootingToolsDiagnosticsApiService
}

func (r TroubleshootingToolsDiagnosticsApiGetStatDataFields30Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetStatDataFields30Execute(r)
}

/*
GetStatDataFields30 Method for GetStatDataFields30

Get fields and type

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TroubleshootingToolsDiagnosticsApiGetStatDataFields30Request
*/
func (a *TroubleshootingToolsDiagnosticsApiService) GetStatDataFields30(ctx context.Context) TroubleshootingToolsDiagnosticsApiGetStatDataFields30Request {
	return TroubleshootingToolsDiagnosticsApiGetStatDataFields30Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *TroubleshootingToolsDiagnosticsApiService) GetStatDataFields30Execute(r TroubleshootingToolsDiagnosticsApiGetStatDataFields30Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TroubleshootingToolsDiagnosticsApiService.GetStatDataFields30")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/statistics/speedtest/fields"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TroubleshootingToolsDiagnosticsApiGetStatDataRawData26Request struct {
	ctx context.Context
	ApiService *TroubleshootingToolsDiagnosticsApiService
	query *string
	page *int64
	pageSize *int64
	sortBy *string
	sortOrder *string
}

// Query string
func (r TroubleshootingToolsDiagnosticsApiGetStatDataRawData26Request) Query(query string) TroubleshootingToolsDiagnosticsApiGetStatDataRawData26Request {
	r.query = &query
	return r
}

// page number
func (r TroubleshootingToolsDiagnosticsApiGetStatDataRawData26Request) Page(page int64) TroubleshootingToolsDiagnosticsApiGetStatDataRawData26Request {
	r.page = &page
	return r
}

// page size
func (r TroubleshootingToolsDiagnosticsApiGetStatDataRawData26Request) PageSize(pageSize int64) TroubleshootingToolsDiagnosticsApiGetStatDataRawData26Request {
	r.pageSize = &pageSize
	return r
}

// sort by
func (r TroubleshootingToolsDiagnosticsApiGetStatDataRawData26Request) SortBy(sortBy string) TroubleshootingToolsDiagnosticsApiGetStatDataRawData26Request {
	r.sortBy = &sortBy
	return r
}

// sort order
func (r TroubleshootingToolsDiagnosticsApiGetStatDataRawData26Request) SortOrder(sortOrder string) TroubleshootingToolsDiagnosticsApiGetStatDataRawData26Request {
	r.sortOrder = &sortOrder
	return r
}

func (r TroubleshootingToolsDiagnosticsApiGetStatDataRawData26Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetStatDataRawData26Execute(r)
}

/*
GetStatDataRawData26 Method for GetStatDataRawData26

Get stats raw data

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TroubleshootingToolsDiagnosticsApiGetStatDataRawData26Request
*/
func (a *TroubleshootingToolsDiagnosticsApiService) GetStatDataRawData26(ctx context.Context) TroubleshootingToolsDiagnosticsApiGetStatDataRawData26Request {
	return TroubleshootingToolsDiagnosticsApiGetStatDataRawData26Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *TroubleshootingToolsDiagnosticsApiService) GetStatDataRawData26Execute(r TroubleshootingToolsDiagnosticsApiGetStatDataRawData26Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TroubleshootingToolsDiagnosticsApiService.GetStatDataRawData26")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stream/device/nwpi"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.query != nil {
		localVarQueryParams.Add("query", parameterToString(*r.query, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	if r.sortBy != nil {
		localVarQueryParams.Add("sortBy", parameterToString(*r.sortBy, ""))
	}
	if r.sortOrder != nil {
		localVarQueryParams.Add("sortOrder", parameterToString(*r.sortOrder, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TroubleshootingToolsDiagnosticsApiGetStatDataRawData27Request struct {
	ctx context.Context
	ApiService *TroubleshootingToolsDiagnosticsApiService
	query *string
	page *int64
	pageSize *int64
	sortBy *string
	sortOrder *string
}

// Query string
func (r TroubleshootingToolsDiagnosticsApiGetStatDataRawData27Request) Query(query string) TroubleshootingToolsDiagnosticsApiGetStatDataRawData27Request {
	r.query = &query
	return r
}

// page number
func (r TroubleshootingToolsDiagnosticsApiGetStatDataRawData27Request) Page(page int64) TroubleshootingToolsDiagnosticsApiGetStatDataRawData27Request {
	r.page = &page
	return r
}

// page size
func (r TroubleshootingToolsDiagnosticsApiGetStatDataRawData27Request) PageSize(pageSize int64) TroubleshootingToolsDiagnosticsApiGetStatDataRawData27Request {
	r.pageSize = &pageSize
	return r
}

// sort by
func (r TroubleshootingToolsDiagnosticsApiGetStatDataRawData27Request) SortBy(sortBy string) TroubleshootingToolsDiagnosticsApiGetStatDataRawData27Request {
	r.sortBy = &sortBy
	return r
}

// sort order
func (r TroubleshootingToolsDiagnosticsApiGetStatDataRawData27Request) SortOrder(sortOrder string) TroubleshootingToolsDiagnosticsApiGetStatDataRawData27Request {
	r.sortOrder = &sortOrder
	return r
}

func (r TroubleshootingToolsDiagnosticsApiGetStatDataRawData27Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetStatDataRawData27Execute(r)
}

/*
GetStatDataRawData27 Method for GetStatDataRawData27

Get stats raw data

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TroubleshootingToolsDiagnosticsApiGetStatDataRawData27Request
*/
func (a *TroubleshootingToolsDiagnosticsApiService) GetStatDataRawData27(ctx context.Context) TroubleshootingToolsDiagnosticsApiGetStatDataRawData27Request {
	return TroubleshootingToolsDiagnosticsApiGetStatDataRawData27Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *TroubleshootingToolsDiagnosticsApiService) GetStatDataRawData27Execute(r TroubleshootingToolsDiagnosticsApiGetStatDataRawData27Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TroubleshootingToolsDiagnosticsApiService.GetStatDataRawData27")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/statistics/speedtest"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.query != nil {
		localVarQueryParams.Add("query", parameterToString(*r.query, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	if r.sortBy != nil {
		localVarQueryParams.Add("sortBy", parameterToString(*r.sortBy, ""))
	}
	if r.sortOrder != nil {
		localVarQueryParams.Add("sortOrder", parameterToString(*r.sortOrder, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TroubleshootingToolsDiagnosticsApiGetStatDataRawDataAsCSV27Request struct {
	ctx context.Context
	ApiService *TroubleshootingToolsDiagnosticsApiService
	query *string
}

// Query string
func (r TroubleshootingToolsDiagnosticsApiGetStatDataRawDataAsCSV27Request) Query(query string) TroubleshootingToolsDiagnosticsApiGetStatDataRawDataAsCSV27Request {
	r.query = &query
	return r
}

func (r TroubleshootingToolsDiagnosticsApiGetStatDataRawDataAsCSV27Request) Execute() (string, *http.Response, error) {
	return r.ApiService.GetStatDataRawDataAsCSV27Execute(r)
}

/*
GetStatDataRawDataAsCSV27 Method for GetStatDataRawDataAsCSV27

Get raw data with optional query as CSV

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TroubleshootingToolsDiagnosticsApiGetStatDataRawDataAsCSV27Request
*/
func (a *TroubleshootingToolsDiagnosticsApiService) GetStatDataRawDataAsCSV27(ctx context.Context) TroubleshootingToolsDiagnosticsApiGetStatDataRawDataAsCSV27Request {
	return TroubleshootingToolsDiagnosticsApiGetStatDataRawDataAsCSV27Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return string
func (a *TroubleshootingToolsDiagnosticsApiService) GetStatDataRawDataAsCSV27Execute(r TroubleshootingToolsDiagnosticsApiGetStatDataRawDataAsCSV27Request) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TroubleshootingToolsDiagnosticsApiService.GetStatDataRawDataAsCSV27")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stream/device/nwpi/csv"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.query != nil {
		localVarQueryParams.Add("query", parameterToString(*r.query, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TroubleshootingToolsDiagnosticsApiGetStatDataRawDataAsCSV28Request struct {
	ctx context.Context
	ApiService *TroubleshootingToolsDiagnosticsApiService
	query *string
}

// Query string
func (r TroubleshootingToolsDiagnosticsApiGetStatDataRawDataAsCSV28Request) Query(query string) TroubleshootingToolsDiagnosticsApiGetStatDataRawDataAsCSV28Request {
	r.query = &query
	return r
}

func (r TroubleshootingToolsDiagnosticsApiGetStatDataRawDataAsCSV28Request) Execute() (string, *http.Response, error) {
	return r.ApiService.GetStatDataRawDataAsCSV28Execute(r)
}

/*
GetStatDataRawDataAsCSV28 Method for GetStatDataRawDataAsCSV28

Get raw data with optional query as CSV

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TroubleshootingToolsDiagnosticsApiGetStatDataRawDataAsCSV28Request
*/
func (a *TroubleshootingToolsDiagnosticsApiService) GetStatDataRawDataAsCSV28(ctx context.Context) TroubleshootingToolsDiagnosticsApiGetStatDataRawDataAsCSV28Request {
	return TroubleshootingToolsDiagnosticsApiGetStatDataRawDataAsCSV28Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return string
func (a *TroubleshootingToolsDiagnosticsApiService) GetStatDataRawDataAsCSV28Execute(r TroubleshootingToolsDiagnosticsApiGetStatDataRawDataAsCSV28Request) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TroubleshootingToolsDiagnosticsApiService.GetStatDataRawDataAsCSV28")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/statistics/speedtest/csv"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.query != nil {
		localVarQueryParams.Add("query", parameterToString(*r.query, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TroubleshootingToolsDiagnosticsApiGetStatQueryFields29Request struct {
	ctx context.Context
	ApiService *TroubleshootingToolsDiagnosticsApiService
}

func (r TroubleshootingToolsDiagnosticsApiGetStatQueryFields29Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetStatQueryFields29Execute(r)
}

/*
GetStatQueryFields29 Method for GetStatQueryFields29

Get query fields

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TroubleshootingToolsDiagnosticsApiGetStatQueryFields29Request
*/
func (a *TroubleshootingToolsDiagnosticsApiService) GetStatQueryFields29(ctx context.Context) TroubleshootingToolsDiagnosticsApiGetStatQueryFields29Request {
	return TroubleshootingToolsDiagnosticsApiGetStatQueryFields29Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *TroubleshootingToolsDiagnosticsApiService) GetStatQueryFields29Execute(r TroubleshootingToolsDiagnosticsApiGetStatQueryFields29Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TroubleshootingToolsDiagnosticsApiService.GetStatQueryFields29")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stream/device/nwpi/query/fields"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TroubleshootingToolsDiagnosticsApiGetStatQueryFields30Request struct {
	ctx context.Context
	ApiService *TroubleshootingToolsDiagnosticsApiService
}

func (r TroubleshootingToolsDiagnosticsApiGetStatQueryFields30Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetStatQueryFields30Execute(r)
}

/*
GetStatQueryFields30 Method for GetStatQueryFields30

Get query fields

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TroubleshootingToolsDiagnosticsApiGetStatQueryFields30Request
*/
func (a *TroubleshootingToolsDiagnosticsApiService) GetStatQueryFields30(ctx context.Context) TroubleshootingToolsDiagnosticsApiGetStatQueryFields30Request {
	return TroubleshootingToolsDiagnosticsApiGetStatQueryFields30Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *TroubleshootingToolsDiagnosticsApiService) GetStatQueryFields30Execute(r TroubleshootingToolsDiagnosticsApiGetStatQueryFields30Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TroubleshootingToolsDiagnosticsApiService.GetStatQueryFields30")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/statistics/speedtest/query/fields"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TroubleshootingToolsDiagnosticsApiGetStatsRawData27Request struct {
	ctx context.Context
	ApiService *TroubleshootingToolsDiagnosticsApiService
	page *int64
	pageSize *int64
	sortBy *string
	sortOrder *string
	body *map[string]interface{}
}

// page number
func (r TroubleshootingToolsDiagnosticsApiGetStatsRawData27Request) Page(page int64) TroubleshootingToolsDiagnosticsApiGetStatsRawData27Request {
	r.page = &page
	return r
}

// page size
func (r TroubleshootingToolsDiagnosticsApiGetStatsRawData27Request) PageSize(pageSize int64) TroubleshootingToolsDiagnosticsApiGetStatsRawData27Request {
	r.pageSize = &pageSize
	return r
}

// sort by
func (r TroubleshootingToolsDiagnosticsApiGetStatsRawData27Request) SortBy(sortBy string) TroubleshootingToolsDiagnosticsApiGetStatsRawData27Request {
	r.sortBy = &sortBy
	return r
}

// sort order
func (r TroubleshootingToolsDiagnosticsApiGetStatsRawData27Request) SortOrder(sortOrder string) TroubleshootingToolsDiagnosticsApiGetStatsRawData27Request {
	r.sortOrder = &sortOrder
	return r
}

// Stats query string
func (r TroubleshootingToolsDiagnosticsApiGetStatsRawData27Request) Body(body map[string]interface{}) TroubleshootingToolsDiagnosticsApiGetStatsRawData27Request {
	r.body = &body
	return r
}

func (r TroubleshootingToolsDiagnosticsApiGetStatsRawData27Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetStatsRawData27Execute(r)
}

/*
GetStatsRawData27 Method for GetStatsRawData27

Get stats raw data

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TroubleshootingToolsDiagnosticsApiGetStatsRawData27Request
*/
func (a *TroubleshootingToolsDiagnosticsApiService) GetStatsRawData27(ctx context.Context) TroubleshootingToolsDiagnosticsApiGetStatsRawData27Request {
	return TroubleshootingToolsDiagnosticsApiGetStatsRawData27Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *TroubleshootingToolsDiagnosticsApiService) GetStatsRawData27Execute(r TroubleshootingToolsDiagnosticsApiGetStatsRawData27Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TroubleshootingToolsDiagnosticsApiService.GetStatsRawData27")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stream/device/nwpi"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	if r.sortBy != nil {
		localVarQueryParams.Add("sortBy", parameterToString(*r.sortBy, ""))
	}
	if r.sortOrder != nil {
		localVarQueryParams.Add("sortOrder", parameterToString(*r.sortOrder, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TroubleshootingToolsDiagnosticsApiGetStatsRawData28Request struct {
	ctx context.Context
	ApiService *TroubleshootingToolsDiagnosticsApiService
	page *int64
	pageSize *int64
	sortBy *string
	sortOrder *string
	body *map[string]interface{}
}

// page number
func (r TroubleshootingToolsDiagnosticsApiGetStatsRawData28Request) Page(page int64) TroubleshootingToolsDiagnosticsApiGetStatsRawData28Request {
	r.page = &page
	return r
}

// page size
func (r TroubleshootingToolsDiagnosticsApiGetStatsRawData28Request) PageSize(pageSize int64) TroubleshootingToolsDiagnosticsApiGetStatsRawData28Request {
	r.pageSize = &pageSize
	return r
}

// sort by
func (r TroubleshootingToolsDiagnosticsApiGetStatsRawData28Request) SortBy(sortBy string) TroubleshootingToolsDiagnosticsApiGetStatsRawData28Request {
	r.sortBy = &sortBy
	return r
}

// sort order
func (r TroubleshootingToolsDiagnosticsApiGetStatsRawData28Request) SortOrder(sortOrder string) TroubleshootingToolsDiagnosticsApiGetStatsRawData28Request {
	r.sortOrder = &sortOrder
	return r
}

// Stats query string
func (r TroubleshootingToolsDiagnosticsApiGetStatsRawData28Request) Body(body map[string]interface{}) TroubleshootingToolsDiagnosticsApiGetStatsRawData28Request {
	r.body = &body
	return r
}

func (r TroubleshootingToolsDiagnosticsApiGetStatsRawData28Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetStatsRawData28Execute(r)
}

/*
GetStatsRawData28 Method for GetStatsRawData28

Get stats raw data

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TroubleshootingToolsDiagnosticsApiGetStatsRawData28Request
*/
func (a *TroubleshootingToolsDiagnosticsApiService) GetStatsRawData28(ctx context.Context) TroubleshootingToolsDiagnosticsApiGetStatsRawData28Request {
	return TroubleshootingToolsDiagnosticsApiGetStatsRawData28Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *TroubleshootingToolsDiagnosticsApiService) GetStatsRawData28Execute(r TroubleshootingToolsDiagnosticsApiGetStatsRawData28Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TroubleshootingToolsDiagnosticsApiService.GetStatsRawData28")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/statistics/speedtest"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	if r.sortBy != nil {
		localVarQueryParams.Add("sortBy", parameterToString(*r.sortBy, ""))
	}
	if r.sortOrder != nil {
		localVarQueryParams.Add("sortOrder", parameterToString(*r.sortOrder, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TroubleshootingToolsDiagnosticsApiGetThreadPoolsRequest struct {
	ctx context.Context
	ApiService *TroubleshootingToolsDiagnosticsApiService
}

func (r TroubleshootingToolsDiagnosticsApiGetThreadPoolsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetThreadPoolsExecute(r)
}

/*
GetThreadPools Method for GetThreadPools

Get information on the threadpools

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TroubleshootingToolsDiagnosticsApiGetThreadPoolsRequest
*/
func (a *TroubleshootingToolsDiagnosticsApiService) GetThreadPools(ctx context.Context) TroubleshootingToolsDiagnosticsApiGetThreadPoolsRequest {
	return TroubleshootingToolsDiagnosticsApiGetThreadPoolsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *TroubleshootingToolsDiagnosticsApiService) GetThreadPoolsExecute(r TroubleshootingToolsDiagnosticsApiGetThreadPoolsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TroubleshootingToolsDiagnosticsApiService.GetThreadPools")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/diagnostics/threadpools"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TroubleshootingToolsDiagnosticsApiGetTraceFlowRequest struct {
	ctx context.Context
	ApiService *TroubleshootingToolsDiagnosticsApiService
	traceId *int32
	timestamp *int64
	state *string
}

// trace id
func (r TroubleshootingToolsDiagnosticsApiGetTraceFlowRequest) TraceId(traceId int32) TroubleshootingToolsDiagnosticsApiGetTraceFlowRequest {
	r.traceId = &traceId
	return r
}

// start time
func (r TroubleshootingToolsDiagnosticsApiGetTraceFlowRequest) Timestamp(timestamp int64) TroubleshootingToolsDiagnosticsApiGetTraceFlowRequest {
	r.timestamp = &timestamp
	return r
}

// trace state
func (r TroubleshootingToolsDiagnosticsApiGetTraceFlowRequest) State(state string) TroubleshootingToolsDiagnosticsApiGetTraceFlowRequest {
	r.state = &state
	return r
}

func (r TroubleshootingToolsDiagnosticsApiGetTraceFlowRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetTraceFlowExecute(r)
}

/*
GetTraceFlow Method for GetTraceFlow

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TroubleshootingToolsDiagnosticsApiGetTraceFlowRequest
*/
func (a *TroubleshootingToolsDiagnosticsApiService) GetTraceFlow(ctx context.Context) TroubleshootingToolsDiagnosticsApiGetTraceFlowRequest {
	return TroubleshootingToolsDiagnosticsApiGetTraceFlowRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *TroubleshootingToolsDiagnosticsApiService) GetTraceFlowExecute(r TroubleshootingToolsDiagnosticsApiGetTraceFlowRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TroubleshootingToolsDiagnosticsApiService.GetTraceFlow")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stream/device/nwpi/traceFlow"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.traceId == nil {
		return nil, reportError("traceId is required and must be specified")
	}
	if r.timestamp == nil {
		return nil, reportError("timestamp is required and must be specified")
	}
	if r.state == nil {
		return nil, reportError("state is required and must be specified")
	}

	localVarQueryParams.Add("traceId", parameterToString(*r.traceId, ""))
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("state", parameterToString(*r.state, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type TroubleshootingToolsDiagnosticsApiGetTraceHistoryRequest struct {
	ctx context.Context
	ApiService *TroubleshootingToolsDiagnosticsApiService
}

func (r TroubleshootingToolsDiagnosticsApiGetTraceHistoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetTraceHistoryExecute(r)
}

/*
GetTraceHistory Method for GetTraceHistory

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TroubleshootingToolsDiagnosticsApiGetTraceHistoryRequest
*/
func (a *TroubleshootingToolsDiagnosticsApiService) GetTraceHistory(ctx context.Context) TroubleshootingToolsDiagnosticsApiGetTraceHistoryRequest {
	return TroubleshootingToolsDiagnosticsApiGetTraceHistoryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *TroubleshootingToolsDiagnosticsApiService) GetTraceHistoryExecute(r TroubleshootingToolsDiagnosticsApiGetTraceHistoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TroubleshootingToolsDiagnosticsApiService.GetTraceHistory")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stream/device/nwpi/traceHistory"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type TroubleshootingToolsDiagnosticsApiGetVnicInfoByVnfIdRequest struct {
	ctx context.Context
	ApiService *TroubleshootingToolsDiagnosticsApiService
	vnfId string
}

func (r TroubleshootingToolsDiagnosticsApiGetVnicInfoByVnfIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetVnicInfoByVnfIdExecute(r)
}

/*
GetVnicInfoByVnfId Method for GetVnicInfoByVnfId

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param vnfId
 @return TroubleshootingToolsDiagnosticsApiGetVnicInfoByVnfIdRequest
*/
func (a *TroubleshootingToolsDiagnosticsApiService) GetVnicInfoByVnfId(ctx context.Context, vnfId string) TroubleshootingToolsDiagnosticsApiGetVnicInfoByVnfIdRequest {
	return TroubleshootingToolsDiagnosticsApiGetVnicInfoByVnfIdRequest{
		ApiService: a,
		ctx: ctx,
		vnfId: vnfId,
	}
}

// Execute executes the request
func (a *TroubleshootingToolsDiagnosticsApiService) GetVnicInfoByVnfIdExecute(r TroubleshootingToolsDiagnosticsApiGetVnicInfoByVnfIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TroubleshootingToolsDiagnosticsApiService.GetVnicInfoByVnfId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stream/device/capture/vnicsInfo/{vnfId}"
	localVarPath = strings.Replace(localVarPath, "{"+"vnfId"+"}", url.PathEscape(parameterToString(r.vnfId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type TroubleshootingToolsDiagnosticsApiMonitorStartRequest struct {
	ctx context.Context
	ApiService *TroubleshootingToolsDiagnosticsApiService
	body *map[string]interface{}
}

func (r TroubleshootingToolsDiagnosticsApiMonitorStartRequest) Body(body map[string]interface{}) TroubleshootingToolsDiagnosticsApiMonitorStartRequest {
	r.body = &body
	return r
}

func (r TroubleshootingToolsDiagnosticsApiMonitorStartRequest) Execute() (*http.Response, error) {
	return r.ApiService.MonitorStartExecute(r)
}

/*
MonitorStart Method for MonitorStart

CXP Monitor Action - Start

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TroubleshootingToolsDiagnosticsApiMonitorStartRequest
*/
func (a *TroubleshootingToolsDiagnosticsApiService) MonitorStart(ctx context.Context) TroubleshootingToolsDiagnosticsApiMonitorStartRequest {
	return TroubleshootingToolsDiagnosticsApiMonitorStartRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *TroubleshootingToolsDiagnosticsApiService) MonitorStartExecute(r TroubleshootingToolsDiagnosticsApiMonitorStartRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TroubleshootingToolsDiagnosticsApiService.MonitorStart")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stream/device/nwpi/monitor/start"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type TroubleshootingToolsDiagnosticsApiMonitorStopRequest struct {
	ctx context.Context
	ApiService *TroubleshootingToolsDiagnosticsApiService
	body *map[string]interface{}
}

func (r TroubleshootingToolsDiagnosticsApiMonitorStopRequest) Body(body map[string]interface{}) TroubleshootingToolsDiagnosticsApiMonitorStopRequest {
	r.body = &body
	return r
}

func (r TroubleshootingToolsDiagnosticsApiMonitorStopRequest) Execute() (*http.Response, error) {
	return r.ApiService.MonitorStopExecute(r)
}

/*
MonitorStop Method for MonitorStop

CXP Monitor Action - Stop

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TroubleshootingToolsDiagnosticsApiMonitorStopRequest
*/
func (a *TroubleshootingToolsDiagnosticsApiService) MonitorStop(ctx context.Context) TroubleshootingToolsDiagnosticsApiMonitorStopRequest {
	return TroubleshootingToolsDiagnosticsApiMonitorStopRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *TroubleshootingToolsDiagnosticsApiService) MonitorStopExecute(r TroubleshootingToolsDiagnosticsApiMonitorStopRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TroubleshootingToolsDiagnosticsApiService.MonitorStop")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stream/device/nwpi/monitor/stop"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type TroubleshootingToolsDiagnosticsApiProcessDeviceStatusRequest struct {
	ctx context.Context
	ApiService *TroubleshootingToolsDiagnosticsApiService
	deviceUUID string
	body *string
}

func (r TroubleshootingToolsDiagnosticsApiProcessDeviceStatusRequest) Body(body string) TroubleshootingToolsDiagnosticsApiProcessDeviceStatusRequest {
	r.body = &body
	return r
}

func (r TroubleshootingToolsDiagnosticsApiProcessDeviceStatusRequest) Execute() (*http.Response, error) {
	return r.ApiService.ProcessDeviceStatusExecute(r)
}

/*
ProcessDeviceStatus Method for ProcessDeviceStatus

Get device status stream

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceUUID Device uuid
 @return TroubleshootingToolsDiagnosticsApiProcessDeviceStatusRequest
*/
func (a *TroubleshootingToolsDiagnosticsApiService) ProcessDeviceStatus(ctx context.Context, deviceUUID string) TroubleshootingToolsDiagnosticsApiProcessDeviceStatusRequest {
	return TroubleshootingToolsDiagnosticsApiProcessDeviceStatusRequest{
		ApiService: a,
		ctx: ctx,
		deviceUUID: deviceUUID,
	}
}

// Execute executes the request
func (a *TroubleshootingToolsDiagnosticsApiService) ProcessDeviceStatusExecute(r TroubleshootingToolsDiagnosticsApiProcessDeviceStatusRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TroubleshootingToolsDiagnosticsApiService.ProcessDeviceStatus")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stream/device/status/{deviceUUID}"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceUUID"+"}", url.PathEscape(parameterToString(r.deviceUUID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type TroubleshootingToolsDiagnosticsApiRenewSessionInfoRequest struct {
	ctx context.Context
	ApiService *TroubleshootingToolsDiagnosticsApiService
	sessionId Uuid
}

func (r TroubleshootingToolsDiagnosticsApiRenewSessionInfoRequest) Execute() (*http.Response, error) {
	return r.ApiService.RenewSessionInfoExecute(r)
}

/*
RenewSessionInfo Method for RenewSessionInfo

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sessionId
 @return TroubleshootingToolsDiagnosticsApiRenewSessionInfoRequest
*/
func (a *TroubleshootingToolsDiagnosticsApiService) RenewSessionInfo(ctx context.Context, sessionId Uuid) TroubleshootingToolsDiagnosticsApiRenewSessionInfoRequest {
	return TroubleshootingToolsDiagnosticsApiRenewSessionInfoRequest{
		ApiService: a,
		ctx: ctx,
		sessionId: sessionId,
	}
}

// Execute executes the request
func (a *TroubleshootingToolsDiagnosticsApiService) RenewSessionInfoExecute(r TroubleshootingToolsDiagnosticsApiRenewSessionInfoRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TroubleshootingToolsDiagnosticsApiService.RenewSessionInfo")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stream/device/log/renew/{sessionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"sessionId"+"}", url.PathEscape(parameterToString(r.sessionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type TroubleshootingToolsDiagnosticsApiSaveSpeedTestResultsRequest struct {
	ctx context.Context
	ApiService *TroubleshootingToolsDiagnosticsApiService
	deviceUUID string
	sessionId Uuid
	body *string
}

func (r TroubleshootingToolsDiagnosticsApiSaveSpeedTestResultsRequest) Body(body string) TroubleshootingToolsDiagnosticsApiSaveSpeedTestResultsRequest {
	r.body = &body
	return r
}

func (r TroubleshootingToolsDiagnosticsApiSaveSpeedTestResultsRequest) Execute() (*http.Response, error) {
	return r.ApiService.SaveSpeedTestResultsExecute(r)
}

/*
SaveSpeedTestResults Method for SaveSpeedTestResults

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceUUID
 @param sessionId
 @return TroubleshootingToolsDiagnosticsApiSaveSpeedTestResultsRequest
*/
func (a *TroubleshootingToolsDiagnosticsApiService) SaveSpeedTestResults(ctx context.Context, deviceUUID string, sessionId Uuid) TroubleshootingToolsDiagnosticsApiSaveSpeedTestResultsRequest {
	return TroubleshootingToolsDiagnosticsApiSaveSpeedTestResultsRequest{
		ApiService: a,
		ctx: ctx,
		deviceUUID: deviceUUID,
		sessionId: sessionId,
	}
}

// Execute executes the request
func (a *TroubleshootingToolsDiagnosticsApiService) SaveSpeedTestResultsExecute(r TroubleshootingToolsDiagnosticsApiSaveSpeedTestResultsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TroubleshootingToolsDiagnosticsApiService.SaveSpeedTestResults")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stream/device/speed/{deviceUUID}/{sessionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceUUID"+"}", url.PathEscape(parameterToString(r.deviceUUID, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sessionId"+"}", url.PathEscape(parameterToString(r.sessionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type TroubleshootingToolsDiagnosticsApiSearchDeviceLogRequest struct {
	ctx context.Context
	ApiService *TroubleshootingToolsDiagnosticsApiService
	sessionId string
	body *string
}

func (r TroubleshootingToolsDiagnosticsApiSearchDeviceLogRequest) Body(body string) TroubleshootingToolsDiagnosticsApiSearchDeviceLogRequest {
	r.body = &body
	return r
}

func (r TroubleshootingToolsDiagnosticsApiSearchDeviceLogRequest) Execute() (*http.Response, error) {
	return r.ApiService.SearchDeviceLogExecute(r)
}

/*
SearchDeviceLog Method for SearchDeviceLog

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sessionId Session Id
 @return TroubleshootingToolsDiagnosticsApiSearchDeviceLogRequest
*/
func (a *TroubleshootingToolsDiagnosticsApiService) SearchDeviceLog(ctx context.Context, sessionId string) TroubleshootingToolsDiagnosticsApiSearchDeviceLogRequest {
	return TroubleshootingToolsDiagnosticsApiSearchDeviceLogRequest{
		ApiService: a,
		ctx: ctx,
		sessionId: sessionId,
	}
}

// Execute executes the request
func (a *TroubleshootingToolsDiagnosticsApiService) SearchDeviceLogExecute(r TroubleshootingToolsDiagnosticsApiSearchDeviceLogRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TroubleshootingToolsDiagnosticsApiService.SearchDeviceLog")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stream/device/log/search/{sessionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"sessionId"+"}", url.PathEscape(parameterToString(r.sessionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type TroubleshootingToolsDiagnosticsApiStartPcapSessionRequest struct {
	ctx context.Context
	ApiService *TroubleshootingToolsDiagnosticsApiService
	sessionId Uuid
}

func (r TroubleshootingToolsDiagnosticsApiStartPcapSessionRequest) Execute() (*http.Response, error) {
	return r.ApiService.StartPcapSessionExecute(r)
}

/*
StartPcapSession Method for StartPcapSession

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sessionId
 @return TroubleshootingToolsDiagnosticsApiStartPcapSessionRequest
*/
func (a *TroubleshootingToolsDiagnosticsApiService) StartPcapSession(ctx context.Context, sessionId Uuid) TroubleshootingToolsDiagnosticsApiStartPcapSessionRequest {
	return TroubleshootingToolsDiagnosticsApiStartPcapSessionRequest{
		ApiService: a,
		ctx: ctx,
		sessionId: sessionId,
	}
}

// Execute executes the request
func (a *TroubleshootingToolsDiagnosticsApiService) StartPcapSessionExecute(r TroubleshootingToolsDiagnosticsApiStartPcapSessionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TroubleshootingToolsDiagnosticsApiService.StartPcapSession")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stream/device/capture/start/{sessionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"sessionId"+"}", url.PathEscape(parameterToString(r.sessionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type TroubleshootingToolsDiagnosticsApiStartSpeedTestRequest struct {
	ctx context.Context
	ApiService *TroubleshootingToolsDiagnosticsApiService
	sessionId Uuid
}

func (r TroubleshootingToolsDiagnosticsApiStartSpeedTestRequest) Execute() (*http.Response, error) {
	return r.ApiService.StartSpeedTestExecute(r)
}

/*
StartSpeedTest Method for StartSpeedTest

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sessionId
 @return TroubleshootingToolsDiagnosticsApiStartSpeedTestRequest
*/
func (a *TroubleshootingToolsDiagnosticsApiService) StartSpeedTest(ctx context.Context, sessionId Uuid) TroubleshootingToolsDiagnosticsApiStartSpeedTestRequest {
	return TroubleshootingToolsDiagnosticsApiStartSpeedTestRequest{
		ApiService: a,
		ctx: ctx,
		sessionId: sessionId,
	}
}

// Execute executes the request
func (a *TroubleshootingToolsDiagnosticsApiService) StartSpeedTestExecute(r TroubleshootingToolsDiagnosticsApiStartSpeedTestRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TroubleshootingToolsDiagnosticsApiService.StartSpeedTest")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stream/device/speed/start/{sessionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"sessionId"+"}", url.PathEscape(parameterToString(r.sessionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type TroubleshootingToolsDiagnosticsApiStopPcapSessionRequest struct {
	ctx context.Context
	ApiService *TroubleshootingToolsDiagnosticsApiService
	sessionId Uuid
}

func (r TroubleshootingToolsDiagnosticsApiStopPcapSessionRequest) Execute() (*http.Response, error) {
	return r.ApiService.StopPcapSessionExecute(r)
}

/*
StopPcapSession Method for StopPcapSession

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sessionId
 @return TroubleshootingToolsDiagnosticsApiStopPcapSessionRequest
*/
func (a *TroubleshootingToolsDiagnosticsApiService) StopPcapSession(ctx context.Context, sessionId Uuid) TroubleshootingToolsDiagnosticsApiStopPcapSessionRequest {
	return TroubleshootingToolsDiagnosticsApiStopPcapSessionRequest{
		ApiService: a,
		ctx: ctx,
		sessionId: sessionId,
	}
}

// Execute executes the request
func (a *TroubleshootingToolsDiagnosticsApiService) StopPcapSessionExecute(r TroubleshootingToolsDiagnosticsApiStopPcapSessionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TroubleshootingToolsDiagnosticsApiService.StopPcapSession")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stream/device/capture/stop/{sessionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"sessionId"+"}", url.PathEscape(parameterToString(r.sessionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type TroubleshootingToolsDiagnosticsApiStopSpeedTestRequest struct {
	ctx context.Context
	ApiService *TroubleshootingToolsDiagnosticsApiService
	sessionId Uuid
}

func (r TroubleshootingToolsDiagnosticsApiStopSpeedTestRequest) Execute() (*http.Response, error) {
	return r.ApiService.StopSpeedTestExecute(r)
}

/*
StopSpeedTest Method for StopSpeedTest

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sessionId
 @return TroubleshootingToolsDiagnosticsApiStopSpeedTestRequest
*/
func (a *TroubleshootingToolsDiagnosticsApiService) StopSpeedTest(ctx context.Context, sessionId Uuid) TroubleshootingToolsDiagnosticsApiStopSpeedTestRequest {
	return TroubleshootingToolsDiagnosticsApiStopSpeedTestRequest{
		ApiService: a,
		ctx: ctx,
		sessionId: sessionId,
	}
}

// Execute executes the request
func (a *TroubleshootingToolsDiagnosticsApiService) StopSpeedTestExecute(r TroubleshootingToolsDiagnosticsApiStopSpeedTestRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TroubleshootingToolsDiagnosticsApiService.StopSpeedTest")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stream/device/speed/stop/{sessionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"sessionId"+"}", url.PathEscape(parameterToString(r.sessionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type TroubleshootingToolsDiagnosticsApiStreamLogRequest struct {
	ctx context.Context
	ApiService *TroubleshootingToolsDiagnosticsApiService
	logType string
	deviceUUID string
	sessionId string
	body *string
}

func (r TroubleshootingToolsDiagnosticsApiStreamLogRequest) Body(body string) TroubleshootingToolsDiagnosticsApiStreamLogRequest {
	r.body = &body
	return r
}

func (r TroubleshootingToolsDiagnosticsApiStreamLogRequest) Execute() (*http.Response, error) {
	return r.ApiService.StreamLogExecute(r)
}

/*
StreamLog Method for StreamLog

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param logType Log type
 @param deviceUUID Device uuid
 @param sessionId Session Id
 @return TroubleshootingToolsDiagnosticsApiStreamLogRequest
*/
func (a *TroubleshootingToolsDiagnosticsApiService) StreamLog(ctx context.Context, logType string, deviceUUID string, sessionId string) TroubleshootingToolsDiagnosticsApiStreamLogRequest {
	return TroubleshootingToolsDiagnosticsApiStreamLogRequest{
		ApiService: a,
		ctx: ctx,
		logType: logType,
		deviceUUID: deviceUUID,
		sessionId: sessionId,
	}
}

// Execute executes the request
func (a *TroubleshootingToolsDiagnosticsApiService) StreamLogExecute(r TroubleshootingToolsDiagnosticsApiStreamLogRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TroubleshootingToolsDiagnosticsApiService.StreamLog")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stream/device/log/{logType}/{deviceUUID}/{sessionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"logType"+"}", url.PathEscape(parameterToString(r.logType, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"deviceUUID"+"}", url.PathEscape(parameterToString(r.deviceUUID, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sessionId"+"}", url.PathEscape(parameterToString(r.sessionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type TroubleshootingToolsDiagnosticsApiTraceDeleteRequest struct {
	ctx context.Context
	ApiService *TroubleshootingToolsDiagnosticsApiService
	traceId *string
	timestamp *int64
}

// trace id
func (r TroubleshootingToolsDiagnosticsApiTraceDeleteRequest) TraceId(traceId string) TroubleshootingToolsDiagnosticsApiTraceDeleteRequest {
	r.traceId = &traceId
	return r
}

// start time
func (r TroubleshootingToolsDiagnosticsApiTraceDeleteRequest) Timestamp(timestamp int64) TroubleshootingToolsDiagnosticsApiTraceDeleteRequest {
	r.timestamp = &timestamp
	return r
}

func (r TroubleshootingToolsDiagnosticsApiTraceDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.TraceDeleteExecute(r)
}

/*
TraceDelete Method for TraceDelete

Trace Action - Delete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TroubleshootingToolsDiagnosticsApiTraceDeleteRequest
*/
func (a *TroubleshootingToolsDiagnosticsApiService) TraceDelete(ctx context.Context) TroubleshootingToolsDiagnosticsApiTraceDeleteRequest {
	return TroubleshootingToolsDiagnosticsApiTraceDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *TroubleshootingToolsDiagnosticsApiService) TraceDeleteExecute(r TroubleshootingToolsDiagnosticsApiTraceDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TroubleshootingToolsDiagnosticsApiService.TraceDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stream/device/nwpi/trace/delete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.traceId == nil {
		return nil, reportError("traceId is required and must be specified")
	}
	if r.timestamp == nil {
		return nil, reportError("timestamp is required and must be specified")
	}

	localVarQueryParams.Add("traceId", parameterToString(*r.traceId, ""))
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type TroubleshootingToolsDiagnosticsApiTraceFinFlowWithQueryRequest struct {
	ctx context.Context
	ApiService *TroubleshootingToolsDiagnosticsApiService
	traceId *int32
	timestamp *int64
	query *string
}

// trace id
func (r TroubleshootingToolsDiagnosticsApiTraceFinFlowWithQueryRequest) TraceId(traceId int32) TroubleshootingToolsDiagnosticsApiTraceFinFlowWithQueryRequest {
	r.traceId = &traceId
	return r
}

// start time
func (r TroubleshootingToolsDiagnosticsApiTraceFinFlowWithQueryRequest) Timestamp(timestamp int64) TroubleshootingToolsDiagnosticsApiTraceFinFlowWithQueryRequest {
	r.timestamp = &timestamp
	return r
}

// Query filter
func (r TroubleshootingToolsDiagnosticsApiTraceFinFlowWithQueryRequest) Query(query string) TroubleshootingToolsDiagnosticsApiTraceFinFlowWithQueryRequest {
	r.query = &query
	return r
}

func (r TroubleshootingToolsDiagnosticsApiTraceFinFlowWithQueryRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.TraceFinFlowWithQueryExecute(r)
}

/*
TraceFinFlowWithQuery Method for TraceFinFlowWithQuery

Retrieve Certain Fin Flows

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TroubleshootingToolsDiagnosticsApiTraceFinFlowWithQueryRequest
*/
func (a *TroubleshootingToolsDiagnosticsApiService) TraceFinFlowWithQuery(ctx context.Context) TroubleshootingToolsDiagnosticsApiTraceFinFlowWithQueryRequest {
	return TroubleshootingToolsDiagnosticsApiTraceFinFlowWithQueryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *TroubleshootingToolsDiagnosticsApiService) TraceFinFlowWithQueryExecute(r TroubleshootingToolsDiagnosticsApiTraceFinFlowWithQueryRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TroubleshootingToolsDiagnosticsApiService.TraceFinFlowWithQuery")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stream/device/nwpi/traceFinFlowWithQuery"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.traceId == nil {
		return localVarReturnValue, nil, reportError("traceId is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}

	localVarQueryParams.Add("traceId", parameterToString(*r.traceId, ""))
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	if r.query != nil {
		localVarQueryParams.Add("query", parameterToString(*r.query, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TroubleshootingToolsDiagnosticsApiTraceStartRequest struct {
	ctx context.Context
	ApiService *TroubleshootingToolsDiagnosticsApiService
	body *map[string]interface{}
}

func (r TroubleshootingToolsDiagnosticsApiTraceStartRequest) Body(body map[string]interface{}) TroubleshootingToolsDiagnosticsApiTraceStartRequest {
	r.body = &body
	return r
}

func (r TroubleshootingToolsDiagnosticsApiTraceStartRequest) Execute() (*http.Response, error) {
	return r.ApiService.TraceStartExecute(r)
}

/*
TraceStart Method for TraceStart

Trace Action - Start

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TroubleshootingToolsDiagnosticsApiTraceStartRequest
*/
func (a *TroubleshootingToolsDiagnosticsApiService) TraceStart(ctx context.Context) TroubleshootingToolsDiagnosticsApiTraceStartRequest {
	return TroubleshootingToolsDiagnosticsApiTraceStartRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *TroubleshootingToolsDiagnosticsApiService) TraceStartExecute(r TroubleshootingToolsDiagnosticsApiTraceStartRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TroubleshootingToolsDiagnosticsApiService.TraceStart")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stream/device/nwpi/trace/start"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type TroubleshootingToolsDiagnosticsApiTraceStopRequest struct {
	ctx context.Context
	ApiService *TroubleshootingToolsDiagnosticsApiService
	traceId string
}

func (r TroubleshootingToolsDiagnosticsApiTraceStopRequest) Execute() (*http.Response, error) {
	return r.ApiService.TraceStopExecute(r)
}

/*
TraceStop Method for TraceStop

Trace Action - Stop

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param traceId
 @return TroubleshootingToolsDiagnosticsApiTraceStopRequest
*/
func (a *TroubleshootingToolsDiagnosticsApiService) TraceStop(ctx context.Context, traceId string) TroubleshootingToolsDiagnosticsApiTraceStopRequest {
	return TroubleshootingToolsDiagnosticsApiTraceStopRequest{
		ApiService: a,
		ctx: ctx,
		traceId: traceId,
	}
}

// Execute executes the request
func (a *TroubleshootingToolsDiagnosticsApiService) TraceStopExecute(r TroubleshootingToolsDiagnosticsApiTraceStopRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TroubleshootingToolsDiagnosticsApiService.TraceStop")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stream/device/nwpi/trace/stop/{traceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"traceId"+"}", url.PathEscape(parameterToString(r.traceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
